% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
NecromancerGuild is Guild 

constants:

   include blakston.khd
   include protocol.khd
   
   CANNOT_REJOIN_TIME = 30   %% 30 6-minute intervals = 3 hours

   MAX_MEMBERS = 400         %% maximum number of people allowed in a guild.

   THREE_PERSON_LIMIT = 240    

   MINIMUM_MEMBERS = 3

   RENT_BASE = 5
   RENT_SECRET = 10

   RENT_PER_MEMBER = 1
   RENT_PER_ALLY = -2
   RENT_PER_ENEMY = 5

   RENT_MAX_OVERDUE = 480   %% this is in 6 minute periods.

resources:

   NecromancerGuild_name_rsc = "Orden der Nekromanten"
   NecromancerGuild_icon_rsc = idarknes.bgf
   NecromancerGuild_desc_rsc = "Ein altertümlicher Orden böser Magier, die beabsichtigen, Dunkelheit über die Welt zu bringen."


   NecromancerGuild_master = "Höchster Nekromant"
   NecromancerGuild_mistress = "Höchste Nekromantin"
   NecromancerGuild_lieutenant_Male = "Todesmagier"
   NecromancerGuild_lieutenant_female = "Todesmagierin"
   NecromancerGuild_lord = "Hexer"
   NecromancerGuild_lady = "Hexe"
   NecromancerGuild_sir = "Eingeweihter"
   NecromancerGuild_madame = "Eingeweihte"
   NecromancerGuild_apprentice = "Grünschnabel"
   NecromancerGuild_apprenticette = "Grünschnabel"

   NecromancerGuild_threeperson_failing = "Der Orden der Nekromanten hat weniger als 3 Mitglieder. Wenn Du die Mitgliederzahl nicht innerhalb der nächsten %i %s auf drei erhöhst, wird meine Herrschaft über diese Realitätsebene nachlassen und Ihr werdet alle mit mir umkommen!"



   NecromancerGuild_threeperson_failed = "Der Orden der Nekromanten wurde wegen Mitgliedermangels aufgelöst."

   NecromancerGuild_welcome = "~BHeißt das neueste Mitglied der Gilde %s%q willkommen: %s!"
   NecromancerGuild_induct_already_guilded = "Du bist bereits Mitglied einer Gilde."
   NecromancerGuild_induct_already_member = "Du bist bereits Mitglied dieser Gilde."

   NecromancerGuild_lieut_cant_promote = "%ss kann Gildenmitglieder nicht über den Rang %s befördern."
   NecromancerGuild_cant_promote_lieut = "Du kannst niemanden über %s befördern, da es nur einen %s geben kann."
   NecromancerGuild_cant_promote_capt = "Eine Gilde darf nicht mehr als zwei Mitglieder des Ranges %s haben."
   NecromancerGuild_cant_promote_sire = "Es gibt zu viele Mitglieder des Ranges %s, um ein weiteres Mitglied in diesen Status zu befördern."

   NecromancerGuild_promotee = "~B%q hat Dir den Rang %s verliehen!"
   NecromancerGuild_promoter = "~BDu beförderst %q in den Rang %s. "
   NecromancerGuild_promoted = "~B%s hat %q den Rang %s verliehen. "
   NecromancerGuild_promotee_no_promoter = "~BDu wurdest in den Rang %s befördert!"
   NecromancerGuild_promote_too_high = "Du kannst niemand auf einen Rang befördern, der gar nicht existiert!"

   NecromancerGuild_demotee = "~B%q hat Dich in den Rang %s degradiert!"
   NecromancerGuild_demoter = "~BDu degradierst %q in den Rang %s!"
   NecromancerGuild_demoted = "~B%s hat %q in den Rang %s degradiert."
   NecromancerGuild_demotee_no_demoter = "~BDu wurdest in den Rang %s degradiert!"

   NecromancerGuild_demote_apprentice = "Du kannst niemanden des Ranges %s degradieren! Es geht nicht niedriger!"
   NecromancerGuild_demote_equal_higher = "Du kannst niemand herabsetzen, der den gleichen oder höheren Rang als Du besitzt!"

   NecromancerGuild_cant_vote_outsider = "Du kannst nicht für %q%s stimmen. Diese Person gehört nicht der Gilde %s%q an!"
   NecromancerGuild_cant_vote_nonuser = "%s%s bedankt sich für Deine Unterstützung."

   NecromancerGuild_descension = "~BDu wurdest als %s von %s%q verdrängt!"
   NecromancerGuild_ascension = "~BGlückwunsch! Du bist %s von %s%q!"

   NecromancerGuild_reassure = "~B%s verspricht Dir, Dich weiterhin politisch zu unterstützen."
   NecromancerGuild_talking_to_self = "~BDu versicherst Dir noch einmal selbst, dass Du Dich wirklich magst."
   NecromancerGuild_support_withers = "~BDu spürst, dass Du immer weniger politische Unterstützung bekommst."

   NecromancerGuild_support_self = "~BDu beschließt, selbst Deinen Führungsanspruch über %s%q anzumelden."
   NecromancerGuild_support_other = "~BDu schwörst, %q bei der Führung der Gilde %s%q zu unterstützen."
   NecromancerGuild_supported = "~B%s schwört, Dich bei Deinem Führungsanspruch über %s%q zu unterstützen."

   NecromancerGuild_new_master = "~BGratuliere %q, %s von %s%q!"
   NecromancerGuild_abdicate = "~B%s hat beschlossen, die Führung der Gilde %s%q niederzulegen."

   NecromancerGuild_allies_defunct = "~BDein ehrenwerter Verbündeter, die Gilde %s%q, hat sich losgesagt."
   NecromancerGuild_enemies_defunct = "~BDein verhaßter Feind, die Gilde %s%q, hat sich aufgelöst."

   NecromancerGuild_cant_ally_enemy = "Du kannst Dich mit der Gilde %s%q nicht verbünden! Sie sind Deine erklärten Feinde!"
   NecromancerGuild_already_allies = "Deine Gilde ist bereits mit der Gilde %s%q verbündet!"
   NecromancerGuild_not_member_currently = "Du bist kein Mitglied der Gilde %s%q und kannst in ihrem Namen keine Bündnisse abschließen!"
   NecromancerGuild_not_qualified = "Du bist nicht hochrangig genug, um Bündnisse mit anderen Gilden abzuschließen!"
   NecromancerGuild_cant_enemy_ally = "Du kannst eine andere Gilde nicht zum Feind erklären, bevor Du nicht das Bündnis mit ihr aufgekündigt hast!"
   NecromancerGuild_already_enemies = "Die Mitglieder der Gilde %s%q sind bereits die verhaßten Gegner der Gilde %s%q!"

   NecromancerGuild_new_allies = "~BHeute ist der Tag, an dem das Bündnis zwischen den Gilden %s%q und %s%q in Kraft tritt."
   NecromancerGuild_new_enemies = "~BHiermit wird bekanntgegeben, dass die Mitglieder der Gilde %s%q die erklärten Feinde der Gilde %s%q sind!"
   NecromancerGuild_declared_enemies = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q der Gilde %s%q feindlich gesinnt ist!"
   NecromancerGuild_declared_allies = "~BHiermit wird bekanntgegeben, dass sich die Gilde %s%q mit Deiner Gilde %s%q verbündet hat!"

   NecromancerGuild_end_alliance = "~BHiermit wird bekanntgegeben, dass das Bündnis zwischen den Gilden %s%q und %s%q zerbrochen ist!"
   NecromancerGuild_not_enemies = "~BHiermit wird bekanntgegeben, dass die Mitglieder der Gilde %s%q der Gilde %s%q nicht mehr feindlich gesinnt sind."

   NecromancerGuild_end_declared_alliance = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q ihr Bündnis mit der Gilde %s%q aufkündigen will."

   NecromancerGuild_not_declared_enemies = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q ihre Feindschaft mit der Gilde %s%q beendet hat."

   NecromancerGuild_mature = "~BDie Gilde %s%q ist nun eine vollwertige Gilde, die selbst Hallen besitzen und einnehmen kann."

   NecromancerGuild_hour_rsc = "Stunde"
   NecromancerGuild_hours_rsc = "Stunden"

   NecromancerGuild_rent_nonpayment = "~BDeine dunkle Königin ist vor Hunger umgekommen.Dein Amulett explodiert und reißt Deinen Körper in Fetzen."

   NecromancerGuild_rent_due_5 = "~BKönigin Venya'cyr sagt \"~r~BOh, meine unachtsamen Diener! Mein Hunger brennt wie Kohle in meiner Brust, und Ihr habt mich verlassen! Wenn ich in den nächsten %i %s nicht ausreichend gefüttert werde, gefüttert werde, werde ich zurück in die Dunkelheit gehen, und Ihr werdet mir alle folgen!~n~B\""



   NecromancerGuild_rent_due_4 = "~BQueen Venya'cyr sagt Dir, \"~r~BIch habe sehr großen Hunger, meine Untertanen. Ihr habt Eure Pflichten mir gegenüber grob vernachlässigt. Meine physische Erscheinung löst sich auf... Wenn ich in den nächsten %i %s nicht ausreichend gefüttert werde, werde ich zurück in die Dunkelheit gehen, und Ihr werdet mir alle folgen!~n~B\""



   NecromancerGuild_rent_due_3 = "~BQueen Venya'cyr sagt Dir, \"~r~BIch habe sehr großen Hunger, meine Untertanen. Meine physische Erscheinung löst sich auf... Wenn ich in den nächsten %i %s nicht ausreichend gefüttert werde, werde ich zurück in die Dunkelheit gehen, und Ihr werdet mir alle folgen!~n~B\""


   NecromancerGuild_rent_due_2 = "~BQueen Venya'cyr sagt Dir, \"~r~BIch habe großen Hunger, meine Untertanen. Meine physische Erscheinung löst sich auf... Wenn ich in den nächsten %i %s nicht ausreichend gefüttert werde, werde ich zurück in die Dunkelheit gehen, und Ihr werdet mir alle folgen!~n~B\""


   NecromancerGuild_rent_due_1 = "~BQueen Venya'cyr sagt Dir, \"~r~BIch habe Hunger, meine Untertanen. Meine physische Erscheinung löst sich auf... Wenn ich in den nächsten %i %s nicht ausreichend gefüttert werde, werde ich zurück in die Dunkelheit gehen, und Ihr werdet mir alle folgen!~n~B\""



   NecromancerGuild_new_hall = "~B%s ist die neue Halle der Gilde %s%q!"
   NecromancerGuild_abandon_hall = "~B%s ist nicht mehr die Halle der Gilde %s%q!"
   NecromancerGuild_hall_conquered = "~B%s, Halle der Gilde %s%q, wurde erobert!"
   NecromancerGuild_hall_betrayed = "~B%s, Halle der Gilde %s%q, wurde von einem Mitglied verraten!"

   NecromancerGuild_ranks_full = "~BDu konntest der Gilde %s%q nicht beitreten, weil die Gilde schon zu viele Mitglieder hat."
   NecromancerGuild_ranks_full_inductor = "~B%s%s konnte nicht in %s%q aufgenommen werden, weil alle Ränge bereits vergeben sind."

   NecromancerGuild_invitation_one = "Du kannst immer nur eine Einladung zugleich haben."
   NecromancerGuild_invitation_one_inductee = "Jemand aus Deiner Gilde hat %s%s bereits mit einer Einladung versorgt."

   NecromancerGuild_cannot_rejoin = "~BDieses Ex-Mitglied darf dem Orden noch nicht wiederbeitreten."
   NecromancerGuild_you_cannot_rejoin = "~BDu darfst dem Orden noch nicht wiederbeitreten."

   NecromancerGuild_new_password = "~BDas Paßwort der Halle %s wurde geändert."

   NecromancerGuild_lich = "Venya'cyr, Königin von Brax"
   NecromancerGuild_newly_formed = "~BDer Orden der Nekromanten wurde wiedergeboren!"
   NecromancerGuild_creation_mail = "Betreff: Der Orden der Nekromanten wurde wiedergeboren!\nIch gratuliere Dir zur Gründung des Ordens der Nekromanten! Es gibt jedoch ein paar Regeln, die Du kennen solltest.\n\nMITGLIEDSCHAFT: Ich überlasse Dir die Details der Ordensmitgliedschaft, aber wenn der Orden nicht mindestens 3 Mitglieder besitzt, wird er meinen Zugriff auf diese Realitätsebene nicht unterstützen können. Daher wird es Deine erste Aufgabe sein, mehr Nekromanten für den Orden zu rekrutieren.\n\nNEUE MITGLIEDER ANWERBEN: Wenn Du ein potentielles Mitglied einlädst, wird in seinem Inventar eine Einladung hinterlegt, die entweder akzeptiert oder ignoriert werden kann. Eine Einladung wird immer erstellt, auch wenn jemand dem Orden nicht beitreten darf. Ein Nekromant muss bereits relativ mächtig sein, bevor er dem Orden beitreten darf, und er darf nicht zur selben Zeit Mitglied einer sterblichen Gilde sein.\n\nRÄNGE: Du kannst Leuten verschiedene Ränge zuweisen und damit auch mehr Macht und Verantwortung. Du darfst Nekromanten auch in niedrige Ränge verweisen, wenn Du das Gefühl hast, ihnen nicht trauen zu können. Es gibt folgende Ränge:\n +++ %s: haben keine speziellen Fähigkeiten, außer für den Führer ihrer Wahl zu stimmen. Sie dürfen nicht einmal die Türen zu meinem inneren Heiligtum öffnen.\n +++ %s: haben nur die Fähigkeit, zu wählen.\n +++ %s: haben die Fähigkeit zu wählen und neue Gildenmitglieder einzuladen.\n +++ %s: dürfen wählen, neue Mitglieder einladen, ungehorsame Mitglieder hinauswerfen, Mitglieder niedrigeren Ranges befördern oder degradieren sowie Bündnisse schließen oder auflösen.\n +++ %s: verfügt über alle Gewalten der Gilde.\n\nTRIBUT: Meine fortwährende Anwesenheit in dieser Realitästebene setzt voraus, dass der Orden mich mit einem ständigen Zustrom von Lebensessenz versorgt. Mein Hunger nimmt mit gleichbleibender Geschwindigkeit zu. Die Geschwindigkeit ist dabei von vielen Faktoren abhängig, u. a. der Anzahl der Gildenmitglieder und der Anzahl der Feinde und Verbündeten. Vergiß nicht, Einen Großteil Deiner Macht hast Du von mir  - solltest Du mich hungern lassen, werden alle Mitglieder des Ordens fürchterlich leiden!\n\nJeder aus dem Orden darf mich mit einer Portion Lebensessenz versorgen, die in ihren eigenen Körpern gespeichert ist, indem sie einfach vor mich treten und erklären, dass sie ihren Tribut entrichten möchten. Jedoch empfehle ich Euch um Verwirrung zu vermeiden, dass Ihr eine Person damit beauftragt, zu entscheiden, wer an der Reihe ist, meinen Durst zu löschen. Um herauszufinden, wie gross mein Hunger ist, fragt mich einfach.\n\n -- Venya'cyr, Ewige Königin von Brax"


































   NecromancerGuild_creation2_mail = "Betreff: Verteidige meine Festung gut!\nMEINE FESTUNG: Du darfst nun in meiner Festung wohnen und sie als Deine Heimstatt betrachten. Obwohl viel von Brax zerstört wurde, als es die Erde verschlang, so blieben doch einige meiner Zauber intakt. Du bist hier relativ sicher vor der Außenwelt, um zu rasten und Deine Wunden durch die Nähe zum Zentrum meiner Macht heilen zu lassen. Die Nachrichtenkugel hier ermöglicht es den Mitgliedern des Ordens, sich gegenseitig zu informieren, und es gibt außerhalb eine Geheimtür mit einem Paßwort, das Du nach Belieben bestimmen kannst. (Bis Du ein neues Paßwort bestimmst, lautet es: \"Todesmagier\"). Die Türe zu meinem inneren Heiligtum kann nur von Nekromanten ab einem bestimmten Rang geöffnet werden.\nHüte Dich vor jenen, die das Jägerschwert tragen, mein Liebling! Diese Waffen sind eine Bedrohung für Unsereins und müssen gut bewacht werden - dank diesem verfluchten Magier Tendrath erscheinen sie von Zeit zu Zeit hier in meiner Festung. Glücklicherweise ist das Labyrinth, das ich erbaut habe, um meine Gefangenen zu foltern, immer noch funktionstüchtig. Es ist auch der einzige Weg um sich Zutritt zu meinem innersten Heiligtum oder den Kammern,  in denen diese unsäglichen Schwerter erscheinen, zu verschaffen. Es gibt eine Anzahl von Hebeln im geheimen Raum hinter der durch das Paßwort geschützen Tür, welche die Konfiguration des Labyrinths beeinflussen können. Jeder Hebel hebt oder senkt Teile der Labyrinthwände, wenn er betätigt wird. Ich habe auch noch ein paar Kristallkugeln verzaubert, mit deren Hilfe Du den Irrgarten von vier verschiedenen Punkten aus beobachten kannst, um Eindringlinge rechtzeitig auszumachen und ihr Vordringen durch das Labyrinth zu vereiteln. Du tust gut daran, die Möglichkeiten des Labyrinths zu beherrschen, denn es ist lebenswichtig, mich vor Unheil zu bewahren. Deine weitere Existenz ist nun unlösbar mit der meinen verbunden; denn gelingt es einer Gruppe von lästigen Sterblichen, zu meinem innersten Heiligtum vorzudringen und meine derzeitige physische Manifestation zu zerstören, so werden alle Mitglieder des Ordens mit mir in die Klauen des Todes gerissen.\n\nDiene mir gut, und ich werde meine Kräfte mit Dir teilen, mein dunkler Diener! Zusammen werden wir die Saat der Zwietracht und Zerstörung säen, um diese Welt zu verschlingen! -- Venya'cyr, Ewige Königin von Brax"


























   NecromancerGuild_disbanded_mail = "Betreff: Der Orden existiert nicht mehr\nDer Orden der Nekromanten ist in die Nacht verschwunden. Erneut sinke ich in die Tiefen des Schlafes, meine Lieblinge. "


   NecromancerGuild_deposed_mail = "Betreff: Meuterei in den Rängen\nWährend Deiner Abwesenheit wurdest Du als %s von %s%q abgesetzt. %q ist nun %s.\n\n"


   NecromancerGuild_new_master_mail = "Betreff: Meuterei in den Rängen\nWährend Deiner Abwesenheit hat es einen Führungswechsel gegeben. %q ist nun %s von %s%q.\n\n"


   NecromancerGuild_new_hall_mail = "Betreff: Neue Gildenhalle\n%s ist während Deiner Abwesenheit zur Halle der Gilde %s%q erklärt worden.\n\n"

   NecromancerGuild_ascension_mail = "Betreff: Gratulation!\nDu bist auserwählt worden, %s von %s%q zu sein!\n\n"


   NecromancerGuild_default_password = "Todesmagier"

classvars:

   vrIcon = NecromancerGuild_icon_rsc
   vrDesc = NecromancerGuild_desc_rsc

properties:

   vrName = NecromancerGuild_name_rsc              %% settable by players

   prMaster                             %% all hopefully settable by players.
   prMistress
   prLieutenant_Male 
   prLieutenant_Female
   prLady 
   prLord 
   prMadame
   prSir 
   prApprentice_Male
   prApprentice_Female

   piMature = 0

   plMembers   = $        %%% this is a list of three element lists.
                          %%% first element:  a member's object ID
                          %%% second element:  a member's rank
                          %%% third element:  that member's current 'vote'.
                          %%%           (ignored if guild is assassination)      

   piGuild_Hall = $

   piSuccession = GS_VOTING     %%% as of May 31, one form of succession: Voting

   pbSecret = TRUE             %%% secret societies do not advertise their
                                %%% existence in who lists or look descs.
                                %%% set upon creation

   ptMaintenance = $
   piThreePersonWarning = 0      %%%% If a player has less than three members
                                 %%%% for 24 hours in a row, delete the guild.

   plInvitations = $   %%%% These are stored only so that, if the guild goes
                       %%%% while an invitation is extended, the invitation
                       %%%% disappears.

   plTreaties = $   %%%% These are only stored so that, if the guild is deleted,
                    %%%% all treaties are deleted.

   plAllies = $     %%%% Keeps track of your allies.  Main benefit of being
                    %%%% an ally:  you can share a guild hall.  Ally lists
                    %%%% must always match.

   plEnemies = $    %%%% Keeps track of your enemies.  Main benefit of being
                    %%%% an enemy?  You get warned if one attacks your guild hall.

   plEnemiesOf = $  %%%% list of guilds that has declared YOURS as an enemy
   plAlliesOf = $   %%%% list of guilds that has declared YOURS as an ally

   plFormerMembers = $   %%%% ex-members cannot rejoin for two hours

   piRent = 167               % two kills a day - units of piHunger*10000
   piRentPerMember = 42       % plus half a kill per member
   piRentPerAlly = 21         % plus a quarter kill per ally/enemy
   piRentDue = 0
   piRentCounter = 0

   psPassword      

   piColor1 = XLAT_TO_GRAY
   piColor2 = XLAT_TO_GRAY
   piShield_shape = SHIELDSHAPE_DEFAULT

messages:

   Constructor( master = $ )

   {
     local sTemp;
     ClearTempString();
     AppendTempString(NecromancerGuild_name_rsc);
     sTemp = createString();
     setString(sTemp,GetTempString());
     vrName = sTemp;

     prMaster = NecromancerGuild_master;
     prMistress = NecromancerGuild_mistress;
     prLieutenant_Male = NecromancerGuild_lieutenant_male;
     prLieutenant_Female = NecromancerGuild_lieutenant_female;
     prLady = NecromancerGuild_lady;
     prLord = NecromancerGuild_lord;                            %% text names for guild ranks
     prMadame = NecromancerGuild_madame;
     prSir = NecromancerGuild_sir;
     prApprentice_Male = NecromancerGuild_apprentice;
     prApprentice_Female = NecromancerGuild_apprenticette;

     pbSecret = TRUE;                      %% is the guild secret?
     piMature = 0;

     piSuccession = GS_VOTING;              %% what path of succession
                                             %% allows the leadership to
                                             %% change hands?

     plMembers = cons([master, RANK_MASTER, master], plMembers);

     send(master,@setguild,#guild_obj=self);
     send(self,@resetpowers,#who=master,#rank=RANK_MASTER);


     send(master,@msgsenduser,#message_rsc=NecromancerGuild_newly_formed);
     send(master,@receivenestedmail,#from=NecromancerGuild_lich,
        #dest_list=[master],#nest_list=[4,NecromancerGuild_creation_mail,
                          4,prApprentice_Male,4,prSir,4,prLord,4,prLieutenant_male,4,prMaster]);
     send(master,@receivenestedmail,#from=NecromancerGuild_lich,
        #dest_list=[master],#nest_list=[4,NecromancerGuild_creation2_mail]);

     ptMaintenance = createtimer(self,@MaintenanceTimer,send(sys,@GetMaintenanceDelay));

     piThreePersonWarning = THREE_PERSON_LIMIT;
     psPassword = NecromancerGuild_default_password;

     plFormerMembers = $;

     send(SYS,@newguild,#what=self);

     propagate;
   }

   IsMature()
   {
      return TRUE;
   }

   MaintenanceTimer()
   "Do five things here: "
   "1) Check to be sure they have 3 members."
   "% 2) Check for guild maturity."
   "3) Check to ensure there is a guildmaster."
   "4) Accrue rent."
   "5) Check to see if former members of the guild can once more rejoin the guild."
   {
     local i, hourhours, timeleft, bPKServer;                    

     if send(self,@getguildmaster) = $
       {
         %% this should never happen!  This is just in as a failsafe, since
         %% some commands are guildmaster only!
         DEBUG("Guild somehow ended up without a guildmaster!!!");

         send(self,@countvotes);

         %% countvotes will choose whoever has the most political support 
       }
     if length(plMembers) < MINIMUM_MEMBERS
       {
         if piThreePersonWarning = 0
           {
              piThreePersonWarning = THREE_PERSON_LIMIT;
           }
         else
           {
              piThreePersonWarning = piThreePersonWarning - 1;
           }
         if piThreePersonWarning = 0
           {
             for i in plMembers
               {
                 post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_threeperson_failed);
               }
             send(&NecromancerAmulet,@OrderOfNecromancersDisbanded);
             %send(self, @delete,#timerdelete=TRUE);
             return;
           }
         else
           {
            if (piThreePersonWarning mod 40) = 0
            or ((piThreePersonWarning mod 10) = 0 and piThreePersonWarning < 40)
             {
              if piThreePersonWarning = 10
                {
                   hourhours = NecromancerGuild_hour_rsc;
                }
              else
                {
                   hourhours = NecromancerGuild_hours_rsc;
                }
              for i in plMembers
                {
                  post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_threeperson_failing,
                    #parm1=piThreePersonWarning/10,#parm2=hourhours);
                }
              }
           }
       }
     else
       {
          piThreePersonWarning = 0;
       }

     send(self,@accrueRent);
     for i in plFormerMembers
        {
           timeleft = Nth(i,2) - 1;
           if timeleft < 1
             {
                plFormerMembers = DelListElem(plFormerMembers,i); 
             }
           else
             {
                setnth(i,2,timeleft);
             }
        }
     if piGuild_hall <> $ and send(send(self,@getguildhall),@getguildowner) <> self
       {
          DEBUG("Guild points to a guild hall that does not point back to it!");
          piGuild_hall = $;
          for i in plMembers
            {
              post(self,@resetpowers,#who=first(i),#rank=send(self,@getrank,#who=first(i)));
            }
       }
     ptMaintenance = createtimer(self,@MaintenanceTimer,send(SYS,@getmaintenancedelay));
     return;
   }

   AccrueRent()
   {
      local rent, i, hourhours, oLich;

      if piRentDue < 1
      {
         piRentCounter = 0;
      }

      if piRentCounter = 1
      {
         for i in plMembers
         {
            post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_nonpayment);
         }
         send(&NecromancerAmulet,@OrderOfNecromancersDisbanded);
         return;
      }

      rent = piRent;
      for i in plMembers
      {
         rent = rent + piRentPerMember;
      }
      for i in plAllies
      {
         rent = rent + piRentPerAlly;
      }
      for i in plEnemies
      {
          rent = rent + piRentPerAlly;
      }
      rent=bound(rent,2,$);

      piRentDue = piRentDue+ rent;
      if piRentCOunter = 0
      {
         if piRentDue > (rent*RENT_MAX_OVERDUE)
         {
            piRentCounter = RENT_MAX_OVERDUE;
         }
      }
      else
      {
         piRentCounter = piRentCounter - 1;
      }
      if piRentCounter > 0 and
            ((piRentCounter MOD 40) = 0 or
            (piRentCounter < 40 and piRentCounter MOD 10 = 0))
      {
         hourhours = NecromancerGuild_hours_rsc;
         if piRentCounter = 10
         {
            hourhours = NecromancerGuild_hour_rsc;
         }
         if piRentDue > (rent*RENT_MAX_OVERDUE)
         {
            for i in plMembers
            {
               post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_due_5,
                   #parm1=piRentCounter/10,#parm2= hourhours);
            }
            return;
         }
         if piRentDue > (rent*RENT_MAX_OVERDUE)*4/5
         {
            for i in plMembers
            {
               post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_due_4,
                   #parm1=piRentCounter/10,#parm2= hourhours);
            }
            return;
         }
         if piRentDue > (rent*RENT_MAX_OVERDUE)*3/5
         {
            for i in plMembers
            {
               post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_due_3,
                   #parm1=piRentCounter/10,#parm2= hourhours);
            }
            return;
         }
         if piRentDue > (rent*RENT_MAX_OVERDUE)*2/5
         {
            for i in plMembers
            {
               post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_due_2,
                   #parm1=piRentCounter/10,#parm2= hourhours);
            }
            return;
         }
         for i in plMembers
         {
            post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_rent_due_1,
                #parm1=piRentCounter/10,#parm2= hourhours);
         }
         return;
      }

     return;
   }

   PayRent(amount = $)
   "This merely subtracts a number from the rentdue."
   {
      piRentDue = piRentDue - amount;
      if piRentDue < 1
        {
          piRentCounter = 0;
        }
      return;
   }

   GetRentDue()
   {
      local rent, i;
      rent = piRent;
      for i in plMembers
      {
         rent = rent + piRentPerMember;
      }
      for i in plAllies
      {
         rent = rent + piRentPerAlly;
      }
      for i in plEnemies
      {
          rent = rent + piRentPerAlly;
      }
      rent=bound(rent,2,$);
      return (piRentDue*5/(rent*RENT_MAX_OVERDUE));
   }

   AbandonGuildHall()
   {
      local i, j, members;

      if piGuild_hall = $
        {
          DEBUG("someone without a guild hall is being offered the ABANDON command!");
          return FALSE;  
        }

      psPassword = $;
      for i in plMembers
        {
           send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_abandon_hall,
             #parm1=send(send(self,@getguildhall),@getname),
             #parm2=send(self,@getdef),#parm3=send(self,@getname));
        }
      for j in plAllies
        {
          members = send(j,@getmemberlist);
          for i in Members
           {
              send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_abandon_hall,
                #parm1=send(send(self,@getguildhall),@getname),
                #parm2=send(self,@getdef),#parm3=send(self,@getname));
           }
        }
      send(send(self,@getguildhall),@ResetGuildHall);
      piGuild_hall = $;
      for i in plMembers
        {
           send(self,@resetpowers,#who=first(i),#rank=send(self,@getrank,#who=first(i)));
        }
      return;
   }

   GuildHallConquered(name=$, betrayed = $, oConquerer = $)
   {
      DEBUG("shouldn't ever get here.");
      return;
   }

   InductNewMember(who=$,inductor=$)
   {
      local i;

      if length(plMembers) >= MAX_MEMBERS
        {
           send(who,@msgsenduser,#message_rsc=NecromancerGuild_ranks_full,
             #parm1=send(self,@getdef),#parm2=vrName);
           if inductor <> $
             {
               send(inductor,@msgsenduser,#message_rsc=NecromancerGuild_ranks_full_inductor,
                #parm1=send(who,@getcapdef),#parm2=send(who,@getname),#parm3=send(self,@getdef),
                #parm4=vrName);
             }
           return FALSE;
        }
      for i in plMembers
        {
          if first(i) = who
            {
               send(who,@msgsenduser,#message_rsc = NecromancerGuild_induct_already_member);
               return FALSE;
            }
        }
      if send(who,@getguild) <> $
         {
            send(who,@msgsenduser,#message_rsc = NecromancerGuild_induct_already_guilded);
            return FALSE;
         }
                                        %% cannot rejoin the guild if you
                                        %% left in the last hour
      if send(self,@CheckFormerMemberList,#who=who)
      {
         send(who,@msgsenduser,#message_rsc=NecromancerGuild_you_cannot_rejoin);
         if inductor <> $
         {
            send(inductor,@msgsenduser,#message_rsc=NecromancerGuild_cannot_rejoin);
         }
         return FALSE;
      }
      if send(who,@HasLeftAGuildTooRecently)
      {
         ClearTempString();
         AppendTempString(guild_left_another);
         AppendTempString(send(self,@GetDef));
         AppendTempString(send(self,@GetName));
         AppendTempString(".");
         send(who,@msgsenduser,#message_rsc=send(SYS,@GetPercentQRsc),#parm1=GetTempString(),#type1=STRING_RESOURCE);
         if inductor <> $
         {
            ClearTempString();
            AppendTempString(send(who,@GetName));
            AppendTempString(guild_left_another_2);
            send(inductor,@msgsenduser,#message_rsc=send(SYS,@GetPercentQRsc),#parm1=GetTempString(),#type1=STRING_RESOURCE);
         }
         return FALSE;
      }

      %% cleared checks.  go ahead and set the guild.

      send(who,@setguild,#guild_obj=self);
      plMembers = cons([who,RANK_APPRENTICE,send(self,@getguildmaster)], plMembers);
      send(self,@resetpowers,#who=who,#rank=RANK_APPRENTICE);

      if length(plMembers) >= MINIMUM_MEMBERS
        {
           piThreePersonWarning = 0;
        }

      for i in plMembers
         {
           send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_welcome,
             #parm1=send(self,@getdef),#parm2=send(self,@getname),#parm3=send(who,@gettruename));
         }
      return TRUE;
   }

   RemoveFromGuild(who=$)
   {
      local i, oFound;

      for i in plMembers
        {
          if first(i) = who
            {
              send(who,@resetguildstuff);    %%% removes powers, resets poguild
              send(who,@evaluatePKstatus);
              send(who,@SetGuildRejoinTime,#delayMinutes=(CANNOT_REJOIN_TIME*6));
              plFormerMembers =  cons([who,CANNOT_REJOIN_TIME],plFormerMembers);

              plMembers = dellistelem(plMembers,i);
              oFound = True;
            }
        }

      if oFound = TRUE
        {
           return TRUE;
        }
      DEBUG("Was not a member of this guild!");
      return FALSE;
   }
   

   NewGuildMaster(who=$, abdicate = FALSE)
   "Other than creating a guild, this is the only way to have someone's "
   "rank set to guildmaster.  Note that it will depose any current guildmaster "
   "to the rank of normal peon, and reset votes to neutral (nil)!"
   {
      local i, new_master, old_master;

      if who = $
        {
           DEBUG("Tried to promote -no one- to the rank of guildmaster!");
           return;
        }
      if who = send(self,@getguildmaster)
        {
           DEBUG("Tried to promote existing guildmaster to guildmaster!  Should never happen!");
           return;
        }

      old_master = $;
      for i in plMembers                %% demote anyone at guildmaster rank
        {                              
           if nth(i,2) = RANK_MASTER
           {
              old_master = first(i);
              setnth(i,2,RANK_SIR);
              if abdicate = FALSE
                {
                  if not send(first(i),@isloggedon)
                    {
                      send(first(i),@receivenestedmail,#from=NecromancerGuild_lich,
                      #dest_list=[first(i)],#nest_list=[4,NecromancerGuild_deposed_mail,
                      STRING_RESOURCE,send(self,@getrankname, #sex=send(old_master,@getgender),
                      #rank=RANK_MASTER),4, send(self,@getdef),STRING_RESOURCE,send(self,@getname),
                      STRING_RESOURCE,send(who,@getname),STRING_RESOURCE,send(self,@getrankname,
                      #sex=send(who,@getgender),#rank=RANK_MASTER)]);
                     }
                  else
                     {
                        send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_descension,
                           #parm2=send(self,@getdef), #parm3=send(self,@getname),
                            #parm1=send(self,@getrankname, #sex=send(old_master,@getgender),
                                               #rank=RANK_MASTER));
                      }
                }
              send(self,@resetpowers,#who=first(i),#rank=RANK_SIR);
           }

           if first(i) = who
           {
              new_master = first(i);
              setnth(i,2,RANK_MASTER);         %% promote to master.
              if not send(first(i),@isloggedon)
                {
                  send(first(i),@receivenestedmail,#from=NecromancerGuild_lich,
                  #dest_list=[first(i)],#nest_list=[4,NecromancerGuild_ascension_mail,
                  4,send(self,@getrankname,#rank=RANK_MASTER,#sex=send(who,@getgender)),
                  4,send(self,@getdef),4,send(self,@getname)]);
                }
              else
                {
                  post(first(i),@msgsenduser,#message_rsc=NecromancerGuild_ascension,
                    #parm2=send(self,@getdef), #parm3=send(self,@getname),
                    #parm1=send(self,@getrankname, #sex=send(new_master,@getgender),
                                               #rank=RANK_MASTER));
                }
              send(self,@resetpowers,#who=first(i),#rank=RANK_MASTER);
           }
        }
    for i in plMembers
       {
          if first(i) <> new_master
          and (First(i) <> old_master or abdicate = FALSE)
            {
              if abdicate = TRUE
                {
                   post(first(i),@msgsenduser,#message_rsc = NecromancerGuild_abdicate,
                      #parm1 = send(old_master,@getname),#parm2=send(self,@getdef),
                      #parm3=send(self,@getname));
                }
             if not send(first(i),@isloggedon)
               {
                 if first(i) <> old_master
                   {
                     send(first(i),@receivenestedmail,#from=NecromancerGuild_lich,
                       #dest_list=[first(i)],#nest_list=[4,NecromancerGuild_new_master_mail,
                       STRING_RESOURCE,send(new_master,@getname),
		       4,send(self,@getrankname,#rank=RANK_MASTER,
                       #sex=send(new_master,@getgender)),4,send(self,@getdef), 4,send(self,@getname)]);
                   }
               }
             else
               {
                  post(first(i), @msgsenduser, #message_rsc = NecromancerGuild_new_master,
                    #parm1 = send(new_master,@gettruename), #type1=STRING_RESOURCE,
		       #parm2=send(self,@getrankname,
                      #sex=send(new_master,@getgender),#rank=RANK_MASTER),
                    #parm3 = send(self,@getdef), #parm4 = send(self,@getname));
               }
            }
          SetNth(i,3,$);
       }
     return;
   }

   NewLieutenantOkay()
   {
      local i, number;

      number = 0;
      for i in plMembers
        {
           if nth(i,2) = RANK_LIEUTENANT
             { number = number + 1;  }
        }
      if number >= 2
        {
          return FALSE;
        }
      return TRUE;
   }

   NewLordOkay()
   "No limits as of july 24th."
   {
     return TRUE;
   }

   CheckChangeRank(who=$, promoter = $, newrank = $)
   "Bumps the person up a rank, with some limitations: "
   {
      local who_rank, promoter_rank, i, count, bcount;

      if who=$ or promoter = $ or NewRank = $
        { return FALSE; }

      promoter_rank= send(self,@getrank,#who=promoter);
      if promoter_rank < RANK_LIEUTENANT
        { return FALSE; }

      who_rank = send(self,@getrank,#who=who);
      if who_rank >= RANK_MASTER 
        {
          send(who,@msgsenduser,#message_rsc=NecromancerGuild_promote_too_high);
          return FALSE;
        }  

      if newrank = RANK_LIEUTENANT
        {
          if send(self,@NewLieutenantOkay)
            {
              return TRUE;
            }
          else
            {
              send(promoter,@msgsenduser,#message_rsc=NecromancerGuild_cant_promote_capt,
                 #parm1=send(self,@getrankname,#rank=RANK_LIEUTENANT,#sex=GENDER_MALE));
              return FALSE;
            }
        }
    if newrank = RANK_LORD
      {
        if send(self,@NewLordOkay)
          {
             return TRUE;
          }
        else
          {
             send(promoter,@msgsenduser,#message_rsc=NecromancerGuild_cant_promote_sire,
                #parm1=send(self,@getrankname,#rank=RANK_LORD,#sex=GENDER_MALE));
             return FALSE;
          }
      }
    return TRUE;      %%% every possible scenario should be 'if'ed out above.
   }

   ChangeRank(who=$,promoter=$, newrank= $)
   "This promotes someone whether or not they pass CheckPromote or not."
   "anything that calls promote, it is assumed, also passes checkpromote."
   "One caveat.  No one may be promoted to Guildmaster or demoted below "
   "apprentice with this mechanism."
   {
      local i, bPromotion, oldrank, j;

      if newrank <> bound(newrank,1,4)
      {
	 return FALSE;
      }
      if send(who,@getguild) = self
      {
	 for i in plMembers
         {
	    if first(i) = who
            {
	       oldrank = nth(i,2);
               if oldrank = newrank
               { return FALSE; }
               
	       bPromotion = FALSE;               
	       if oldrank < newrank
               {
		  bPromotion = TRUE;
	       }

               setnth(i,2,newrank);
               
	       send(self,@resetpowers,#who=first(i),#rank=newrank);
	       if bPromotion = TRUE
               {
		  if promoter <> $ 
                  {
		     send(who,@msgsenduser,#message_rsc=NecromancerGuild_promotee,
			#parm1=send(promoter,@gettruename),#type1=STRING_RESOURCE,
                        #parm2=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
                     send(promoter,@msgsenduser,#message_rsc=NecromancerGuild_promoter,
			#parm1=send(who,@gettruename),#type1=STRING_RESOURCE,
                        #parm2=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
                     for j in plMembers
                     {
			if first(j) <> promoter and first(j) <> who
                        {
			   send(first(j),@msgsenduser,#message_rsc=NecromancerGuild_promoted,
			      #parm1=send(promoter,@gettruename),#type2=STRING_RESOURCE,
			      #parm2=send(who,@gettruename),#parm3=
			   send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
			}
		     }
		  }
                  else
                  {
		     send(who,@msgsenduser,#message_rsc=NecromancerGuild_promotee_no_promoter,
			#parm1=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
		  }
	       }
               else
               {
		  if promoter <> $
                  {
		     send(who,@msgsenduser,#message_rsc=NecromancerGuild_demotee,
			#parm1=send(promoter,@gettruename),#type1=STRING_RESOURCE,
                        #parm2=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
		     send(promoter,@msgsenduser,#message_rsc=NecromancerGuild_demoter,
			#parm1=send(who,@gettruename),#type1=STRING_RESOURCE,
                        #parm2=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
		     for j in plMembers
                     {
			if first(j) <> promoter and first(j) <> who
                        {
			   send(first(j),@msgsenduser,#message_rsc=NecromancerGuild_demoted,
			      #parm1=send(promoter,@gettruename),#type2=STRING_RESOURCE,
			      #parm2=send(who,@gettruename),
			      #parm3=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
			}
		     }

		  }
                  else
                  {
		     send(who,@msgsenduser,#message_rsc=NecromancerGuild_demotee_no_demoter,
			#parm1=send(self,@getrankname,#rank=newrank,#sex=send(who,@getgender)));
		  }
	       }
               return TRUE;
	    }
	 }
      } 
      else
      {
          DEBUG("guild member is not a member of this guild!");
      }
      return;
   }


   Vote(who=$,candidate=$)
   {
      local i, bFound, j, oldvote, newleader;

       if not send(self,@ismember, #who=who)
          {
             DEBUG("Somehow, someone's voting in a guild that is not their own!");
             return FALSE;
          }

       if not isClass(candidate,&user)
          {
             DEBUG("voted for an inanimate object of some sort!");
             send(who,@msgsenduser,#message_rsc=NecromancerGuild_cant_vote_nonuser,
                #parm1=send(candidate,@getcapdef), #parm2=send(candidate,@gettruename));

          }
       for i in plMembers
         {
           if first(i) = candidate
             {
               for j in plMembers
                {
                 if first(j) = who
                  {
                    oldvote = nth(j,3);
                    if oldvote = candidate
                     {
                      if who = candidate
                        {         
                       send(who,@msgsenduser,#message_rsc= NecromancerGuild_talking_to_self,
                         #parm1=send(candidate,@getname));
                       return;
                        }
                       send(candidate,@msgsenduser,#message_rsc= NecromancerGuild_reassure,
                         #parm1=send(who,@gettruename));
                       send(candidate,@msgsenduser,#message_rsc= NecromancerGuild_reassure,
                         #parm1=send(who,@gettruename));
                       return;
                     }

                     setnth(j,3,candidate);
                     newleader = send(self,@countvotes);

                     if candidate = who
                       {
                        send(who,@msgsenduser,#message_rsc= NecromancerGuild_support_self,
                          #parm1=send(self,@getdef),#parm2=send(self,@getname));
                        if oldvote <> $ and oldvote <> who and newleader = FALSE
                           {
                             send(oldvote,@msgsenduser,#message_rsc=NecromancerGuild_support_withers);
                           }
                        }
                     else
                       {
                        send(who,@msgsenduser,#message_rsc= NecromancerGuild_support_other,
                          #parm1=send(candidate,@gettruename),#type1=STRING_RESOURCE,
                          #parm2=send(self,@getdef),#parm3=send(self,@getname));
                        send(candidate,@msgsenduser,#message_rsc= NecromancerGuild_supported,
                          #parm1=send(who,@gettruename),
                          #parm2=send(self,@getdef),#parm3=send(self,@getname));
                        if oldvote <> $ and oldvote <> who and newleader = FALSE
                           {
                             send(oldvote,@msgsenduser,#message_rsc=NecromancerGuild_support_withers);
                           }
                         }
                        return;
                      }
                  }
               }
          }
       DEBUG("Somehow, someone's voting for someone outside their guild!");
       send(who,@msgsenduser,#message_rsc=NecromancerGuild_cant_vote_outsider,
         #parm1=send(candidate,@getdef),#type2=STRING_RESOURCE,#parm2=send(candidate,@gettruename),
         #parm3=send(self,@getdef),#parm4=send(self,@getname));
       return FALSE;
     }

   CountVotes(disqualify=$)
   "Note:  currently, all ties go to the oldest guild member."
   {
     local winner, i, j, count, mostvotes, guildmaster;

     %% this code is convoluted and slow, so initially, just check to see
     %% if current guildmaster still has the majority.

     guildmaster = send(self,@getguildmaster);

     if (guildmaster <> $) and (guildmaster <> disqualify)
       {
         count = 0;   
         for i in plMembers
           {
             if nth(i,3) = guildmaster
               {
                  count = count+1;
               }
           }
         if count > (length(plMembers)/2)
           {
              return FALSE;
           }
        }

     %% Guildmaster does not have the majority.  If guildmaster exists, he
     %% still retains leadership as long as no one else has a majority.
     %% Since there must always be a guildmaster, if there is no guildmaster,
     %% person with most votes is chosen.

     mostvotes = -1;
     winner = $;
     for i in plMembers
       {
         if first(i) = disqualify {continue;}
         count = 0;
         for j in plMembers
           {
              if nth(j,3) = first(i) 
	      and first(j) <> disqualify
                {
                  count = count + 1;
                }
           }        
         if count >= mostvotes
           {
              winner = first(i);
              mostvotes = count;
           }
       }

     if mostvotes > (length(plMembers)/2)
       {
         send(self,@newguildmaster,#who=winner);
         return TRUE;
       }
     else
       {
          if (guildmaster = $) or (guildmaster = disqualify)
            {
              DEBUG("a new guildmaster was declared because there formerly was no old guildmaster!");  
              send(self,@newguildmaster,#who=winner);
              return TRUE;  
            }
          else
            {
               return FALSE;
            }
       }
     return FALSE;
   }

   DefunctGuild(what=$)
   "Removes the guild from all ally and enemy lists."
   {
      local i, j;

      for i in plAllies
        {
           if i = what
             {
               plAllies = dellistelem(plAllies, i);
               for j in plMembers
                 {
                   send(first(j),@msgsenduser,#message_rsc=NecromancerGuild_allies_defunct,
                      #parm1=send(what,@getdef), #parm2=send(what,@getname));
                 }
             }
        }
      for i in plEnemies
        {
           if i = what
             {
               plEnemies = dellistelem(plEnemies, i);
               for j in plMembers
                 {
                   send(first(j),@msgsenduser,#message_rsc=NecromancerGuild_enemies_defunct,
                      #parm1=send(what,@getdef), #parm2=send(what,@getname));
                 }

             }
        }
      for i in plEnemiesOf
        {
           if i = what
             {
               plEnemiesOf = dellistelem(plEnemiesOf, i);
             }
        }
      for i in plAlliesOf
        {
           if i = what
             {
               plAlliesOf = dellistelem(plAlliesOf, i);
             }
        }
      return;
   }

   GetEnemyList()
   {
     return plEnemies;
   }

   GetAllyList()
   {
     return plAllies;
   }

   GetDeclaredEnemyList()
   {
     return plEnemiesOf;
   }

   GetDeclaredAllyList()
   {
     return plAlliesOf;
   }

   IsAlly(otherguild = $)
   "returns TRUE if the guild in question is in the ally list."
   {
     local i;

     for i in plAllies
       {
         if i = otherguild
           { return TRUE; }
       }
     return FALSE;
   }

   IsEnemy(otherguild = $)
   "returns TRUE if the guild in question is in the enemy list."
   {
     local i;

     for i in plEnemies
       {
         if i = otherguild
           { return TRUE; }
       }
     return FALSE;
   }


   CanAlly(otherguild = $, rep = $, otherrep = $)
   "Can the guild ally itself with another guild?  Three checks:"
   "1) Must not be on either ally or enemy list.  2) Rep must be a member."
   "3) Rep must be at least a lieutenant."
   {
     local i;

     if not send(self,@ismember,#who=rep)
       {
         send(rep,@msgsenduser,#message_rsc= NecromancerGuild_not_member_currently,
            #parm1 = send(self,@getdef), #parm2 = send(self, @getname));
         return FALSE;
       }
     if send(self,@getrank,#who=rep) < RANK_LIEUTENANT
       {
         send(rep,@msgsenduser,#message_rsc= NecromancerGuild_not_qualified);
         return FALSE;
       }
     for i in plEnemies
       {
          if i = otherguild
            {
              send(rep,@msgsenduser,#message_rsc=NecromancerGuild_cant_ally_enemy,
                 #parm1 = send(otherguild,@getdef),
                 #parm2 = send(otherguild,@getname));
              return FALSE;
            }
       }
     for i in plAllies
       {
          if i = otherguild
            {
              send(rep,@msgsenduser,#message_rsc=NecromancerGuild_already_allies,
                 #parm1 = send(otherguild,@getdef),
                 #parm2 = send(otherguild,@getname));
              return FALSE;
            }
       }
     return TRUE;
   }

   NewAlly(otherguild = $)
   "Put the guild in question in the ally list."
   {
      local i;

      plAllies = cons(otherguild, plAllies);
      for i in plMembers
        {
           send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_new_allies,
              #parm1 = send(self,@getdef), #parm2 = send(self,@getname),
              #parm3 = send(otherguild,@getdef), #parm4 = send(otherguild,@getname));
        }
      send(otherguild,@declareally,#otherguild=self);
      return;
   }

   DeclareAlly(otherguild = $)
   {
      local i;

      plAlliesOf = cons(otherguild, plAlliesOf);
      for i in plMembers
        {
           send(first(i),@msgsenduser,#message_rsc=NecromancerGuild_declared_allies,
              #parm1 = send(otherguild,@getdef), #parm2 = send(otherguild,@getname),
              #parm3 = send(self,@getdef), #parm4 = send(self,@getname));
        }
      return;
   }

   EndAlly(otherguild = $)
   "Removes the guild in question from the ally list.  Tells the other guild "
   "to end it's alliance with you."
   {
     local i, j;

     for i in plAllies
       {
          if i = otherguild
            {
               plAllies = dellistelem(plAllies, i);
               for j in plMembers
                 {
                    send(first(j),@msgsenduser,#message_rsc = NecromancerGuild_end_alliance,
                      #parm1 = send(otherguild,@getdef), #parm2 = send(otherguild,@getname),
                      #parm3 = send(self,@getdef), #parm4 = send(self,@getname));
                 }
               send(otherguild,@removedeclaredally,#otherguild=self);
               return TRUE;
            }
       }
     DEBUG("tried to end an alliance that didn't exist!");
     return FALSE;
   }

   RemoveDeclaredAlly(otherguild = $)
   "Removes the guild in question from the ally list.  Tells the other guild "
   "to end it's alliance with you."
   {
     local i, j;

     for i in plAlliesOf
       {
          if i = otherguild
            {
               plAlliesOf = dellistelem(plAlliesOf, i);
               for j in plMembers
                 {
                    send(first(j),@msgsenduser,#message_rsc = NecromancerGuild_end_declared_alliance,
                      #parm1 = send(otherguild,@getdef), #parm2 = send(otherguild,@getname),
                      #parm3 = send(self,@getdef), #parm4 = send(self,@getname));
                 }
               send(otherguild,@removedeclaredally,#otherguild=self);
               return TRUE;
            }
       }
     DEBUG("tried to end an alliance that didn't exist!");
     return FALSE;
   }

   Delete(timerdelete=FALSE)
   "Kick all members out first!"
   "Since the timer may delete the object, TimerDelete checks to be sure "
   "the timer isn't already gone (getting rid of an error message."
   {
      local i;

      for i in plMembers
      {
        if not send(first(i),@isloggedon)
          {
            send(first(i),@receivenestedmail,#from=NecromancerGuild_lich,
              #dest_list=[first(i)],#nest_list=[4,NecromancerGuild_disbanded_mail]);
          }
      }
      propagate;
   }

   MemberKilled(victim=$,killer=$)
   {
      local IsMaster,oLich,i;
      if not send(self,@IsMember,#who=victim)
      {
         DEBUG("Tried to remove non-member ",send(victim,@GetName)," from the Order of Necromancers.");
         return;
      }
      IsMaster = FALSE;
      if send(self,@getrank,#who=victim) = RANK_MASTER
      {
         IsMaster = TRUE;
      }

      if length(plMembers) = 1
      {
         if first(first(plMembers)) <> victim
         {
            DEBUG("Tried to remove ",send(victim,@GetName)," from the Order of Necromancers but the last member is ",send(first(first(plMembers)),@GetName));
            send(self,@Delete);
            return;
         }
         oLich = send(send(SYS,@FindRoomByNum,#num=RID_GUILDH15),@FindHoldingActive,#class=&Lich);
         if oLich <> $
         {
            % lich will handle guild cleanup
            if (piRentCounter = 1) or (piThreePersonWarning = 0)
            {
               % we got here through nonpayment of rent or insufficient membership.
               post(oLich,@Killed,#what=self,#resetScenario=FALSE,#guildDisbandDeath=TRUE);
            }
            else
            {
               post(oLich,@Killed,#what=killer);
            }
         }
         else
         {
            DEBUG("The Order of Necromancers somehow ended up without a lich.");
            send(self,@Delete);
         }
         return;
      }

      % kick them out of the Order
      send(self,@RemoveFromGuild,#who=victim);
      % if master, find a new one
      if IsMaster
      {
         if send(self,@IsMember,#who=killer) and (killer <> victim)
         {
            % shift everyone's support to the assassin
            for i in plMembers
            {
               setnth(i,3,killer);
            }
         }
         send(self,@CountVotes);
      }
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

