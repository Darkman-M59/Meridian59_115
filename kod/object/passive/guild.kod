% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Guild is PassiveObject 

constants:

   include blakston.khd
   include protocol.khd

   % Once you leave a guild, you cannot rejoin another one for 4 hours
   % You cannot rejoin the same one for 18 times this length.
   % This is measured in minutes.
   CANNOT_REJOIN_TIME = 4 * 60  

   % maximum number of people allowed in a guild.
   MAX_MEMBERS = 400         

   % How much money do you lose if you pull out of a mutually-declared war?
   WAR_LOSS_PENALTY = 50000
   % What percent of the war penalty do you gain from a vanquished enemy?
   WAR_WINNER_PERCENT = 60

   MATURITY_SECRET = 60
   MATURITY_NONSECRET = 30

   THREE_PERSON_LIMIT = 240    

   MINIMUM_MEMBERS = 3

   RENT_BASE = 5
   RENT_SECRET = 10

   RENT_PER_MEMBER = 1
   RENT_PER_ALLY = -2
   RENT_PER_ENEMY = 5

   % this is in 6 minute periods.
   RENT_MAX_OVERDUE = 480   

   % Maximum number of lieutenants
   MAX_LIEUTENANT = 2

   % How long before you can back out of a mutual guild war?
   %  2 hours (1 Meridian day).
   PEACE_DELAY = 2 * 60 * 60 * 1000

resources:

   guild_name_rsc = "Die Gilde"
   guild_icon_rsc = light.bgf
   guild_desc_rsc = "Eine Gruppe von Individuen mit ähnlichen Zielen."

   guild_master = "Der Gildenmeister"
   guild_mistress = "Die Gildenmeisterin"
   Guild_lieutenant_Male = "Leutnant"
   Guild_lieutenant_female = "Leutnant"
   guild_lord = "Lord"
   guild_lady = "Lady"
   guild_sir = "Sir"
   guild_madame = "Lady"
   guild_apprentice = "Lehrling"
   guild_apprenticette = "Lehrling"

   guild_newly_formed = "~BDeine neue Gilde wurde soeben gegründet."

   guild_threeperson_failing = "Deine Gilde besteht aus weniger als drei Personen. Sofern Du nicht innerhalb von %i %s auf drei Mitglieder kommst, wird Deine Gilde wieder aufgelöst."




   guild_threeperson_failed = "Aufgrund zu geringer Mitgliederzahl wurde Deine Gilde aufgelöst."


   guild_welcome = "~BHeißt das neueste Mitglied der Gilde %s%q willkommen: %s!"
   guild_induct_already_guilded = "Du bist bereits Mitglied einer Gilde."
   guild_induct_already_member = "Du bist bereits Mitglied dieser Gilde."

   guild_lieut_cant_promote = "%ss kann keine Mitglieder über den Rang %q hinaus befördern."

   guild_cant_promote_lieut = "Du kannst niemanden über den Rang %q befördern, da es nur einen %q geben kann."

   guild_cant_promote_capt = "Eine Gilde soll nicht mehr als zwei Mitglieder des Ranges %q besitzen."

   guild_cant_promote_sire = "Es gibt zu viele Mitglieder mit dem Rang %q, um weiteren diesen Status zu verschaffen."



   guild_promotee = "~B%q hat Dir den Rang %q verliehen!"
   guild_promoter = "~BDu verleihst %q den Rang %q."
   guild_promoted = "~B%s hat %q den Rang %q verliehen."
   guild_promotee_no_promoter = "~BDir wurde der Rang %q verliehen!"
   guild_promote_too_high = "Du kannst niemand auf einen Rang befördern, der gar nicht existiert!"


   guild_demotee = "~B%q hat Dich auf den Rang %q herabgesetzt!"
   guild_demoter = "~BDu setzt %q auf den Rang %q!"
   guild_demoted = "~B%s hat %q auf den Rang %q herabgesetzt."
   guild_demotee_no_demoter = "~BDu wurdest auf den Rang %q herabgesetzt!"

   guild_demote_apprentice = "Du kannst niemand auf den Rang %q herabsetzen. Es existiert kein niedrigerer Rang!"

   guild_demote_equal_higher = "Du kannst niemand herabsetzen, der den gleichen oder höheren Rang als Du besitzt!"


   guild_cant_vote_outsider = "Du kannst nicht für %q%s stimmen. Diese Person gehört nicht der Gilde %s%q an!"

   guild_cant_vote_nonuser = "%s%s bedankt sich für Deine Unterstützung."

   guild_descension = "~BDu bist als %q von %s%q degradiert worden!"
   guild_ascension = "~BGratulation! Du bist nun %q der Gilde %s%q!"

   guild_reassure = "~B%s verspricht Dir, Dich weiterhin politisch zu unterstützen."
   guild_talking_to_self = "~BDu versicherst Dir noch einmal selbst, dass Du Dich wirklich magst."

   guild_support_withers = "~BDu spürst, dass Du immer weniger politische Unterstützung bekommst."

   guild_support_self = "~BDu beschließt, selbst Deinen Führungsanspruch über %s%q anzumelden."
   guild_support_other = "~BDu schwörst, %q bei der Führung der Gilde %s%q zu unterstützen."
   guild_supported = "~B%s schwört, Dich bei Deinem Führungsanspruch über %s%q zu unterstützen."

   guild_new_master = "~BGratuliere %q, dem neuen %q von %s%q!"
   guild_abdicate = "~B%s hat beschlossen, die Führung der Gilde %s%q niederzulegen."

   guild_allies_defunct = "~BDein ehrenwerter Verbündeter, die Gilde %s%q, hat sich losgesagt."
   guild_enemies_defunct = "~BDein verhaßter Feind, die Gilde %s%q, hat sich aufgelöst."

   guild_cant_ally_enemy = "Du kannst Dich mit der Gilde %s%q nicht verbünden! Sie sind Deine erklärten Feinde!"

   guild_already_allies = "Deine Gilde ist bereits mit der Gilde %s%q verbündet!"
   guild_not_member_currently = "Du bist kein Mitglied der Gilde %s%q und kannst in ihrem Namen keine Bündnisse abschließen!"

   guild_not_qualified = "Du bist nicht hochrangig genug, um Bündnisse mit anderen Gilden abzuschließen!"

   guild_cant_enemy_ally = "Du kannst einer allierten Gilde nicht den Krieg erklären. Beende die Allianz zuerst!"


   guild_already_enemies = "Die Mitglieder der Gilde %s%q sind bereits die verhaßten Gegner der Gilde %s%q!"

   guild_new_allies = "~BHeute ist der Tag, an dem das Bündnis zwischen den Gilden %s%q und %s%q in Kraft tritt."

   guild_new_enemies = "~BHiermit wird bekanntgegeben, dass die Mitglieder der Gilde %s%q die erklärten Feinde der Gilde %s%q sind!"

   guild_declared_allies = "~BHiermit wird bekanntgegeben, dass sich die Gilde %s%q mit Deiner Gilde %s%q verbündet hat!"


   guild_declared_enemies = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q der Gilde %s%q feindlich gesinnt ist!"


   guild_mutual_enemies = "~BEs sei verkündet, dass sich %s%q und %s%q nun im Krieg befinden!"

   guild_cant_enemy_mature = "Du kannst keine Feinde erklären solange deine Gilde nicht reifer geworden ist."

   guild_cant_enemy_funds = "Du benötigst %q Schillinge an Guthaben auf deinem Gildenkonto um einen Feind zu erklären und einen Krieg zu finanzieren."

   guild_end_enemy_loser = "~BDeine Gilde hat %q Schillinge wegen eurer feigen Niederlage verloren."

   guild_end_enemy_winner = "~BDeine Gilde hat für den Sieg über euren feigen Feind %q Schillinge gutgeschrieben bekommen."



   guild_end_alliance = "~BHiermit wird bekanntgegeben, dass das Bündnis zwischen den Gilden %s%q und %s%q zerbrochen ist!"

   guild_not_enemies = "~BHiermit wird bekanntgegeben, dass die Mitglieder der Gilde %s%q der Gilde %s%q nicht mehr feindlich gesinnt sind."


   guild_end_declared_alliance = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q ihr Bündnis mit der Gilde %s%q aufkündigen will."

   guild_not_declared_enemies = "~BHiermit wird bekanntgegeben, dass die Gilde %s%q ihre Feindschaft mit der Gilde %s%q beendet hat."



   guild_sue_for_peace = "~BEs sei verkündet, dass die Mitglieder von %s%q im Krieg mit %s%q um Frieden flehen."


   guild_already_suing_for_peace = "Ihr fleht bereits um Frieden mit %s%q."
   guild_only_one_suing_for_peace = "Ihr könnt nur bei einem Feind auf einmal um Frieden flehen."


   guild_mature = "~BDie Gilde %s%q ist nun eine vollwertige Gilde, die selbst Hallen besitzen und einnehmen kann."



   guild_hour_rsc = "Stunde"
   guild_hours_rsc = "Stunden"

   guild_rent_nonpayment = "~BDeine Gilde wurde aufgelöst, weil sie ihre Schulden nicht bezahlt hat!"

   guild_rent_due = "~BDeine Gilde hat %i Schulden. Wenn dieser Betrag in den nächsten %i%s nicht beglichen wird, wird Deine Gilde aufgelöst."



   guild_new_hall = "~B%s ist die neue Halle der Gilde %s%q!"
   guild_abandon_hall = "~B%s ist nicht mehr die Halle der Gilde %s%q!"
   guild_hall_conquered = "~B%s, Halle der Gilde %s%q, wurde erobert!"
   guild_hall_betrayed = "~B%s, Halle der Gilde %s%q, wurde von einem Mitglied verraten!"

   guild_ranks_full = "~BDu konntest der Gilde %s%q nicht beitreten, weil die Gilde schon zu viele Mitglieder hat."


   guild_ranks_full_inductor = "~B%s%s konnte nicht in %s%q aufgenommen werden, weil alle Ränge bereits vergeben sind."



   guild_invitation_one = "Du kannst immer nur eine Einladung zugleich haben."

   guild_invitation_one_inductee = "Jemand aus Deiner Gilde hat %s%s bereits mit einer Einladung versorgt."


   guild_cannot_rejoin = "~BDieses ehemalige Mitglied Deiner Gilde kann noch nicht wieder eintreten."
   guild_you_cannot_rejoin = "~BNoch kannst Du Deiner früheren Gilde nicht wieder beitreten."

   guild_new_password = "~BDas Passwort der Halle %s wurde geändert."

   guild_frular = "Frular, Verwalter aller Gilden"

   guild_creation_mail = "Betreff: Deine Gilde hat sich formiert\nIch gratuliere Dir zur Gründung der Gilde %s%q! Es gibt jedoch ein paar Regeln, die Du kennen solltest.\n\nVOLLWERTIGKEIT: Ich gestatte es nicht jeder beliebigen Gilde, eine Halle zu mieten. Du musst Dich erst draußen in der Welt bewähren. Ich werde Dich informieren, wenn ich das Gefühl habe, dass Deine Gilde reif ist. Dann (und nur dann) kannst Du eine Halle mieten oder die einer anderen Gilde erobern.\n\nMITGLIEDSCHAFT: Ich überlasse es Dir, die Einzelheiten für eine Mitgliedschaft in Deiner Gilde selbst festzulegen, aber wenn Deine Gilde weniger als drei Mitglieder hat, ist sie den Verwaltungsaufwand nicht wert. In diesem Fall löse ich die Gilde auf. Aus diesem Grund solltest Du Dein erstes Augenmerk darauf richten, mehr als drei Mitglieder in Deiner Gilde zu versammeln.\n\nNEUE MITGLIEDER ANWERBEN: Wenn Du ein potentielles Mitglied einlädst, wird in seinem Inventar eine Einladung hinterlegt, die entweder angenommen oder abgelehnt werden kann. Eine Einladung wird immer erteilt, auch wenn jemand aus irgendeinem Grund keiner Gilde beitreten will. Ein Spieler muss ziemlich machtvoll sein, um einer Gilde beitreten zu können. Er kann gleichzeitig immer nur Mitglied einer einzigen Gilde sein.\n\nRÄNGE: Du kannst Leuten verschiedene Ränge zuweisen und damit auch mehr Macht und Verantwortung verleihen. Du kannst Spieler auch in niedrigere Ränge verweisen, wenn Du das Gefühl hast, ihnen nicht trauen zu können. Es gibt folgende Ränge:\n +++ %q: haben keine besonderen Fertigkeiten. Sie dürfen lediglich einen Anführer wählen. Es ist ihnen nicht einmal gestattet, die äußeren Türen ihrer Gildenhalle zu öffnen.\n +++ %q: dürfen nur wählen.\n +++ %q: dürfen wählen und neue Mitglieder in die Gilde einladen.\n +++ %q: dürfen wählen, neue Mitglieder einladen, undisziplinierte Mitglieder hinauswerfen, andere Leute niedrigen Ranges empfehlen oder ablehnen sowie Bündnisse formen und aufkündigen. Sie dürfen auch eine Gildenhalle mieten, wenn ihre Gilde vollwertig ist.\n +++ %q: hat alle Befugnisse in Zusammenhang mit Gilden, einschließlich dem Recht, die Gilde aufzulösen.\n\nMIETE: Der Verwaltungsaufwand, den ich mit Deiner Satzung habe, verursacht mir Kosten und deshalb verlange ich eine Gebühr für diese Dienstleistung: Miete wird regelmäßig fällig und die Steigerungsrate ist dabei von vielen Faktoren abhängig, u. a. der Anzahl der Gildenmitglieder sowie der Zahl Deiner erklärten Feinde und Verbündeten. Entscheidend ist, ob Du eine Gildenhalle besitzt oder nicht. Gildenhallen können ziemlich teuer sein und deshalb empfiehlt es sich, zu warten, bis die eigene Gilde über ausreichend Mitglieder verfügt.\n\nJedes Mitglied in Deiner Gilde kann mir die fälligen Schulden bezahlen. Um jedoch Verwirrung zu vermeiden, empfiehlt es sich, eine bestimmte Person mit der Aufgabe zu betrauen.\n\nGratulation zur Gründung Deiner Gilde! Und vergiß nicht, Deine Schulden zu begleichen!\n\n -- Frular, Verwalter aller Gilden"






















































   guild_mature_mail = "Betreff: Deine Gilde ist nun vollwertig\n%s%q ist nun eine vollwertige Gilde, d. h. ihre Mitglieder können nun Gildenhallen besitzen und erobern.\n\nGILDENHALLEN: Eine Gilde kann eine Gildenhalle bei mir erwerben. Gildenhallen bieten ihren Besitzern eine Reihe von Annehmlichkeiten, wie z. B. einen relativ sicheren Platz zum Ausruhen, eine Nachrichtenkugel mit den Gilden-Neuigkeiten und eine Geheimtür, die durch ein von Dir festgelegtes Paßwort geschützt wird. Gildenhallen sind auch Plätze, an denen die Wunden des Spielers schneller heilen.\n\nGildenhallen werden durch eine Außentür mit einem magischen Verteidigungsschild geschützt. Nur Mitglieder der Besitzergilde können die Außentür ihrer Gildenhalle öffnen. Sobald die Tür einmal offen ist, kann jedoch jeder eintreten. Die Türen bleiben für eine sehr kurze Zeitspanne offen.\n\nSIEG: Jede Gildenhalle verfügt auch über eine Vorrichtung zum Deaktivieren des mystischen Schildes. Wenn diese Vorrichtung benutzt wird, verliert die Gildenhalle ihren Schutz und jeder kann die Außentüren öffnen. Wenn die Vorrichtung für mehr als 10 Minuten hintereinander ausgeschaltet bleibt, so gilt die Gildenhalle als 'erobert'.\n\nNur die Gilde, die eine spezielle Halle erobert hat, darf sie nachher mieten. Man kann jedoch immer nur eine einzige Gildenhalle besitzen, d. h. wenn man eine Halle erobert, muss man erst seine alte verlassen, um die neue übernehmen zu können. Eine Stunde nach der Eroberung wird die Gildenhalle wieder auf dem offenen Markt angeboten und jeder kann sie mieten.\n\nBETRUG UND HÄNDLER EROBERUNG:  Wenn eine Gildenhalle von einem Mitglied Deiner eigenen Gilde erobert wird, drückt die Gilde offiziell ihre Verlegenheit aus. In einem solchen Falle kann jeder außer der besiegten Gilde die Halle mieten. Dieses Limit gilt für eine Stunde.\n\nVERBÜNDETE: Wenn Du eine Gilde zu Deinem Verbündeten machst, können deren Mitglieder Deine Halle betreten, als ob es ihre eigene wäre. Dieses Zeichen des Vertrauens senkt die Miete Deiner Gilde.\n\nFEINDE: Wenn Du eine Gilde zu Deinen Feinden erklärst, wirst Du rechtzeitig gewarnt, falls diese versucht, Deine Gilde zu besiegen. Ansonsten bekommst Du nur bruchstückhafte und verspätete Informationen von den mystischen Verteidigungsvorrichtungen Deiner Gilde. Diese zusätzliche Vorsichtsmaßnahme erhöht Deine Mietkosten.\n\nNIEDERE RÄNGE: Kein Mitglied des Ranges '%q' kann die Außentür Deiner Gildenhalle öffnen, egal ob es sich in Deiner eigenen Gilde oder der eines Verbündeten aufhält.\n\nGratulation, Deine Gilde ist vollwertig geworden. Ich weiß, dass Du es noch weit bringen wirst.\n\n -- Frular, Verwalter aller Gilden"



































































   guild_mature_happyland_mail = "Betreff: Deine Gilde ist nun vollwertig\n%s%q ist nun eine vollwertige Gilde, d. h. ihre Mitglieder können nun Gildenhallen besitzen und erobern.\n\nEine Gilde kann eine Gildenhalle in Besitz nehmen, indem sie einen Vertrag mit mir abschließt. Gildenhallen bieten ihren Besitzern eine Reihe von Annehmlichkeiten, wie z. B. einen relativ sicheren Platz zum Ausruhen, eine Nachrichtenkugel mit den Gilden-Neuigkeiten und eine Geheimtür, die durch ein von Dir festgelegtes Paßwort geschützt wird. Gildenhallen sind auch Plätze, an denen die Wunden des Spielers schneller heilen.\n\nGildenhallen werden durch eine Außentür mit einem magischen Verteidigungsschild geschützt. Nur Mitglieder der Besitzergilde können die Außentür ihrer Gildenhalle öffnen. Sobald die Tür einmal offen ist, kann jedoch jeder eintreten. Die Türen bleiben für eine sehr kurze Zeitspanne offen.\n\nBeachte, dass, auch wenn sich jemand in Deine Halle schleichen kann, er doch nicht in der Lage ist, sie in dieser Welt zu erobern. Diese zusätzliche Sicherheit wird durch, wie soll ich es sagen, eine HÖHERE Miete belohnt. -- Frular, Verwalter aller Gilden.\n\n"



















   guild_conquered_mail = "Betreff: Gildenhalle erobert\n%s, Halle der Gilde %s%q, wurde während Deiner Abwesenheit erobert.\n\n -- Frular, Verwalter aller Gilden"


   guild_disbanded_mail = "Betreff: Gilde aufgelöst\nDeine Gilde %s%q wurde während Deiner Abwesenheit aufgelöst.\n\n -- Frular, Verwalter aller Gilden"


   guild_deposed_mail = "Betreff: Meuterei in den Rängen\nDu wurdest während Deiner Abwesenheit als %q der Gilde %s%q gestürzt. %q hat einen neuen Rang verliehen bekommen: %q.\n\n -- Frular, Verwalter aller Gilden"



   guild_new_master_mail = "Betreff: Meuterei in den Rängen\nWährend Deiner Abwesenheit hat es einen Führungswechsel gegeben. %q ist jetzt %q der Gilde %s%q.\n\n -- Frular, Verwalter aller Gilden"



   guild_new_hall_mail = "Betreff: Neue Gildenhalle\n%s ist während Deiner Abwesenheit zur Halle der Gilde %s%q erklärt worden.\n\n -- Frular, Verwalter aller Gilden"


   guild_ascension_mail = "Betreff: Gratulation!\nDu wurdest als %q der Gilde %s%q ausersehen!\n\n -- Frular, Verwalter aller Gilden"


   guild_left_another = "Du hast eine andere Gilde erst kürzlich verlassen und kannst folgender Gilde z. Z. nicht beitreten: "
   guild_left_another_2 = " hat eine andere Gilde erst kürzlich verlassen und kann derzeit Deiner Gilde noch nicht beitreten."

   
   guild_war_title = " erklärt den Krieg."
   guild_war_body1 = "Lasst es bekannt werden, dass "
   guild_war_body2 = " von diesem Tag an "
   guild_war_body3 = " den Krieg erklärt."
   guild_endwar_title = " haben ihre Streitigkeiten beigelegt."
   guild_endwar_body2 = " beenden ihre Streitigkeiten mit "
   
   
   guild_peace_title = " schließt Frieden."
   guild_peace_body1 = "Lasst es bekannt werden, dass sich "
   guild_peace_body2 = " mit "
   guild_peace_body3 = " verbündet haben."
   guild_endpeace_title = " beendet die Allianz."
   guild_endpeace_body2 = " beenden ihre Allianz mit "

   
   
classvars:

   vrIcon = guild_icon_rsc
   vrDesc = guild_desc_rsc

properties:

   % Settable by players
   vrName = guild_name_rsc

   % Titles settable by players.
   prMaster                             
   prMistress
   prLieutenant_Male 
   prLieutenant_Female
   prLady 
   prLord 
   prMadame
   prSir 
   prApprentice_Male
   prApprentice_Female

   piMature = 0

   % This is a list of lists each representing a member, of the form:
   %  [object ID, rank, member's current 'vote' (if guild votes for leader)]
   plMembers   = $

   piGuild_Hall = $

   piSuccession = GS_VOTING

   % Secret societies do not advertise their existence in who lists or
   %  look descs.  Set at guild creation.
   pbSecret = FALSE

   ptMaintenance = $

   % If a guild has less than three members for 24 hours in a row,
   %  delete the guild.
   piThreePersonWarning = 0

   % These are stored only so that, if the guild goes while an invitation is
   %  extended, the invitation disappears.
   plInvitations = $

   % These are only stored so that, if the guild is deleted, all treaties
   %  are deleted.
   plTreaties = $

   % Keeps track of your allies.  Main benefit of being an ally:  you can share
   %  a guild hall and get cheaper rent.  Ally lists must always match.
   plAllies = $

   % Keeps track of your enemies.  Main benefit of declaring an enemy?
   %  You get warned if one attacks your guild hall.
   plEnemies = $

   % List of guilds that has declared YOURS as an enemy
   plEnemiesOf = $

   % List of guilds that has declared YOURS as an ally
   plAlliesOf = $

   % Ex-members cannot rejoin for a while
   plFormerMembers = $

   piRentDue = 0
   piRentCounter = 0

   psPassword = $

   piColor1 = XLAT_TO_GRAY
   piColor2 = XLAT_TO_GRAY
   piShield_shape = SHIELDSHAPE_DEFAULT

   piLastGuildhallRaid = 0

   % Information for suing for peace from a mutual guild war.
   ptSuingForPeace = $
   poGuildSuingForPeace = $

messages:

   Constructor(guildname = guild_name_rsc, secret = FALSE,
               succession = GS_VOTING, master = $,
               rMaster = guild_master,
               rMistress = guild_mistress,
               rLieutenant_Male = guild_lieutenant_male,
               rLieutenant_Female = guild_lieutenant_female,
               rLord = guild_lord, rLady = guild_lady,
               rSir = guild_sir, rMadame = guild_madame,
               rApprentice_Male = guild_apprentice,
               rApprentice_Female = guild_apprenticette
              )
   {   
      if IsClass(self,&NecromancerGuild)
      {
         propagate;
      }

      vrName = guildname;

      % Text names for guild ranks.
      prMaster = rMaster;
      prMistress = rMistress;
      prLieutenant_Male = rLieutenant_male;
      prLieutenant_Female = rLieutenant_female;
      prLady = rLady;
      prLord = rLord;
      prMadame = rMadame;
      prSir = rSir;
      prApprentice_Male = rApprentice_Male;
      prApprentice_Female = rApprentice_Female;

      % Is the guild secret?
      pbSecret = secret;

      piMature = MATURITY_NONSECRET;
      if secret
      {
         piMature = MATURITY_SECRET;
      }

      % What path of succession allows the leadership to change hands?
      piSuccession = succession;              

      plMembers = cons([master, RANK_MASTER, master], plMembers);

      Send(master,@SetGuild,#guild_obj=self);
      Send(self,@ResetPowers,#who=master,#rank=RANK_MASTER);

      Send(master,@MsgSendUser,#message_rsc=guild_newly_formed);
      Send(master,@ReceiveNestedMail,#from=guild_frular,
           #dest_list=[master],
           #nest_list=[4,guild_creation_mail,4,Send(self,@GetDef),
                       4,Send(self,@GetName),4,rApprentice_male,4,rSir,
                       4,rLord,4,rLieutenant_male,4,rMaster]);

      ptMaintenance = CreateTimer(self,@MaintenanceTimer,
                                  Send(SYS,@GetMaintenanceDelay));

      piThreePersonWarning = THREE_PERSON_LIMIT;
      psPassword = $;

      plFormerMembers = $;

      piLastGuildhallRaid = 0;

      Send(SYS,@NewGuild,#what=self);

      propagate;
   }

   ResetPowers(who=$,rank = 0)
   {
      local i, lGuildCommands, bIsNecro;

      bIsNecro = IsClass(self,&NecromancerGuild);

      if who = $ or rank = 0
      {
         DEBUG("Passed to ResetPowers with bogus information!");
         
         return FALSE;
      }
      else
      {
         lGuildCommands=Send(SYS,@GetGuildcommands);

         for i in lGuildCommands
         {
            Send(i,@ResetCommand,#who=who,#rank=rank,#necro=bIsNecro); 
         }
      }
      
      return;
   }

   IsSecret()
   {
      return pbSecret;
   }

   IsMature()
   {
      if piMature = 0
      {
         return TRUE;
      }
      
      return FALSE;
   }

   GetLastGuildhallRaid()
   {
      return piLastGuildhallRaid;
   }

   SetLastGuildhallRaid(now=$)
   {
      if now = $
      {
         now = getTime();
      }
      
      piLastGuildhallRaid = now;
      
      return;
   }

   MaintenanceTimer()
   "Do five things here: "
   "1) Check to be sure they have 3 members."
   "2) Check for guild maturity."
   "3) Check to ensure there is a guildmaster."
   "4) Accrue rent."
   "5) Check to see if former members of the guild can once more rejoin the "
   "guild."
   {
      local i, hourhours, timeleft, bPKServer;                    

      if Send(self,@GetGuildMaster) = $
      {
         %% this should never happen!  This is just in as a failsafe, since
         %% some commands are guildmaster only!
         DEBUG("MaintenanceTimer: Guild",vrName,"has no guildmaster!");

         % CountVotes will choose whoever has the most political support 
         Send(self,@CountVotes);
      }

      if length(plMembers) < MINIMUM_MEMBERS
      {
         if piThreePersonWarning = 0
         {
            piThreePersonWarning = THREE_PERSON_LIMIT;
         }
         else
         {
            piThreePersonWarning = piThreePersonWarning - 1;
         }
         
         if piThreePersonWarning = 0
         {
            for i in plMembers
            {
               Post(First(i),@MsgSendUser,
                    #message_rsc=guild_threeperson_failed);
            }
            
            Send(self,@Delete,#timerdelete=TRUE);
            
            return;
         }
         else
         {
            if (piThreePersonWarning mod 40) = 0
               OR ((piThreePersonWarning mod 10) = 0
                   AND piThreePersonWarning < 40)
            {
               if piThreePersonWarning = 10
               {
                  hourhours = guild_hour_rsc;
               }
               else
               {
                  hourhours = guild_hours_rsc;
               }
               
               for i in plMembers
               {
                  Post(First(i),@MsgSendUser,
                       #message_rsc=guild_threeperson_failing,
                       #parm1=piThreePersonWarning/10,#parm2=hourhours);
               }
            }
         }
      }
      else
      {
         piThreePersonWarning = 0;
      }

      if piMature > 0
      {
         for i in plMembers
         {
            if Send(First(i),@IsLoggedOn)
            {
               if piMature <> 1
	            {
	               piMature = piMature - 1;
	            }
	            else
	            {
	               %% if they're about to become mature, then
	               %% don't let them if they have fewer than 3 members.
	               if length(plMembers) >= 3
	               {
                     piMature = piMature - 1;
	               }
	            }

               break;
            }
         }
         
         if piMature = 0
         {
            bPKserver = Send(SYS,@IsPKAllowed);
            for i in plMembers
            {
	                 if bPKserver
	                 {
	                    Send(First(i),@ReceiveNestedMail,#from=guild_frular,
		                      #dest_list=[First(i)],
		                      #nest_list=[4,guild_mature_mail,
		                                  4,Send(self,@GetCapDef),
                                        4,Send(self,@GetName),
                                        4,prApprentice_male]);
	                 }
	                 else
	                 {
                       Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                            #dest_list=[First(i)],
                            #nest_list=[4,guild_mature_happyland_mail,
                                        4,Send(self,@GetCapDef),
                                        4,Send(self,@GetName)]);
               }
            }
         }
      }

      Send(self,@AccrueRent);
     
      for i in plFormerMembers
      {
         timeleft = Nth(i,2) - 1;
         
         if timeleft < 1
         {
            plFormerMembers = DelListElem(plFormerMembers,i); 
         }
         else
         {
            SetNth(i,2,timeleft);
         }
      }
      
      if piGuild_hall <> $
         AND Send(Send(self,@GetGuildHall),@GetGuildOwner) <> self
      {
         DEBUG("Guild points to a guild hall that does not point back to it!");
         piGuild_hall = $;
         for i in plMembers
         {
            Post(self,@ResetPowers,#who=First(i),
                 #rank=Send(self,@GetRank,#who=First(i)));
         }
      }
      
      ptMaintenance = CreateTimer(self,@MaintenanceTimer,
                                  Send(SYS,@GetMaintenanceDelay));
      
      return;
   }

   AccrueRent(amount=$)
   "Accrues 'amount' rent if non-nil.  Otherwise, calculates rent that "
   "accrues periodically."
   {
      local rent, i, hourhours;

      if amount <> $
      {
         piRentDue = piRentDue + amount;

         return;
      }

      if piRentDue < 1
      {
         piRentCounter = 0;
      }

      if piRentCounter = 1
      {
         for i in plMembers
         {
            Post(First(i),@MsgSendUser,#message_rsc=guild_rent_nonpayment);
         }
         
         Send(self,@Delete,#timerdelete=TRUE);
         
         return;
      }

      rent = RENT_BASE;
      
      if pbSecret
      {
         rent = rent + RENT_SECRET;
      }
      
      for i in plMembers
      {
         rent = rent + RENT_PER_MEMBER;
      }

      if piGuild_hall <> $
      {
         rent = rent + Send(Send(self,@GetGuildHall),@GetRentValue)/10;   
         for i in plAllies
         {
            rent = rent + RENT_PER_ALLY;
         }
         
         for i in plEnemies
         {
            rent = rent + RENT_PER_ENEMY;
         }
         
         rent = bound(rent,2,$);
      }
      else
      {
         for i in plAllies
         {
            rent = rent + RENT_PER_ALLY/2;
         }
         
         for i in plEnemies
         {
            rent = rent + RENT_PER_ENEMY/5;
         }
         
         rent = bound(rent,2,$);
      }

      piRentDue = piRentDue + rent;
      if piRentCounter = 0
      {
         if piRentDue > (rent * RENT_MAX_OVERDUE)
         {
            piRentCounter = RENT_MAX_OVERDUE;
         }
      }
      else
      {
         piRentCounter = piRentCounter - 1;
      }
      
      if piRentCounter > 0
         AND ((piRentCounter MOD 40) = 0
              OR (piRentCounter < 40 AND piRentCounter MOD 10 = 0))
      {
         hourhours = guild_hours_rsc;
         if piRentCounter = 10
         {
            hourhours = guild_hour_rsc;
         }
         
         for i in plMembers
         {
            Post(First(i),@MsgSendUser,#message_rsc=guild_rent_due,
                 #parm1=piRentDue,#parm2=piRentCounter/10,#parm3=hourhours);
         }
      }

      return;
   }

   PayRent(amount = $)
   "This merely subtracts a number from the rentdue."
   {
      piRentDue = piRentDue - amount;
      if piRentDue < 1
      {
         piRentCounter = 0;
      }
      
      return;
   }

   GetRentDue()
   {
      return piRentDue;
   }

   GetRentCounter()
   {
      return piRentCounter;
   }
   
   GetGuildHall()
   "Returns the guildhall's object, not the guildhall's RID!"
   {
      if piGuild_hall = $
      {
         return $;
      }
      
      return Send(SYS,@FindRoomByNum,#num=piGuild_hall);
   }

   GetGuildHallNum()
   "Used by system to relink recreated guild halls with their former owners."
   {
      return piGuild_hall;
   }

   SetGuildHall(RID=$, name = $, password = $)
   "Performs no checks - those checks are almost all done in ghall.kod."
   {
      local i,j, members;

      if RID = $ or name = $ or password = $
      {
         DEBUG("Invalid info sent to SetGuildHall!");
         
         return FALSE;
      } 

      psPassword = password;
      piGuild_hall = RID;
      for i in plMembers
      {
         Send(self,@ResetPowers,#who=First(i),
              #rank=Send(self,@GetRank,#who=First(i)));

         if NOT Send(First(i),@IsLoggedOn)
         {
            Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                 #dest_list=[First(i)],
                 #nest_list=[4,guild_new_hall_mail, 4,name,
                             4,Send(self,@GetDef), 4,Send(self,@GetName)]);
         }
         else
         {
            Send(First(i),@MsgSendUser,#message_rsc=guild_new_hall,
                 #parm1=name,#parm2=Send(self,@GetDef),
                 #parm3=Send(self,@GetName));
         }
      }
      
      for j in plAllies
      {
         members = Send(j,@GetMemberList);
         for i in Members
         {
            Send(First(i),@MsgSendUser,#message_rsc=guild_new_hall,
                 #parm1=name,#parm2=Send(self,@GetDef),
                 #parm3=Send(self,@GetName));
         }
      }
      
      return;
   }

   AbandonGuildHall()
   {
      local i, j, members;

      if piGuild_hall = $
      {
         return FALSE;  
      }

      psPassword = $;
      
      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=guild_abandon_hall,
              #parm1=Send(Send(self,@GetGuildHall),@GetName),
              #parm2=Send(self,@GetDef),#parm3=Send(self,@GetName));
      }
      
      for j in plAllies
      {
         members = Send(j,@GetMemberList);
         for i in Members
         {
            Send(First(i),@MsgSendUser,#message_rsc=guild_abandon_hall,
                 #parm1=Send(Send(self,@GetGuildHall),@GetName),
                 #parm2=Send(self,@GetDef),#parm3=Send(self,@GetName));
         }
      }
      
      Send(Send(self,@GetGuildHall),@ResetGuildHall);
      piGuild_hall = $;
      
      for i in plMembers
      {
         Send(self,@ResetPowers,#who=First(i),
              #rank=Send(self,@GetRank,#who=First(i)));
      }
      
      return;
   }

   GuildHallConquered(name=$, betrayed = $, oConquerer = $)
   {
      local i, j, members, conq_msg;

      if betrayed = TRUE
      {
         Debug("Guild hall betrayed.");
         conq_msg = guild_hall_betrayed;
      }
      else
      {
         Debug("guild hall just conquered.");     
         conq_msg = guild_hall_conquered;
      }
      
      for i in plMembers
      {
         Post(self,@ResetPowers,#who=First(i),
              #rank=Send(self,@GetRank,#who=First(i)));
         if NOT Send(First(i),@IsLoggedOn)
         {
            Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                 #dest_list=[First(i)],
                 #nest_list=[4,guild_conquered_mail, 4,name,
                             4,Send(self,@GetDef), 4,Send(self,@GetName)]);
         }
         else
         {
            Send(First(i),@MsgSendUser,#message_rsc=conq_msg,
                 #parm1=name,#parm2=Send(self,@GetDef),
                 #parm3=Send(self,@GetName));
         }
      }
      
      psPassword = $;
      piGuild_hall = $;

      for j in plAllies
      {
         if j <> oConquerer
         {
            members = Send(j,@GetMemberList);
            for i in Members
            {
               Send(First(i),@MsgSendUser,#message_rsc=conq_msg,
                    #parm1=name,#parm2=Send(self,@GetDef),
                    #parm3=Send(self,@GetName));
            }
         }
      }

      return;
   }

   ChangePassword(password = $)
   {
      local oMaster;

      psPassword = password;
      oMaster = Send(self,@GetGuildMaster);
      Send(oMaster,@MsgSendUser,#message_rsc=guild_new_password,
           #parm1 = Send(Send(self,@GetGuildHall),@GetName));

      return;
   }

   GetPassword()
   {
      return psPassword;
   }

   
   ReceiveMail(from = $, dest_list = $, perm_string = $)
   "Sends mail to all the members. Structured just like it is when sent to a "
   "player."
   {
      local lMemberInfo;
      
      for lMemberInfo in plMembers
      {
         % First element is the guild object.
         Send(First(lMemberInfo),@ReceiveMail,#from=from,#dest_list=dest_list,
              #perm_string=perm_string);
      }
      
      return;
   }

   CheckInvitationList(inductor = $, inductee = $)
   {
      local i;

      for i in plInvitations
      {
         if Send(i,@getinductor) = inductor
         {
            Send(inductor,@MsgSendUser,#message_rsc=guild_invitation_one);
            
            return FALSE;
         }
      }
      
      for i in plInvitations
      {
         if Send(i,@getinductee) = inductee
         {
            Send(inductor,@MsgSendUser,
                 #message_rsc=guild_invitation_one_inductee,
                 #parm1=Send(inductee,@GetDef),
                 #parm2=Send(inductee,@GetName));
                 
            return FALSE;
         }
      }

      return TRUE;
   }

   AddInvitation(invite_obj = $)
   "Adds the invitation to the list.  This list is stored only so it can"
   "be deleted if the guild is deleted."
   {
      plInvitations = cons(invite_obj, plInvitations);
      
      return;
   }

   RemoveInvitation(invite_obj = $)
   {
      local i;

      for i in plInvitations
      {
         if i = invite_obj
         {
            plInvitations = DelListElem(plInvitations, i);
            
            return TRUE;
         }
      }
      
      DEBUG("invitation wasn't here!");
      
      return FALSE;
   }

   AddTreaty(treaty_obj = $)
   "Adds the invitation to the list.  This list is stored only so it can"
   "be deleted if the guild is deleted."
   {
      plTreaties = cons(treaty_obj, plTreaties);
      return;
   }

   RemoveTreaty(treaty_obj = $)
   {
      local i;

      for i in plTreaties
      {
         if i = treaty_obj
         {
            plTreaties = DelListElem(plTreaties, i);
            return TRUE;
         }
      }
      
      DEBUG("treaty wasn't here!");
      
      return FALSE;
   }

   GetRank(who=$)
   {
      local i;
      for i in plMembers
      {
         if First(i) = who
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }

   GetRankNames()
   {
      return [ prApprentice_Male, prApprentice_Female, prSir, prMadame,
               prLord, prLady, prLieutenant_Male, prLieutenant_Female,
               prMaster, prMistress ];
   }


   GetRankName(sex = GENDER_MALE, rank = RANK_MASTER)
   {
      if rank = RANK_MASTER
      {
         if sex = GENDER_MALE
         {
            return prMaster;
         }
         else
         {
            return prMistress;
         }
      }

      if rank = RANK_LIEUTENANT
      {
         if sex = GENDER_MALE
         {
            return prLieutenant_male;
         }
         else
         {
            return prLieutenant_female;
         }
      }
      
      if rank = RANK_LORD
      {
         if sex = GENDER_MALE
         {
            return prLord;
         }
         else
         {
            return prLady;
         }
      }
      
      if rank = RANK_SIR
      {
         if sex = GENDER_MALE
         {
            return prSir;
         }
         else
         {
            return prMadame;
         }
      }
      
      if sex = GENDER_MALE
      {
         return prApprentice_male;
      }
      
      return prApprentice_female;
   }

   GetMemberList()
   {
      return plMembers;
   }

   GetGuildMaster()
   {
      local i;

      for i in plMembers
      {
         if Nth(i,2) = RANK_MASTER
         {
            return First(i);
         }
      }

      return $;
   }

   GetOfficers()
   "Returns a list of players RANK_LIEUTENANT and higher."
   {
      local i, lOfficers;

      lOfficers = [];

      for i in plMembers
      {
         if Nth(i,2) >= RANK_LIEUTENANT
         {
            Cons(First(i), lOfficers);
         }
      }

      return lOfficers;
   }

   IsMember(who=$)
   {
      local i;

      for i in plMembers
      {
         if First(i) = who
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   InductNewMember(who=$,inductor=$)
   {
      local i;

      if length(plMembers) >= MAX_MEMBERS
      {
         Send(who,@MsgSendUser,#message_rsc=guild_ranks_full,
              #parm1=Send(self,@GetDef),#parm2=vrName);
              
         if inductor <> $
         {
            Send(inductor,@MsgSendUser,#message_rsc=guild_ranks_full_inductor,
                 #parm1=Send(who,@getcapdef),#parm2=Send(who,@GetName),
                 #parm3=Send(self,@GetDef),#parm4=vrName);
         }
         
         return FALSE;
      }
      
      for i in plMembers
      {
         if First(i) = who
         {
            Send(who,@MsgSendUser,#message_rsc = guild_induct_already_member);
            
            return FALSE;
         }
      }
      
      if Send(who,@GetGuild) <> $
      {
         Send(who,@MsgSendUser,#message_rsc = guild_induct_already_guilded);
         
         return FALSE;
      }
      
      % Cannot rejoin the guild if you left recently
      if Send(self,@CheckFormerMemberList,#who=who)
      {
         Send(who,@MsgSendUser,#message_rsc=guild_you_cannot_rejoin);
         if inductor <> $
         {
            Send(inductor,@MsgSendUser,#message_rsc=guild_cannot_rejoin);
         }
         
         return FALSE;
      }
      
      if Send(who,@HasLeftAGuildTooRecently)
      {
         ClearTempString();
         AppendTempString(guild_left_another);
         AppendTempString(Send(self,@GetDef));
         AppendTempString(Send(self,@GetName));
         AppendTempString(".");
         
         Send(who,@MsgSendUser,#message_rsc=Send(SYS,@GetPercentQRsc),
              #parm1=GetTempString(),#type1=STRING_RESOURCE);
         
         if inductor <> $
         {
            ClearTempString();
            AppendTempString(Send(who,@GetName));
            AppendTempString(guild_left_another_2);
            Send(inductor,@MsgSendUser,#message_rsc=Send(SYS,@GetPercentQRsc),
                 #parm1=GetTempString(),#type1=STRING_RESOURCE);
         }
         
         return FALSE;
      }
     
      % Cleared checks.  Go ahead and set the guild.

      Send(who,@SetGuild,#guild_obj=self);
      plMembers = cons([who,RANK_APPRENTICE,Send(self,@GetGuildMaster)],
                       plMembers);
      Send(self,@ResetPowers,#who=who,#rank=RANK_APPRENTICE);

      if length(plMembers) >= MINIMUM_MEMBERS
      {
         piThreePersonWarning = 0;
      }

      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=guild_welcome,
              #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
              #parm3=Send(who,@GetTrueName));

         % Reset friend/foe colors
         Send(First(i),@ToCliRoomContents);
      }

      return TRUE;
   }

   RemoveFromGuild(who=$)
   {
      local i, bFound, oOwner;

      bFound = FALSE;

      for i in plMembers
      {
         if First(i) = who
         {
            % Remove powers, reset poGuild
            Send(who,@ResetGuildStuff);

            Send(who,@EvaluatePKstatus);

            % No joining a guild again for 4 hours.
            Send(who,@SetGuildRejoinTime,#delayMinutes=CANNOT_REJOIN_TIME);

            % No rejoining the same guild for 72 hours.  This is the number of
            %  six-minute periods to wait.
            plFormerMembers = cons([who,CANNOT_REJOIN_TIME*3],plFormerMembers);

            plMembers = DelListElem(plMembers,i);
            bFound = TRUE;
         }

         % Reset friend/foe colors for everyone
         Send(First(i),@ToCliRoomContents);
      }
      
      if bFound = TRUE
      {
         % If this player has an owner (is logged on), then let the room know
         %  something changed so that other players can reset friend/foe
         %  colors.
         oOwner = Send(who,@GetOwner);
         if oOwner <> $
         {
            Send(oOwner,@SomethingChanged,#what=who);
         }

         return TRUE;
      }
      
      DEBUG("Was not a member of this guild!");
      
      return FALSE;
   }
   
   NewGuildMaster(who=$, abdicate = FALSE)
   "Other than creating a guild, this is the only way to have someone's "
   "rank set to guildmaster.  Note that it will depose any current "
   "guildmaster to the rank of normal peon, and reset votes to neutral (nil)!"
   {
      local i, new_master, old_master;

      if who = $
      {
         DEBUG("Tried to promote -no one- to the rank of guildmaster!");
         
         return;
      }
      
      if who = Send(self,@GetGuildMaster)
      {
         DEBUG("Tried to promote existing guildmaster to guildmaster!  Should never happen!");
         
         return;
      }

      %% demote anyone at guildmaster rank
      for i in plMembers                
      {                              
         if Nth(i,2) = RANK_MASTER
         {
            old_master = First(i);
            SetNth(i,2,RANK_SIR);
            if abdicate = FALSE
            {
               if not Send(First(i),@IsLoggedOn)
               {
                  Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                       #dest_list=[First(i)],
                       #nest_list=[4,guild_deposed_mail,
                                   4,Send(self,@GetRankName,#rank=RANK_MASTER,
                                          #sex=Send(old_master,@GetGender)),
                                   4,Send(self,@GetDef),
                                   STRING_RESOURCE,Send(self,@GetName),
                                   STRING_RESOURCE,Send(who,@GetName),
                                   4,Send(self,@GetRankName,#rank=RANK_MASTER,
                                          #sex=Send(who,@GetGender))]);
               }
               else
               {
                  Send(First(i),@MsgSendUser,#message_rsc=guild_descension,
                       #parm1=Send(self,@GetRankName,#rank=RANK_MASTER,
                                   #sex=Send(old_master,@GetGender)),
                       #parm2=Send(self,@GetDef),#parm3=Send(self,@GetName));
               }
            }
            Send(self,@ResetPowers,#who=First(i),#rank=RANK_SIR);
         }

         if First(i) = who
         {
            %% promote to master.
            new_master = First(i);
            SetNth(i,2,RANK_MASTER);
            
            if NOT Send(First(i),@IsLoggedOn)
            {
               Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                    #dest_list=[First(i)],
                    #nest_list=[4,guild_ascension_mail,
                                4,Send(self,@GetRankName,#rank=RANK_MASTER,
                                       #sex=Send(who,@GetGender)),
                                4,Send(self,@GetDef), 4,Send(self,@GetName)]);
            }
            else
            {
               Post(First(i),@MsgSendUser,#message_rsc=guild_ascension,
                    #parm1=Send(self,@GetRankName,#rank=RANK_MASTER,
                                #sex=Send(new_master,@GetGender)),
                    #parm2=Send(self,@GetDef),#parm3=Send(self,@GetName));
            }
            
            Send(self,@ResetPowers,#who=First(i),#rank=RANK_MASTER);
         }
      }
      
      for i in plMembers
      {
         if First(i) <> new_master
            AND (First(i) <> old_master OR abdicate = FALSE)
         {
            if abdicate = TRUE
            {
               Post(First(i),@MsgSendUser,#message_rsc=guild_abdicate,
                    #parm1=Send(old_master,@GetName),#parm2=Send(self,@GetDef),
                    #parm3=Send(self,@GetName));
            }
            
            if not Send(First(i),@IsLoggedOn)
            {
               if First(i) <> old_master
               {
                  Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                       #dest_list=[First(i)],
                       #nest_list=[4,guild_new_master_mail,
                                   STRING_RESOURCE,Send(new_master,@GetName),
	                                4,Send(self,@GetRankName,#rank=RANK_MASTER,
	                                       #sex=Send(new_master,@GetGender)),
                                   4,Send(self,@GetDef),
                                   4,Send(self,@GetName)]);
               }
            }
            else
            {
               Post(First(i),@MsgSendUser,#message_rsc=guild_new_master,
                    #parm1=Send(new_master,@GetTrueName),
                    #type1=STRING_RESOURCE,
	                 #parm2=Send(self,@GetRankName,#rank=RANK_MASTER,
	                             #sex=Send(new_master,@GetGender)),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));
            }
         }
         
         SetNth(i,3,$);
      }
      
      return;
   }

   NewLieutenantOkay()
   {
      local i, number;

      number = 0;
      for i in plMembers
      {
         if Nth(i,2) = RANK_LIEUTENANT
         {
            number = number + 1;
         }
      }
      
      if number >= MAX_LIEUTENANT
      {
         return FALSE;
      }
      
      return TRUE;
   }

   NewLordOkay()
   "Currently, always returns TRUE."
   {
     return TRUE;
   }

   CheckChangeRank(who=$, promoter = $, newrank = $)
   "Bumps the person up a rank, with some limitations: "
   {
      local who_rank, promoter_rank, i, count, bcount;

      if who = $ OR promoter = $ OR newrank = $
      {
         return FALSE;
      }

      promoter_rank= Send(self,@GetRank,#who=promoter);
      if promoter_rank < RANK_LIEUTENANT
      {
         return FALSE;
      }

      who_rank = Send(self,@GetRank,#who=who);
      
      if who_rank >= RANK_MASTER 
      {
         Send(who,@MsgSendUser,#message_rsc=guild_promote_too_high);
         
         return FALSE;
      }  

      if newrank = RANK_LIEUTENANT
      {
         if Send(self,@NewLieutenantOkay)
         {
            return TRUE;
         }
         else
         {
            Send(promoter,@MsgSendUser,#message_rsc=guild_cant_promote_capt,
                 #parm1=Send(self,@GetRankName,#rank=RANK_LIEUTENANT,
                             #sex=GENDER_MALE));

            return FALSE;
         }
      }
      
      if newrank = RANK_LORD
      {
         if Send(self,@NewLordOkay)
         {
            return TRUE;
         }
         else
         {
            Send(promoter,@MsgSendUser,#message_rsc=guild_cant_promote_sire,
                 #parm1=Send(self,@GetRankName,#rank=RANK_LORD,
                             #sex=GENDER_MALE));
                 
            return FALSE;
         }
      }

      % Every possible scenario should be 'if'ed out above.
      return TRUE;      
   }

   ChangeRank(who=$,promoter=$, newrank= $)
   "This promotes someone whether or not they pass CheckPromote or not."
   "anything that calls promote, it is assumed, also passes checkpromote."
   "One caveat.  No one may be promoted to Guildmaster or demoted below "
   "apprentice with this mechanism."
   {
      local i, bPromotion, oldrank, j;

      if newrank <> bound(newrank,1,4)
      {
         return FALSE;
      }
      
      if Send(who,@GetGuild) = self
      {
         for i in plMembers
         {
            if First(i) = who
            {
               oldrank = Nth(i,2);
               if oldrank = newrank
               {
                  return FALSE;
               }
               
               bPromotion = FALSE;               
               if oldrank < newrank
               {
                  bPromotion = TRUE;
               }

               SetNth(i,2,newrank);
               
               Send(self,@ResetPowers,#who=First(i),#rank=newrank);
               if bPromotion = TRUE
               {
                  if promoter <> $ 
                  {
                     Send(who,@MsgSendUser,#message_rsc=guild_promotee,
                          #parm1=Send(promoter,@GetTrueName),
                          #type1=STRING_RESOURCE,
                          #parm2=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                     Send(promoter,@MsgSendUser,#message_rsc=guild_promoter,
                          #parm1=Send(who,@GetTrueName),#type1=STRING_RESOURCE,
                          #parm2=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                          
                     for j in plMembers
                     {
                        if First(j) <> promoter AND First(j) <> who
                        {
                           Send(First(j),@MsgSendUser,
                                #message_rsc=guild_promoted,
                                #parm1=Send(promoter,@GetTrueName),
                                #type2=STRING_RESOURCE,
                                #parm2=Send(who,@GetTrueName),
                                #parm3=Send(self,@GetRankName,#rank=newrank,
                                            #sex=Send(who,@GetGender)));
                        }
                     }
                  }
                  else
                  {
                     Send(who,@MsgSendUser,
                          #message_rsc=guild_promotee_no_promoter,
                          #parm1=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                  }
               }
               else
               {
                  if promoter <> $
                  {
                     Send(who,@MsgSendUser,#message_rsc=guild_demotee,
                          #parm1=Send(promoter,@GetTrueName),
                          #type1=STRING_RESOURCE,
                          #parm2=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                     Send(promoter,@MsgSendUser,#message_rsc=guild_demoter,
                          #parm1=Send(who,@GetTrueName),#type1=STRING_RESOURCE,
                          #parm2=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                          
                     for j in plMembers
                     {
                        if First(j) <> promoter AND First(j) <> who
                        {
                           Send(First(j),@MsgSendUser,
                                #message_rsc=guild_demoted,
                                #parm1=Send(promoter,@GetTrueName),
                                #type2=STRING_RESOURCE,
                                #parm2=Send(who,@GetTrueName),
                                #parm3=Send(self,@GetRankName,#rank=newrank,
                                            #sex=Send(who,@GetGender)));
                        }
                     }
                  }
                  else
                  {
                     Send(who,@MsgSendUser,
                          #message_rsc=guild_demotee_no_demoter,
                          #parm1=Send(self,@GetRankName,#rank=newrank,
                                      #sex=Send(who,@GetGender)));
                  }
               }
               
               return TRUE;
            }
         }
      } 
      else
      {
          DEBUG("guild member is not a member of this guild!");
      }
      
      return;
   }

   Vote(who=$,candidate=$)
   {
      local i, bFound, j, oldvote, newleader;

      if NOT Send(self,@ismember, #who=who)
      {
         DEBUG("Somehow, someone's voting in a guild that is not their own!");
          
         return FALSE;
      }

      if NOT IsClass(candidate,&User)
      {
         DEBUG("voted for an inanimate object of some sort!");
         Send(who,@MsgSendUser,#message_rsc=guild_cant_vote_nonuser,
              #parm1=Send(candidate,@getcapdef),
              #parm2=Send(candidate,@GetTrueName));

      }
      
      for i in plMembers
      {
         if First(i) = candidate
         {
            for j in plMembers
            {
               if First(j) = who
               {
                  oldvote = Nth(j,3);
                  if oldvote = candidate
                  {
                     if who = candidate
                     {         
                        Send(who,@MsgSendUser,
                             #message_rsc=guild_talking_to_self,
                             #parm1=Send(candidate,@GetName));

                        return;
                     }
                     
                     Send(candidate,@MsgSendUser,#message_rsc=guild_reassure,
                          #parm1=Send(who,@GetTrueName));
                          
                     return;
                  }

                  SetNth(j,3,candidate);
                  newleader = Send(self,@CountVotes);

                  if candidate = who
                  {
                     Send(who,@MsgSendUser,#message_rsc= guild_support_self,
                          #parm1=Send(self,@GetDef),
                          #parm2=Send(self,@GetName));
                     if oldvote <> $ AND oldvote <> who AND newleader = FALSE
                     {
                        Send(oldvote,@MsgSendUser,
                             #message_rsc=guild_support_withers);
                     }
                  }
                  else
                  {
                     Send(who,@MsgSendUser,#message_rsc=guild_support_other,
                          #parm1=Send(candidate,@GetTrueName),
                          #type1=STRING_RESOURCE,
                          #parm2=Send(self,@GetDef),
                          #parm3=Send(self,@GetName));
                     Send(candidate,@MsgSendUser,#message_rsc=guild_supported,
                          #parm1=Send(who,@GetTrueName),
                          #parm2=Send(self,@GetDef),
                          #parm3=Send(self,@GetName));
                          
                     if oldvote <> $ and oldvote <> who and newleader = FALSE
                     {
                        Send(oldvote,@MsgSendUser,
                             #message_rsc=guild_support_withers);
                     }
                  }
                  
                  return;
               }
            }
         }
      }
         
      DEBUG("Somehow, someone's voting for someone outside their guild!");
      Send(who,@MsgSendUser,#message_rsc=guild_cant_vote_outsider,
           #parm1=Send(candidate,@GetDef),
           #type2=STRING_RESOURCE,#parm2=Send(candidate,@GetTrueName),
           #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));
           
      return FALSE;
   }

   CountVotes()
   "Note:  currently, all ties go to the oldest guild member."
   {
      local winner, i, j, count, mostvotes, guildmaster;

      % This code is convoluted and slow, so initially, just check to see
      %  if current guildmaster still has the majority.

      guildmaster = Send(self,@GetGuildmaster);

      if guildmaster <> $
      {
         count = 0;   
         for i in plMembers
         {
            if Nth(i,3) = guildmaster
            {
               count = count + 1;
            }
         }
         
         if count > (length(plMembers)/2)
         {
            return FALSE;
         }
      }

      % Guildmaster does not have the majority.  If guildmaster exists, he
      %  still retains leadership as long as no one else has a majority.
      % Since there must always be a guildmaster, if there is no guildmaster,
      %  person with most votes is chosen.

      mostvotes = -1;
      winner = $;
      for i in plMembers
      {
         count = 0;
         for j in plMembers
         {
            if Nth(j,3) = First(i)
            {
               count = count + 1;
            }
         }        
         if count >= mostvotes
         {
            winner = First(i);
            mostvotes = count;
         }
      }

      if (winner <> $) AND (mostvotes > (length(plMembers)/2))
      {
         Send(self,@NewGuildMaster,#who=winner);
         
         return TRUE;
      }
      else
      {
         if winner <> $ AND guildmaster = $
         {
            DEBUG("New guildmaster was declared because there was no old guildmaster!");
            Send(self,@NewGuildMaster,#who=winner);
            
            return TRUE;  
         }
         else
         {
            return FALSE;
         }
      }
      
      return FALSE;
   }

   DefunctGuild(what=$)
   "Removes the guild from all ally and enemy lists."
   {
      local i, j;

      for i in plAllies
      {
         if i = what
         {
            plAllies = DelListElem(plAllies, i);
            for j in plMembers
            {
               Send(First(j),@MsgSendUser,#message_rsc=guild_allies_defunct,
                    #parm1=Send(what,@GetDef), #parm2=Send(what,@GetName));
            }
         }
      }
      
      for i in plEnemies
      {
         if i = what
         {
            plEnemies = DelListElem(plEnemies, i);
            for j in plMembers
            {
               Send(First(j),@MsgSendUser,#message_rsc=guild_enemies_defunct,
                    #parm1=Send(what,@GetDef), #parm2=Send(what,@GetName));
            }
         }
      }
      
      for i in plEnemiesOf
      {
         if i = what
         {
            plEnemiesOf = DelListElem(plEnemiesOf, i);
         }
      }
      
      for i in plAlliesOf
      {
         if i = what
         {
            plAlliesOf = DelListElem(plAlliesOf, i);
         }
      }

      % Reset friend/foe colors
      for i in plMembers
      {
         Send(First(i),@ToCliRoomContents);
      }

      return;
   }

   GetEnemyList()
   {
     return plEnemies;
   }

   GetAllyList()
   {
     return plAllies;
   }

   GetDeclaredEnemyList()
   {
     return plEnemiesOf;
   }

   GetDeclaredAllyList()
   {
     return plAlliesOf;
   }

   IsAlly(otherguild = $)
   "returns TRUE if the guild in question is in the ally list."
   {
      local i;

      for i in plAllies
      {
         if i = otherguild
         {
            return TRUE;
         }
     }
     
     return FALSE;
   }

   IsEnemy(otherguild = $)
   "returns TRUE if the guild in question is in the enemy list."
   {
      local i;

      for i in plEnemies
      {
         if i = otherguild
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   IsMutualEnemy(otherguild = $)
   {
      if otherguild <> $
         AND Send(otherguild,@IsEnemy,#otherguild=self)
         AND Send(self,@IsEnemy,#otherguild=otherguild)
      {
         return TRUE;
      }

      return FALSE;
   }

   CanAlly(otherguild = $, rep = $, otherrep = $)
   "Can the guild ally itself with another guild?  Three checks:"
   "1) Must not be on either ally or enemy list.  2) Rep must be a member. "
   "3) Rep must be at least a lieutenant."
   {
      local i;

      if not Send(self,@IsMember,#who=rep)
      {
         Send(rep,@MsgSendUser,#message_rsc=guild_not_member_currently,
              #parm1=Send(self,@GetDef),#parm2=Send(self, @GetName));
             
         return FALSE;
      }
      
      if Send(self,@GetRank,#who=rep) < RANK_LIEUTENANT
      {
         Send(rep,@MsgSendUser,#message_rsc=guild_not_qualified);
         
         return FALSE;
      }
      
      for i in plEnemies
      {
         if i = otherguild
         {
            Send(rep,@MsgSendUser,#message_rsc=guild_cant_ally_enemy,
                 #parm1 = Send(otherguild,@GetDef),
                 #parm2 = Send(otherguild,@GetName));
                 
            return FALSE;
         }
      }
       
      for i in plAllies
      {
         if i = otherguild
         {
            Send(rep,@MsgSendUser,#message_rsc=guild_already_allies,
                 #parm1 = Send(otherguild,@GetDef),
                 #parm2 = Send(otherguild,@GetName));
                 
            return FALSE;
         }
      }
     
      return TRUE;
   }

   NewAlly(otherguild = $)
   "Put the guild in question in the ally list."
   {
      local i, oMaster, oBook, peace_string1, peace_string2;

      plAllies = cons(otherguild, plAllies);
      
      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=guild_new_allies,
              #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
              #parm3=Send(otherguild,@GetDef),
              #parm4=Send(otherguild,@GetName));

         % Reset friend/foe colors
         Send(First(i),@ToCliRoomContents);
      }
      
      Send(otherguild,@DeclareAlly,#otherguild=self);
      
      % Post this new ally/partnership to the globe in guildmasters.
      
      ClearTempString();
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_peace_title);
      peace_string1 = CreateString();
      setString(peace_string1,GetTempString());
                  
      ClearTempString();
      AppendTempString(guild_peace_body1);
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_peace_body2);
      AppendTempString(Send(otherguild,@GetName));
      AppendTempString(guild_peace_body3);
      peace_string2 = CreateString();
      setString(peace_string2,GetTempString());
                  
      oBook = Send(SYS,@FindNewsByNum,#num=NID_GUILD_NEWS);
      oMaster = Send(Send(SYS,@FindRoomByNum, #num=RID_GMHALL),@GetMaster);
      Send(oBook,@PostNews,#what=oMaster,#title=peace_string1,#body=peace_string2);

      return;
   }

   DeclareAlly(otherguild = $)
   {
      local i;

      plAlliesOf = cons(otherguild, plAlliesOf);
      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=guild_declared_allies,
              #parm1=Send(otherguild,@GetDef),#parm2=Send(otherguild,@GetName),
              #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

         % Reset friend/foe colors
         Send(First(i),@ToCliRoomContents);
      }
      
      return;
   }

   EndAlly(otherguild = $)
   "Removes the guild in question from the ally list.  Tells the other guild "
   "to end it's alliance with you."
   {
      local i, j, oMaster, oBook, peace_string1, peace_string2;

      for i in plAllies
      {
         if i = otherguild
         {
            plAllies = DelListElem(plAllies, i);
            for j in plMembers
            {
               Send(First(j),@MsgSendUser,#message_rsc=guild_end_alliance,
                    #parm1=Send(otherguild,@GetDef),
                    #parm2=Send(otherguild,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

               % Reset friend/foe colors
               Send(First(j),@ToCliRoomContents);
            }
            
            Send(otherguild,@RemoveDeclaredAlly,#otherguild=self);
            
            % Post this end of partnership to the globe in guildmasters.
      
            ClearTempString();
            AppendTempString(Send(self,@GetName));
            AppendTempString(guild_endpeace_title);
            peace_string1 = CreateString();
            setString(peace_string1,GetTempString());

            ClearTempString();
            AppendTempString(guild_peace_body1);
            AppendTempString(Send(self,@GetName));
            AppendTempString(guild_endpeace_body2);
            AppendTempString(Send(otherguild,@GetName));
            AppendTempString(guild_peace_body3);
            peace_string2 = CreateString();
            setString(peace_string2,GetTempString());

            oBook = Send(SYS,@FindNewsByNum,#num=NID_GUILD_NEWS);
            oMaster = Send(Send(SYS,@FindRoomByNum, #num=RID_GMHALL),@GetMaster);
            Send(oBook,@PostNews,#what=oMaster,#title=peace_string1,#body=peace_string2);
            
            return TRUE;
         }
     }
     
     DEBUG("tried to end an alliance that didn't exist!");
     
     return FALSE;
   }

   RemoveDeclaredAlly(otherguild = $)
   "Removes the guild in question from the ally list.  Tells the other guild "
   "to end it's alliance with you."
   {
      local i, j;

      for i in plAlliesOf
      {
         if i = otherguild
         {
            plAlliesOf = DelListElem(plAlliesOf, i);
            for j in plMembers
            {
               Send(First(j),@MsgSendUser,
                    #message_rsc=guild_end_declared_alliance,
                    #parm1=Send(otherguild,@GetDef),
                    #parm2=Send(otherguild,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

               % Reset friend/foe colors
               Send(First(i),@ToCliRoomContents);
            }
            
            Send(otherguild,@RemoveDeclaredAlly,#otherguild=self);
            
            return TRUE;
         }
      }
      
      DEBUG("tried to end an alliance that didn't exist!");
      
      return FALSE;
   }

   CanEnemy(otherguild = $, rep = $)
   {
      % Gotta be mature enough to declare war.

      if NOT Send(self,@IsMature)
      {
         Send(rep,@MsgSendUser,#message_rsc=guild_cant_enemy_mature);

         return FALSE;
      }

      % Gotta have enough cash to declare a war, in case of losing.
      if Send(self,@GetRentDue) > -WAR_LOSS_PENALTY
      {
         ClearTempString();
         AppendTempString(WAR_LOSS_PENALTY);
         Send(rep,@MsgSendUser,#message_rsc=guild_cant_enemy_funds,
              #parm1=GetTempString());

         return FALSE;
      }

      if Send(self,@IsEnemy,#otherguild=otherguild)
      {
         Send(rep,@MsgSendUser,#message_rsc=guild_already_enemies,
              #parm1=Send(otherguild,@GetDef),#parm2=Send(otherguild,@GetName),
              #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

         return FALSE;
      }
      
      if Send(self,@IsAlly,#otherguild=otherguild)        
      {
         Send(rep,@MsgSendUser,#message_rsc=guild_cant_enemy_ally);
         
         return FALSE;
      }
      
      return TRUE;
   }

   NewEnemy(otherguild = $)
   "Put the guild in question in the enemy list."
   {
      local i, rMessage, oMaster, oBook, war_string1, war_string2;

      plEnemies = cons(otherguild, plEnemies);

      % Give the separate war message if this kicks off a mutual war.
      if Send(self,@IsMutualEnemy,#otherguild=otherguild)
      {
         rMessage = guild_mutual_enemies;
      }
      else
      {
         rMessage = guild_new_enemies;
      }

      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=rMessage,
              #parm1=Send(otherguild,@GetDef),#parm2=Send(otherguild,@GetName),
              #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

         % Reset friend/foe colors
         Send(First(i),@ToCliRoomContents);
      }
      
      Send(otherguild,@DeclaredEnemy,#otherguild=self);
      
      % Post this new war to the globe in guildmasters.
      
      ClearTempString();
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_war_title);
      war_string1 = CreateString();
      setString(war_string1,GetTempString());
                  
      ClearTempString();
      AppendTempString(guild_war_body1);
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_war_body2);
      AppendTempString(Send(otherguild,@GetName));
      AppendTempString(guild_war_body3);
      war_string2 = CreateString();
      setString(war_string2,GetTempString());
                  
      oBook = Send(SYS,@FindNewsByNum,#num=NID_GUILD_NEWS);
      oMaster = Send(Send(SYS,@FindRoomByNum, #num=RID_GMHALL),@GetMaster);
      Send(oBook,@PostNews,#what=oMaster,#title=war_string1,#body=war_string2);
      
      return;
   }

   DeclaredEnemy(otherguild=$)
   "Called when another guild declares this guild as an enemy."
   {
      local i,rMessage;

      plEnemiesOf = cons(otherguild, plEnemiesOf);

      % Give the separate war message if this kicks off a mutual war.
      if Send(self,@IsMutualEnemy,#otherguild=otherguild)
      {
         rMessage = guild_mutual_enemies;
      }
      else
      {
         rMessage = guild_declared_enemies;
      }

      for i in plMembers
      {
         Send(First(i),@MsgSendUser,#message_rsc=rMessage,
              #parm1=Send(otherguild,@GetDef),#parm2=Send(otherguild,@GetName),
              #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

         % Reset friend/foe colors
         Send(First(i),@ToCliRoomContents);
      }
      
      return;
   }

   CanEndEnemy(otherguild = $, rep = $)
   "Can this guild end enemy status with this guild?"
   {
      % Are we already suing for peace?
      if ptSuingForPeace <> $
         AND Send(self,@IsMutualEnemy,#otherguild=otherguild)
      {
         % Are we being repetitive with the same guild?
         if otherguild = poGuildSuingForPeace
         {
            Send(rep,@MsgSendUser,#message_rsc=guild_already_suing_for_peace,
                 #parm1=Send(otherguild,@GetDef),
                 #parm2=Send(otherguild,@GetName));
         }
         else
         {
            Send(rep,@MsgSendUser,#message_rsc=guild_only_one_suing_for_peace);
         }

         return FALSE;
      }

      return TRUE;
   }

   EndEnemy(otherguild = $, bSetTimer = TRUE)
   "Removes the guild in question from your enemy list."
   {
      local i, j, iSpoils, oBook, oMaster, war_string1, war_string2;

      % Post this end of partnership to the globe in guildmasters.
      
      ClearTempString();
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_endwar_title);
      war_string1 = CreateString();
      setString(war_string1,GetTempString());
               
      ClearTempString();
      AppendTempString(guild_war_body1);
      AppendTempString(Send(self,@GetName));
      AppendTempString(guild_endwar_body2);
      AppendTempString(Send(otherguild,@GetName));
      AppendTempString(guild_peace_body3);
      war_string2 = CreateString();
      setString(war_string2,GetTempString());
                  
      oBook = Send(SYS,@FindNewsByNum,#num=NID_GUILD_NEWS);
      oMaster = Send(Send(SYS,@FindRoomByNum, #num=RID_GMHALL),@GetMaster);
      Send(oBook,@PostNews,#what=oMaster,#title=war_string1,#body=war_string2);
      
      if NOT Send(self,@IsMutualEnemy,#otherguild=otherguild)
      {
         Send(self,@FinalizeEndEnemy,#otherguild=otherguild);

         return TRUE;
      }

      % Set up temp string for message below.
      ClearTempString();
      AppendTempString(WAR_LOSS_PENALTY);

      Send(self,@AccrueRent,#amount=WAR_LOSS_PENALTY);

      % Give our enemy spoils equal to 60% of the positive rent lost.
      iSpoils = WAR_LOSS_PENALTY - bound(Send(self,@GetRentDue),0,
                                         WAR_LOSS_PENALTY);
      iSpoils = (iSpoils * WAR_WINNER_PERCENT) / 100;

      for i in plEnemies
      {
         if i = otherguild
         {
            for j in plMembers
            {
               Send(First(j),@MsgSendUser,#message_rsc=guild_sue_for_peace,
                    #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
                    #parm3=Send(otherguild,@GetDef),
                    #parm4=Send(otherguild,@GetName));

               Send(First(j),@MsgSendUser,#message_rsc=guild_end_enemy_loser,
                    #parm1=GetTempString());
            }
            
            Send(otherguild,@NotifyOtherEndEnemy,#otherguild=self,
                 #spoils=iSpoils);

            % Don't set the timer if we're undeclaring enemies when deleting.
            if bSetTimer
            {
               ptSuingForPeace = CreateTimer(self,@TimerEndEnemy,PEACE_DELAY);
               poGuildSuingForPeace = otherguild;
            }

            return TRUE;
         }
      }

      DEBUG("tried to remove an enemy that didn't exist!");

      return FALSE;      
   }

   NotifyOtherEndEnemy(otherguild=$, spoils=0)
   "A notification that otherguild wants to sue for peace in mutual war."
   {
      local j;

      % Do we get spoils from a humiliated enemy?
      if spoils > 0
      {
         Send(self,@PayRent,#amount=spoils);

         % Setup temp string for message below.
         ClearTempString();
         AppendTempString(spoils);
      }

      for j in plMembers
      {
         Send(First(j),@MsgSendUser,#message_rsc=guild_sue_for_peace,
              #parm1=Send(otherguild,@GetDef),#parm2=Send(otherguild,@GetName),
              #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

         if spoils > 0
         {
            Send(First(j),@MsgSendUser,#message_rsc=guild_end_enemy_winner,
               #parm1=GetTempString());
         }
      }
      
      return TRUE;
   }

   TimerEndEnemy()
   "Called after the Timer expires to remove an enemy that was mutual."
   {
      ptSuingForPeace = $;
      Send(self,@FinalizeEndEnemy,#otherguild=poGuildSuingForPeace);
      poGuildSuingForPeace = $;

      return;
   }

   FinalizeEndEnemy(otherguild=$)
   "Does the final cleanup of ending an Enemy declaration."
   {
      local i, j;

      for i in plEnemies
      {
         if i = otherguild
         {
            plEnemies = DelListElem(plEnemies, i);

            for j in plMembers
            {
               Send(First(j),@MsgSendUser,#message_rsc=guild_not_enemies,
                    #parm1=Send(otherguild,@GetDef),
                    #parm2=Send(otherguild,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

               % Reset all friend/foe colors
               Send(First(j),@ToCliRoomContents);
            }
            
            Send(otherguild,@RemoveDeclaredEnemy,#otherguild=self);
            
            return TRUE;
         }
      }

      DEBUG("tried to remove an enemy that didn't exist!");

      return FALSE;
   }

   RemoveDeclaredEnemy(otherguild=$)
   {
      local i,j;

      for i in plEnemiesOf
      {
         if i = otherguild
         {
            plEnemiesOf = DelListElem(plEnemiesOf, i);

            % Check to see if we're suing for peace, too.  If so, end our wait
            %  early.
            if poGuildSuingForPeace = otherguild
            {
               DeleteTimer(ptSuingForPeace);
               Post(self,@TimerEndEnemy);
            }

            for j in plMembers
            {
               Send(First(j),@MsgSendUser,
                    #message_rsc=guild_not_declared_enemies,
                    #parm1=Send(otherguild,@GetDef),
                    #parm2=Send(otherguild,@GetName),
                    #parm3=Send(self,@GetDef),#parm4=Send(self,@GetName));

               % Reset friend/foe colors
               Send(First(j),@ToCliRoomContents);
            }
            
            return TRUE;
         }
      }
      
      DEBUG("tried to remove an enemy that didn't exist!");
      
      return FALSE;
   }

   Delete(timerdelete=FALSE)
   "Kick all members out First!"
   "Since the timer may delete the object, TimerDelete checks to be sure "
   "the timer isn't already gone (getting rid of an error message."
   {
      local i;

      if piGuild_hall <> $
      {
         Send(Send(self,@GetGuildHall),@ResetGuildHall);
      }
      
      piGuild_hall = $;
      psPassword = $;

      for i in plEnemies
      {
         % Give mutual enemies their reward for destroying the guild.
         if Send(self,@IsMutualEnemy,#otherguild=i)
         {
            Send(self,@EndEnemy,#otherguild=i,#bSetTimer=FALSE);
         }
      }

      for i in plMembers
      {
         if NOT Send(First(i),@IsLoggedOn)
            AND NOT IsClass(self,&NecromancerGuild)
         {
            Send(First(i),@ReceiveNestedMail,#from=guild_frular,
                 #dest_list=[First(i)],
                 #nest_list=[4,guild_disbanded_mail,4,Send(self,@GetDef),
                             4,Send(self,@GetName)]);
         }
         
         Send(self,@RemoveFromGuild,#who=First(i));
      }
      
      if plMembers <> $
      {
         debug("plMembers not fully empty!",Send(self,@GetName));
         
         plMembers = $;
      }

      % Delete any outstanding invites
      for i in plInvitations
      {
         Send(i,@InvitationVanish);
      }
      
      plInvitations = $;

      if ptMaintenance <> $ AND NOT TimerDelete
      {
         DeleteTimer(ptMaintenance);
      }

      if ptSuingForPeace <> $
      {
         DeleteTimer(ptSuingForPeace);
         ptSuingForPeace = $;
      }

      ptMaintenance = $;
      
      plEnemies = $;
      plAllies = $;
      plEnemiesOf = $;
      plAlliesOf = $;

      % This must be done *after* removing players from guild
      plFormerMembers = $;

      % Reset friend/foe colors
      for i in plMembers
      {
         Send(First(i),@ToCliRoomContents);
      }

      Send(sys,@SystemRemoveFromChampionLists,#oldChamp=self);
      Send(sys,@DefunctGuild,#what=self);

      propagate;
   }

   GetMaxMembers()
   {
      return MAX_MEMBERS;
   }

   ChangeRentDue(amount = -20000)
   {
      if piRentDue < amount
      {
         piRentdue = amount;
      }
      
      return;
   }

   ResetAllGuildCommands()
   "Called from RecreateGuildcommands."
   {
      local i;

      for i in plMembers
      {
         Send(self,@ResetPowers,#who=First(i),
              #rank=Send(self,@GetRank,#who=First(i)));
      }
      
      return;
   }

   CheckFormerMemberList(who=$)
   {
      local i;

      for i in plFormerMembers
      {
         if First(i) = who
         {
            return TRUE;
         }
      }

      return FALSE;     
   }

   RemoveFromFormerMemberList(who=$)
   "Kills any errant pointers to a deleted player."     
   {
      local i;

      if who = $
      {
         DEBUG("Called removefromformermemberlist without an argument!");
         
         return;
      }
      
      for i in plFormerMembers
      {
         if First(i) = who
         {
            plFormerMembers = DelListElem(plFormerMembers,i); 
         }
      }
      
      return;  
   }

   HasGuildColors()
   {
      if piColor1 = XLAT_TO_GRAY
         AND piColor2 = XLAT_TO_GRAY
      {
         return FALSE;
      }

      return TRUE;
   }

   GetPrimaryGuildColor()
   {
      return piColor1;
   }

   GetSecondaryGuildColor()
   {
      return piColor2;
   }

   GetShieldShape()
   {
      return piShield_shape;
   }

   SetGuildColors(color1=$, color2=$, shape = $)
   {
      if Send(self,@HasGuildColors)
      {
         return FALSE;
      }

      if (color1 = $) OR (color2 = $) OR (shape = $)  
      {
         return FALSE;
      }

      if (color1 < XLAT_LOW_VALUE) OR (color1 > XLAT_HIGH_VALUE)
         OR (color2 < XLAT_LOW_VALUE) OR (color2 > XLAT_HIGH_VALUE)
      {
         return FALSE;
      }

      piColor1 = color1;
      piColor2 = color2;
      piShield_shape = shape;

      return TRUE; 
   }

   RecalibrateGuild()
   {
      if plMembers = $
      {  
         debug("Defunct guild still hanging around!  Members are $!",Send(self,@GetName));
         
         plEnemies = $;
         plAllies = $;
         plEnemiesOf = $;
         plAlliesOf = $;
      }

      if Send(self,@GetGuildMaster) = $
      {
         Debug("Guild has no guildmaster!  That's just wrong!", Send(self,@GetName));
      }

      if ptMaintenance = $
      {
         Debug("Guild has no maintenance timer!", Send(self,@GetName));
      }

      return;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

