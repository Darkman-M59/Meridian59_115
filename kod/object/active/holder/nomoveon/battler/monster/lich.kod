% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Lich is Monster

constants:

   include blakston.khd
   LICH_ILLUSION_TIME = 5 * 60 * 1000  % five minutes
   MAGIC_RESIST = 60
   
resources:

   lich_pretty_name_rsc = "Die Königin Venya'cyr"
   lich_pretty_icon_rsc = licha.bgf
   lich_pretty_desc_rsc = "Eine edle Frau von unglaublicher Schönheit. Königin Venya'cyr bewegt sich mit einer kultivierten Eleganz, die in diesem Zeitalter fast nicht mehr gesehen wird. Du kannst Dich nur wundern, wie sie es über all diese Jahrhunderte geschafft hat, ihr Gesicht so jung und schön zu halten."

   lich_name_rsc = "Die Königin Venya'cyr"
   lich_icon_rsc = lichb.bgf
   lich_desc_rsc = "Duch einen dunklen Pakt der Jahrhunderte in der Vergangenheit geschlossen wurde, wird Königin Venya'cyrs entsetzlicher Leichnam durch dunkle Magie am Leben erhalten. Reine Kraft geht spürbar von ihren Augen aus, als ein intensiver Blick Dein Herz mit Furcht erfüllt.Die Jahrhunderte haben scheinbar ihren Zoll von ihrer pysikalischen Form gefordert, denn ihre Haut ist ein Haufen verrottendes Fleisch, das von Würmern bevölkert wird."
      
   lich_dispel = "Die schreckliche Erscheinung des Lichs ist nun enthüllt und für alle sichtbar!"
   lich_respel = "Die schreckliche Erscheinung des Lichs ist wieder mit einer Illusion verdeckt."

   lich_dead_icon_rsc = lichbx.bgf
   lich_dead_name_rsc = "Der Geist von Königin Venya'cyr"

   lich_sound_miss = lich_atk.wav
   lich_sound_death = lich_dth.wav
   lich_sound_aware = lich_awr.wav

   lich_cast_spell = "Die Lichkönigin beschwört die Dunkelheit!!"
   lich_cast_sound = necro01.wav

   lich_death_blow = "Dein letzter Schlag hat die verdorbene Königin Venya'cyr von dieser Ebene der Existenz verbannt!"
   lich_single_killer = "Du hast persönlich die verdorbene Königin Venya'cyr von dieser Ebene der Existenz verbannt!"
   lich_double_killer = "Die verdorbene Lichkönigin wurde dank Dir und Deinen Kameraden von dieser Ebene der Existenz verbannt!"
   lich_helper_killer = "Die verdorbene Lichkönigin wurde dank Dir und Deinen Kameraden von dieser Ebene der Existenz verbannt!"

   lich_no_truce = "Die verdorbene Gegenwart der Lichkönigin zerstört Deine Waffenruhe, bevor Du sie auch nur zaubern kannst."
   lich_killed_world_saved_0 = "~B"
   lich_killed_world_saved_1 = " hat die dunkle Königin Venya'cyr getötet und Meridian von der bösen Herrschaft der Nekromanten befreit!\nDanke an "
   lich_comma = ", "
   lich_and = "und "
   lich_killed_world_saved_2 = ". Die guten Bewohner Meridians können nun wieder in Sicherheit leben, wissend, dass "
   lich_killed_world_saved_3 = " mit der untoten Königin vergangen sind."
   lich_killed_world_saved_nolich = " hat den letzen des Ordens der Nekromanten erschlagen und befreit somit Meridian von ihrer Bosheit!\n"

   lich_spit = lightnin.bgf

   lich_tribute_trigger = "Anerkennung"
   lich_hunger_trigger = "Hunger"

   Lich_starting_password = "Todesmagier"

   lich_hunger_5 = "~rMein Hunger ist wie ein glühende Kohle in meiner Brust! Füttere mich sofort!"
   lich_hunger_4 = "~rIch hungere sehr stark! Der Orden hat mir gegenüber seine Pflichten vernachlässigt. Füttere mich sofort!"
   lich_hunger_3 = "~rIch bin sehr hungrig! Füttere mich, mein Diener."
   lich_hunger_2 = "~rIch bin hungrig und möchte bald gefüttert werden."
   lich_hunger_1 = "~rIch verspüre zur Zeit nur ein wenig Hunger."
   lich_hunger_0 = "~rIch bin zufrieden. Der Orden dient mir gut."

   lich_not_powerful = "~kQueen Venya'cyr sagt, \"~rDein schwacher Geist ist nicht in der Lage, solch mächtige Magie zu lernen.\""
   lich_not_order = "~kQueen Venya'cyr sagt, \"~rNur meine Diener erhalten diesen mächtigen Bonus.\""

   lich_darkbolt = gob.bgf

classvars:

   vrName = lich_pretty_name_rsc
   vrIcon = lich_pretty_icon_rsc
   vrDesc = lich_pretty_desc_rsc
   vrName2 = lich_name_rsc
   vrIcon2 = lich_icon_rsc
   vrDesc2 = lich_desc_rsc
   vrDead_icon = lich_dead_icon_rsc
   vrDead_name = lich_dead_name_rsc
   viDefinite = ARTICLE_NONE
   viIndefinite = ARTICLE_NONE
   viGender = GENDER_FEMALE

   viTreasure_type = TID_LICH
   viSpeed = SPEED_FAST
   viAttack_spell = ATCK_SPELL_UNHOLY
   viLevel = 200
   viDifficulty = 9
   viVisionDistance = 60
   % Attack range of 192, or 3 row/col.
   viAttackRange = 192
   viKarma = -100
   viDefault_behavior = \
      AI_FIGHT_AGGRESSIVE |  AI_FIGHT_WIZARD_KILLER | AI_FIGHT_HYPERAGGRESSIVE \
      | AI_MOVE_FLEE_FRIGHTENERS | AI_FIGHT_THROUGH_WALLS | AI_FIGHT_SWITCHALOT

   viAttributes = MOB_LISTEN | MOB_RECEIVE | MOB_TEACHER

   vrSound_miss = lich_sound_miss
   vrSound_aware = lich_sound_aware
   vrSound_death = lich_sound_death

   vrTributeTrigger = lich_tribute_trigger
   vrHungerTrigger = lich_hunger_trigger

properties:

   piAnimation = ANIM_NONE
   plAttackers = $  % [player,player....]

   poNecromancerGuild = $
   psTempRosterString = $
   
   pbIllusioned = TRUE
   ptGoIllusioned = $

   piBlindAttackChance = 15    % Chance she'll attack with blind
   piBlindCounterChance = 7    % Chance she'll counter a spell or arrow with blind
   piBlindDurationMin = 20  % seconds
   piBlindDurationMax = 30  % seconds

   ptDeathSequence = $
   piDeathSequenceTimestep = 200  % milliseconds

messages:

   Constructed(oNecromancerGuild=$)
   {
      % Keep the scenario deactivated for now.
      %Send(Send(SYS,@GetNecromancerBalance),@ActivateScenario);

      pimax_Hit_Points = pimax_hit_Points * 2;
      piHit_Points = pimax_hit_points * 100;

      plResistances = [ [-ATCK_SPELL_ALL, 60],
                        [ATCK_WEAP_ALL, 60],
                        [ATCK_WEAP_NERUDITE, -20 ],
                        [ATCK_WEAP_BLUDGEON, -20 ],
                        [ATCK_WEAP_SILVER, -60 ],
                        [-ATCK_SPELL_COLD, 90],
                        [-ATCK_SPELL_UNHOLY, 90 ],
                        [-ATCK_SPELL_ACID, 30 ],
                        [-ATCK_SPELL_SHOCK, -20],
                        [-ATCK_SPELL_FIRE, -20 ],
                        [-ATCK_SPELL_HOLY, -40 ],
                        [-ATCK_SPELL_HUNTERSWORD, -90 ]
                      ];

      if oNecromancerGuild <> $
      {
         poNecromancerGuild = oNecromancerGuild;
      }

      propagate;
   }

   SetForSale()
   {
      plFor_sale = [ $, $, $, $ ];

      return;
   }

   GetIcon()
   {
      if pbIllusioned
      {
         return vrIcon;
      }

      return vrIcon2;
   }

   GetName()
   {
      if pbIllusioned
      {
         return vrName;
      }

      return vrName2;
   }

   GetApparentName()
   {
      if pbIllusioned
      {
         return vrName;
      }

      return vrName2;
   }

   ShowDesc()
   {
      if pbIllusioned
      {
         AddPacket(4,vrDesc);

         return;
      }

      AddPacket(4,vrDesc2);

      return;
   }

   DispelIllusionEnchantments()
   {
      if NOT pbIllusioned
      {
         return;
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=lich_dispel,
            #type=SAY_MESSAGE);

      pbIllusioned = FALSE;
      Send(poOwner,@SomethingChanged,#what=self);

      if ptGoIllusioned <> $
      {
         DeleteTimer(ptGoIllusioned);
         ptGoIllusioned = $;
      }

      ptGoIllusioned = CreateTimer(self,@ReplaceIllusions,LICH_ILLUSION_TIME);

      return;
   }

   ReplaceIllusions()
   {
      ptGoIllusioned = $;

      if pbIllusioned
      {
         return;
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=lich_respel,
            #type=SAY_MESSAGE);

      pbIllusioned = TRUE;
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   Delete()
   {
      plAttackers = $;

      if poNecromancerGuild <> $
      {
         Send(self,@ClearNecromancerGuild);
      }

      if ptGoIllusioned <> $
      {
         DeleteTimer(ptGoIllusioned);
         ptGoIllusioned = $;
      }

      if ptDeathSequence <> $
      {
         DeleteTimer(ptDeathSequence);
         ptDeathSequence = $;
         Send(self,@DeathSequence2);
      }

      propagate;
   }

   AssessDamage(what = $,damage = $,atype = 0, aspell = 0,bonus = 0)
   "This is called when something causes damage to us."
   {
      local i;

      for i in plAttackers
      {
         if i = what
         {
            propagate;
         }
      }

      plAttackers = Cons(what,plAttackers);

      propagate;
   }

   SomethingMoved()
   "Delete walls around us."
   {
      if poOwner <> $
      {
         Send(poOwner,@DeleteWallsAroundBattler,#who=self);
      }

      propagate;
   }

   MonsterAttack(what = $)
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   DoCast()
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      Send(poOwner,@SomethingShot,#who=self,#target=poTarget,#projectile=self);
      piAnimation = ANIM_NONE;

      return;
   }


   GetProjectileIcon()
   {
      return lich_darkbolt;
   }

   GetProjectileSpeed()
   {
      return 8;
   }

   SendProjectileAnimation()
   {
      AddPacket(1,ANIMATE_TRANSLATION,1,PT_GRAY_TO_BLACK);
      AddPacket(1, ANIMATE_CYCLE, 4, 40, 2, 1, 2, 5);   % 40ms between animations

      return;
   }

   GetProjectileLightFlags()
   {
      % No lighting information.
      % There probably should be ligthing information, since it's magical-type.
      return LIGHT_FLAG_NONE;
   }

   SendMoveAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,80,2,2,2,5);

      return;
   }

   SendLookAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,200,2,2,2,3);

      return;
   }

   SendAnimation()
   {
      if piAnimation = ANIM_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,150,2,6,2,9,2,1);

         return;
      }

      propagate;
   }

   ReqSpellCast(who = $, oSpell = $, lItems = $)
   {
      if oSpell = Send(SYS,@FindSpellByNum,#num=SID_TRUCE)
      {
         Send(who,@MsgSendUser,#message_rsc=lich_no_truce);

         return FALSE;
      }

      if Random(1,piBlindCounterChance) = 1
         AND Send(self,@CanSee,#what=who)
      {
         Send(self,@MonsterCastAttackSpell,#what=who);

         return FALSE;
      }

      propagate;
   }

   ReqSomethingAttack(what = $,victim = $,use_weapon = $)
   {
      if use_weapon <> $
      {
         if IsClass(use_weapon,&RangedWeapon)
            AND victim = self
            AND Send(self,@CanSee,#what=what)
            AND Random(1,piBlindCounterChance) = 1 
         {
            Send(self,@MonsterCastAttackSpell,#what=what);

            return FALSE;
         }
      }

      propagate;
   }

   MonsterCastAttackSpell(what=$)
   {
      local oSpell, iRandom, oTarget;

      if what = $
      {
         oTarget = poTarget;
      }
      else
      {
         oTarget = what;
      }

      if NOT Send(self,@CanSee,#what=poTarget)
      {
         return;
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLIND);
      iRandom = Random(piBlindDurationMin,piBlindDurationMax);

      if NOT Send(poOwner,@ReqSomethingAttack,#what=self,
                  #victim=poTarget,#use_weapon=self)
      {
         return;
      }

      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=lich_cast_sound);
      Send(poOwner,@SomeoneSaid,#type=SAY_MESSAGE,#string=lich_cast_spell,#what=self);
      Send(self,@DoCast);
      Send(oSpell,@DoBlind,#what=self,#oTarget=oTarget,#iDurationSecs=iRandom);

      return;
   }

   AttackTimer( timer = $ )
   "We were bashing on something before, and now its time to hit it again."
   {
      local oSpell, iRandom;

      iRandom = Random(1,piBlindAttackChance);
      oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLIND);
      Send(self,@ClearBehavior,#timer=timer);

      % Sanity checks.
      if poOwner = $
      {
         Debug("Unreachable. Null Owner");
         Send(self,@EnterStateLimbo);

         return;
      }

      if poTarget = $
      {
         Debug("Unreachable. Null poTarget","monster",self); 
         Send(self,@EnterStateWait);

         return;
      }

      Send(self,@FindNewTarget);

      if NOT Send(self,@CanReach,#what=poTarget)
         AND Send(poTarget,@IsEnchanted,#what=oSpell)
      {
         Send(self,@EnterStateChase,#Target=poTarget);

         return;
      }
      else
      {
         if NOT Send(self,@CanReach,#what=poTarget)
         {
            Send(self,@MonsterCastAttackSpell);
            Send(poBrain,@PostAttackTimer,#mob=self,#state=piState);

            return;
         }
      }

      if NOT Send(poTarget,@IsEnchanted,#what=oSpell)
         AND iRandom = 1
      {
         Send(self,@MonsterCastAttackSpell);
      }
      else
      {
         Send(self,@TryAttack,#what=poTarget);
      }

      Send(poBrain,@PostAttackTimer,#mob=self,#state=piState);

      return;
   }

   FindNewTarget()
   {
      local oBlind, lActive, iRandom, iDistance, iBestDistance, i, each_obj;

      % Only one in three people are considered eligible
      % targets.  The closest is targeted.  Held people
      % aren't considered - she deals with her current
      % target first.  Only people in view are considered.
   
      oBlind = Send(SYS,@FindSpellByNum,#num=SID_BLIND);
      lActive = Send(poOwner,@GetHolderActive);
      iRandom = Random(1,30);
      iBestDistance = 10000;

      if Send(poTarget,@IsEnchanted,#what=oBlind)
      {
         for i in lActive
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            iDistance = Send(self,@SquaredDistanceTo,#what=each_obj);

            if IsClass(each_obj,&User)
               AND Send(self,@CanSee,#what=each_obj)
               AND NOT Send(each_obj,@IsEnchanted,#what=oBlind)
               AND (iRandom < 10 OR iDistance < iBestDistance)
               AND NOT Send(self,@isAlly,#target=each_obj)
            {
               Debug("Lich target change:",each_obj);
               iBestDistance = iDistance;
               Send(self,@TargetSwitch,#what=each_obj,#iHatred=60);

               if iRandom < 5
               {
                  return;
               }
            }
         }
      }

      return;
   }

   Killed(what=$, resetScenario=TRUE, guildDisbandDeath=FALSE)
   {
      local oSpell, oRoom, NumAttackers, i, lichActivated;

      NumAttackers = Length(plAttackers);

      for i in plAttackers
      {
         if i = what
         {
            Send(i,@MsgSendUser,#message_rsc=lich_death_blow);
         }

         if NumAttackers = 2
            AND i <> what
         {
            Send(i,@MsgSendUser,#message_rsc=lich_double_killer);
         }

         if NumAttackers > 2
            AND i <> what
         {
            Send(i,@MsgSendUser,#message_rsc=lich_helper_killer);
         }
      }

      lichActivated = FALSE;
      if plAttackers <> $
         AND poNecromancerGuild <> $
         AND Send(poNecromancerGuild,@GetMemberList) <> $
      {
         lichActivated = TRUE;
      }

      % Disband the guild.
      if NOT guildDisbandDeath
      {
         Send(self,@ClearNecromancerGuild);
      }

      Send(Send(SYS,@FindRoomByNum,#num=RID_LICH_MAZE),@RandomizeLeverEffects);
      Send(Send(SYS,@FindRoomByNum,#num=RID_G9),@RandomizeLeverEffects);

      if what <> $
         AND NOT guildDisbandDeath
      {
         Post(self,@BroadcastLichDeathMessage,#what=what,#Attackers=plAttackers,
               #lichActivated=lichActivated,#resetScenario=resetScenario);
      }

      if resetScenario
         AND ptDeathSequence = $
         AND NOT guildDisbandDeath
      {
         ptDeathSequence = CreateTimer(self,@DeathSequence2,piDeathSequenceTimestep);
      }

      propagate;
   }

   BroadcastLichDeathMessage(what=$, Attackers=$, resetScenario=TRUE,
                              lichActivated=TRUE)
   {
      local i, sKilledMessage, sRoster;

      if lichActivated
      {
         % Send a message to the world.
         sRoster = Send(self,@GetNecromancerRoster);
         ClearTempString();
         AppendTempString(lich_killed_world_saved_0);
         AppendTempString(Send(what,@GetTrueName));
         AppendTempString(lich_killed_world_saved_1);
         for i in Attackers
         {
            if Length(Attackers) > 1
               AND i = Nth(Attackers,Length(Attackers))
            {
               AppendTempString(lich_and);
            }
            AppendTempString(Send(i,@GetTrueName));
            if Length(Attackers) > 2
            {
               AppendTempString(lich_comma);
            }
            else
            {
               AppendTempString(" ");
            }
         }

         AppendTempString(lich_killed_world_saved_2);
         AppendTempString(sRoster);
         AppendTempString(lich_killed_world_saved_3);

         sKilledMessage = SetString($,GetTempString());

         Send(SYS,@AdminSystemMessage,#string=sKilledMessage);
      }
      else
      {
         % Send a message to the world.
         ClearTempString();
         AppendTempString(lich_killed_world_saved_0);
         AppendTempString(Send(what,@GetTrueName));
         AppendTempString(lich_killed_world_saved_nolich);

         sKilledMessage = SetString($,GetTempString());

         Send(SYS,@AdminSystemMessage,#string=sKilledMessage);
      }

      return;
   }

   DeathSequence2()
   {
      ptDeathSequence = $;
      ptDeathSequence = CreateTimer(self,@DeathSequence3,piDeathSequenceTimestep);

      % Tell all amulets and swords the bad/good news.
      Send(&NecromancerAmulet,@LichKilled);

      return;
   }

   DeathSequence3()
   {
      ptDeathSequence = $;
      Send(&HunterSword,@LichKilled,#oLich=self);

      return;
   }

   CanMorphTo()
   {
      return FALSE;
   }

   SpellResist(oSpell=$,who=$,iSpellpower=$)
   {
      local iResistChance;

      if IsClass(who,&DM)
      {
         return FALSE;
      }

      if Send(oSpell,@IsHarmful)
      {
         % Unaffected by Qor spells.  Period.
         if Send(oSpell,@GetSchool) = SS_QOR
         {
            return TRUE;
         }

         iResistChance = MAGIC_RESIST;
         if IsClass(oSpell,&Dazzle)
         {
            % Extra 50% chance to resist.
            iResistChance = (iResistChance * 150) / 100;
         }

         if iSpellPower < 30
            OR Random(0,100) < iResistChance
         {
            return TRUE;
         }
      }

      return FALSE;
   }

%%%%%%%%%%%%%%%%
% Special code %
%%%%%%%%%%%%%%%%
%

   EstablishNecromancerGuild(master=$)
   {
      if master = $
      {
         return;
      }

      if Send(master,@GetGuild) <> $
      {
         Debug("Tried to establish necroguild with master already guilded.");

         return;
      }

      if poNecromancerGuild <> $
      {
         return;
      }

      poNecromancerGuild = Create(&NecromancerGuild,#master=master);
      Send(Send(SYS,@FindRoomByNum,#num=RID_GUILDH15),
               @ClaimGuildHall,#oGuild=poNecromancerGuild,#rep=master,
               #password=Lich_starting_password);

      Send(Send(SYS,@FindRoomByNum,#num=RID_LICH_MAZE),@RandomizeLeverEffects);
      Send(Send(SYS,@FindRoomByNum,#num=RID_G9),@RandomizeLeverEffects);

      return;
   }

   ClearNecromancerGuild()
   {
      if poNecromancerGuild <> $
      {
         Send(poNecromancerGuild,@Delete,#timerdelete=TRUE);
         poNecromancerGuild = $;
      }

      return;
   }

   SomeoneSaid(what = $,type = $,string = $)
   {
      local oAmulet, iAmountDrained, iHunger, rHungerSpiel;

      if IsClass(what,&User)
         AND Send(what,@GetGuild) <> $
         AND Send(what,@GetGuild) = poNecromancerGuild
      {
         if StringContain(string,vrTributeTrigger)
         {
            % Tell the amulet to pay up, find out how much we sucked out.
            oAmulet = $;
            for oAmulet in Send(what,@GetPlayerUsing)
            {
               if IsClass(oAmulet,&NecromancerAmulet)
               {
                  break;
               }
            }

            if oAmulet = $
               OR (NOT IsClass(oAmulet,&NecromancerAmulet))
            {
               propagate;
            }

            iAmountDrained = Send(oAmulet,@LichTributeDrain);

            % Tell the guild object how much was paid.
            if iAmountDrained = 0
            {
               propagate;
            }
            Send(poNecromancerGuild,@PayRent,#amount=iAmountDrained*10000);
         }

         if StringContain(string,vrHungerTrigger)
         {
            iHunger = Send(poNecromancerGuild,@GetRentDue);
            rHungerSpiel = lich_hunger_0;
            if iHunger > 4
            {
               rHungerSpiel = lich_hunger_5;
            }
            if iHunger = 4
            {
               rHungerSpiel = lich_hunger_4;
            }
            if iHunger = 3
            {
               rHungerSpiel = lich_hunger_3;
            }
            if iHunger = 2
            {
               rHungerSpiel = lich_hunger_2;
            }
            if iHunger = 1
            {
               rHungerSpiel = lich_hunger_1;
            }
            Send(what,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,
                  #string=rHungerSpiel);
         }
      }

      propagate;
   }

   GetNecromancerRoster()
   {
      local sRoster;

      ClearTempString();
      Send(&NecromancerAmulet,@NecromancerRosterRequest,#oLich=self);

      if StringContain(GetTempString(),lich_comma)
      {
         AppendTempString(lich_and);
      }
      AppendTempString(psTempRosterString);
      psTempRosterString = $;

      sRoster = SetString($,GetTempString());

      return sRoster;
   }

   NecromancerRosterReply(necroName = $)
   {
      if psTempRosterString <> $
      {
         AppendTempString(psTempRosterString);
         AppendTempString(lich_comma);
      }
      psTempRosterString = necroName;

      return;
   }

   IsAlly(target = $, regroup = FALSE)
   {
      if IsClass(target,&User)
      { 
         if Send(target,@IsUsingA,#class=&NecromancerAmulet)
         {
            return TRUE;
         }
      }

      if IsClass(target,&DM)
      {
         return TRUE;
      }

      propagate;
   }

   SpecialHatredBehavior(what=$)
   {
      local i;

      % She hates anyone with a hunter sword, and goody-goodies too.
      % But she REALLY hates backstabbers.
      if IsClass(what,&User)
      {
         if Send(what,@FindHoldingActive,#class=&HunterSword) <> $
         {
            if poOwner <> $
            {
               return 85;
            }
         }

         if Send(what,@GetKarma) > 30
         {
            return Send(what,@GetKarma);
         }

         if Send(what,@IsUsingA,#class=&NecromancerAmulet)
         {
            for i in plAttackers
            {
               if i = what
               {
                  return 100;
               }
            }
         }
      }

      return 0;
   }

   CreateDeadBody(killer=$)
   {
      local oBody, iQNTindex, oQE;

      oBody = Create(&DeadLich,#Attackers=plAttackers);
      oQE = Send(SYS,@GetQuestEngine);

      Send(oQE,@SetQuestScheduleChance,#index=QST_ID_ESTABLISH_NECROGUILD,
            #new_pct = 100 );
      iQNTindex = First(Nth(Send(oQE,@GetQuestTemplate,#index=QST_ID_ESTABLISH_NECROGUILD),
                        QT_QUEST_NODES));
      Send(oQE,@SetQuestNodeNPCList,#index=iQNTindex,#new_NPC_list=[oBody]);

      return oBody;
   }

   IsUndead()
   {
      return TRUE;
   }

   DMCanArmageddon()
   {
      return FALSE;
   }

   NewOwner(what=$)
   {
      % This should never happen, but if it does...
      if what <> $
         AND NOT IsClass(what,&GuildHall15)
      {
         Debug("Bad Lich!  Go to your room!");
         Post(self,@GoBackToGuildhall);
      }

      propagate;
   }

   LastUserLeft(what = $)
   {
      Post(self,@GoBackToGuildhall);

      propagate;
   }

   GoBackToGuildhall()
   {
      local oGuildh15;

      oGuildh15 = Send(SYS,@FindRoomByNum,#num=RID_GUILDH15);
      Send(oGuildh15,@NewHold,#what=self,#new_row=13,#new_col=49,
            #fine_row=16,#fine_col=00,#new_angle=ANGLE_WEST);

      if Send(oGuildh15,@CountHoldingHowMany,#class=&Lich) > 1
      {
         Debug("More than one lich in the guild hall!!");
      }

      if Send(oGuildh15,@CountHoldingHowMany,#class=&DeadLich) > 0
         AND Send(oGuildh15,@CountHoldingHowMany,#class=&Lich) > 0
      {
         Debug("Both a lich and a dead lich in the guild hall!!");
      }

      return;
   }

   CanEvilTwin()
   {
      return FALSE;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

