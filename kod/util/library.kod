% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Library is UtilityFunctions

% Notes from the dawn of time:
% Here are some things I have had NPC's hint at, things we can add in the
% future:
%        -30 years ago, we traded with people north of the Great Ocean, but we
%         can no longer sail ships, so we don't know what's happened to them.
%        -Two generations ago, there were no monsters in Meridian other than
%         your usual spider.  No one knows where they come from or why.  Only 
%         that they're getting worse.
%        -Far'Nohl (the ghost) also died at about this time.  
%        -Hints of the volcano and swamp we'll be adding.
%        -The Treefolk south of Marion were once gentle, but now are 
%         aggressively expanding their territory.  No one knows why.
%        -A carving dug up in Marion, with a fire killing the digger in his 
%         home soon after.
%        -Jasper, the border town, is fighting a losing battle with monsters.
%        -Cor Noth is developing a pollution problem

constants:
   
   include blakston.khd

resources:

   % for the extended speech and random libs -AJM
   quote_substring = "%q"
   quote_uninitialized = "Ich versuch' zu denken, aber nix passiert!"
   test_quote = "Ich kann sagen, was ich will, dass du es nur weißt."
   append_string = "@*$#!.........."
   append_substring1 = "@*$#!"
   append_substring2 = ".........."
   substring_name = "%NAME"
   substring_sirmadam = "%SIRMADAM"
   substring_ladlassie = "%LADLASSIE"
   substring_lordlady = "%LORDLADY"
   substring_daynight = "%DAYNIGHT"
   plugin_night = "night"
   plugin_day = "Tag"
   plugin_lad = "Junge"
   plugin_lassie = "Mädchen"
   plugin_sir = "Sir"
   plugin_madam = "meine Dame"

   faction_visit_completed = "Du erfährst, dass der Auftrag des königlichen Hofs erledigt wurde. Deine Versuche, diesen zu erfüllen, haben jedoch Deinen guten Willen gezeigt. Du bist weiterhin ein Mitglied des königlichen Hofs."
   faction_visit_novice = "Es tut mir leid, aber Du bist noch nicht erfahren genug, um Mitglied am königlichen Hof zu werden. Bitte komme später wieder."
   factionite_visit_start = "Willkommen am Hof, mein Anhänger. Wenn Du mir diese Nachricht überbringst, bist Du Deiner Pflicht für einige Zeit nachgekommen."
   neutral_visit_start = "Willkommen! Wenn Du meiner Anhängerschar beitreten willst, musst Du mir erst Deine Ergebenheit erweisen."
   faction_too_strong = "Tut mir leid! Aber ich habe zur Zeit mehr als genug Anhänger. Solltest Du später wiederkommen, habe ich vielleicht Verwendung für Dich."
   faction_visit_wrong = "Es ist bekannt, dass Du meinem Widersacher dienst. Bevor Du nicht das Lager wechselst, werde ich Dir keinen Auftrag erteilen, %s "
   faction_visit_wrong_accept = "Trotzdem werde ich Dich vielleicht aufnehmen, wenn Du mir ein Artefakt bringst."
   faction_visit_wrong_decline = "Tut mir leid! Aber ich habe zur Zeit mehr als genug Anhänger. Solltest Du später wiederkommen, habe ich vielleicht Verwendung für Dich."
   faction_visit_too_soon = "Du brauchst mir Deine Ergebenheit nicht schon wieder beweisen. Laß anderen den Vortritt."

   LM_town_tokendeath = "Wenn man ein Artefakt trägt, soll man keinen Schaden durch den Tod erleiden. Wie gesagt, nur ein Gerücht!"
   LM_town_tokenmove = "Niemand hat bisher herausgefunden, warum sich die Artefakte der Ratsmitglieder wegteleportieren."
   LM_town_tokenblink = "Neulich sah ich, wie ein Ratsmitglied ein Artefakt ins Wasser fallen ließ. Kurze Zeit später teleportierte es sich aber seltsamerweise wieder an Land."
   LM_advice_string1 = "%s"
   LM_advice_string2 = "%s %s"
   LM_advice_string3 = "%s %s %s"
   LM_monster_has_high_karma = "%s%s ist eine friedfertige und gutmütige Kreatur."
   LM_monster_has_good_karma = "%s%s hat ein gutes Herz, ist aber nicht extrem gut."
   LM_monster_has_neutral_karma = "%s%s ist eine harmlose Kreatur, die weder besonders gutmütig noch besonders böse ist."
   LM_monster_has_bad_karma = "%s%s ist eine böse Kreatur, nicht so böse wie einige andere, aber bestimmt nicht gutartig."
   LM_monster_has_low_karma = "%s%s ist eine wahrlich böse Kreatur, ohne Zweifel ein Diener von Qor."

   LM_monster_for_groups = "Am besten greifst Du mit Freunden an Deiner Seite an."
   LM_monster_too_easy = "%s%s dürfte im Kampf kaum eine Herausforderung für jemanden wie Dich sein. Es ist reine Zeitverschwendung, wenn Du Dich an so einem unwürdigen Gegner versuchst."
   LM_monster_too_hard = "%s%s ist stärker, als Du Dir vorstellen kannst, aber ein Kampf wird sicherlich Deine Waffenfertigkeiten verbessern - solltest Du überleben!"
   LM_monster_really_hard = "%s%s ist ein furchteinflößender Feind. Ein Angriff grenzt fast schon an Selbstmord."
   LM_monster_about_right = "%s%s ist eine faire Herausforderung für Dich. Dabei könntest Du die eine oder andere Fertigkeit verbessern."

   LM_haz_factions = "Der Herzog und die Prinzessin zanken sich ständig um irgendwelche Sachen. Zum Glück braucht Dich das hier nicht zu interessieren."
   LM_haz_towns = "Die fünf Städte liegen sehr weit von hier entfernt."
   LM_haz_help = "Ich werde versuchen, Dir eine Hilfe zu sein, aber Du solltest zuerst die Schilder lesen."
   LM_haz_quest = "Hmm, darüber ist mir nichts bekannt. Du solltest die Alten zu Rate ziehen."
   LM_haz_quest_elder = "Ja, ja ich brauche Abenteurer, die das Mausoleum im Norden der Stadt von den Mumien befreien!"
   LM_haz_mausoleum = "Einstmals eine heilige Städte der Dorfbewohner. Der Platz ist heute jedoch von den vielen Untoten entweiht."
   LM_haz_mummy = "Nobler Vorfahr oder ruheloser Wanderer? Egal, die Mumien sind abscheuliche Kreaturen und müssen vernichtet werden!"
   LM_haz_quest_entroot = "Hmmm... Ich hörte, dass Eric Jorn stets nach Wurzelknollen sucht. Ich habe aber keine Ahnung, warum..."
   LM_haz_entroot_none = "Wurzelknollen? Nein, ich glaube nicht, dass sie hier zu finden sind."
   LM_Haz_entroot_response = "Die Mumien nutzen die Magie der Wurzelknollen, um am Leben zu bleiben. Vielleicht haben sie ein paar dabei?"
   LM_haz_smith_buy = "Wenn Du eine Waffe oder Rüstung findest, kann ich vielleicht soviel Geld zusammenkratzen, um sie Dir abzukaufen."
   LM_haz_smith_sell = "Ich kann Dir ein paar Waffen zeigen. Tippe KAUFEN."
   LM_haz_elder_buy = "Ich habe kein Interesse an weltlichen Gütern."
   LM_haz_elder_sell = "Sehe ich aus wie ein gewöhnlicher Hausierer?!"
   LM_haz_apoth_buy = "Ich suche verzweifelt nach Reagenzien. Wenn Du welche findest, würde ich sie gerne erwerben."
   LM_haz_apoth_sell = "Mein Warenlager ist beinahe leer. Alles, was ich noch habe, sind Rote Pilze."
   LM_haz_innk_buy = "Ich handle nicht mit allem, was den Leuten den lieben langen Tag so einfällt!"
   LM_haz_innk_sell = "Ich habe leider keine Räume zu vermieten."
   LM_haz_bar_buy = "Ich glaube, mein Händler würde verrückt spielen, wenn er wüßte, dass ich mit Dir Handel treibe!"
   LM_haz_bar_sell = "Ich habe hier reichlich Nahrungsmittel, die einem Abenteurer schmecken und ihn auf den Beinen halten!"
   LM_haz_meridian = "Ja, da sind wir! Natürlich ist das gerade einmal ein winziger Teil der Welt. Ein echter Abenteurer wie Du hat noch jede Menge zu entdecken!"
   LM_haz_ravi = "Der Apotheker sucht immer nach Reagenzien für sein Lager."
   LM_haz_rodric = "Ich habe gehört, dass der alte Mann einen Auftrag für Dich hat."
   LM_haz_marcus = "Ein guter Mann, ein wirklich guter Mann! Wenn Du verwundet bist, kannst Du Dich in seiner Kneipe hervorragend erholen."
   LM_haz_tomas = "Ein Krieger sollte immer bewaffnet sein. Verkaufe alle Gegenstände, die Du findest, an den Händler Thomas. So kannst Du Dir etwas dazuverdienen."
   LM_haz_eric = "Der beste Wirt auf dieser Seite von Barloque! Ich hörte, er sucht irgendetwas..."

   LM_no_mana_nodes = "Du bist noch mit keinen magischen Quellen verbunden."
   LM_mana_nodes = "Deine Aura ist mit folgenden magischen Quellen verbunden: %q."
   

   QM_missed_middle = "Was ist das? Das ergibt doch keinen Sinn. Bist Du sicher, dass Du %s%s aufgesucht und die ~Irichtige~n Botschaft für mich hast?"
   QM_never_sent = "Anscheinend versuchst Du mich zu betrügen, oder? Ich glaube nicht, dass Du mich jemals um einen Gefallen gebeten hast!"
   QM_no_record = "Hmmm. Bist Du sicher, dass Du diese Botschaft überbringen solltest? Vielleicht solltest Du noch einmal zurückeilen und Dich vergewissern."
   QM_old_phrase = "Vielen Dank, aber ich habe diese Botschaft bereits von jemand anderem erhalten."
   QM_mob_phrase = "Ich habe gehört, dass %s%s eine Botschaft für mich hat. Derjenige, der mir die Botschaft als erster überbringt, erhält eine Belohnung für seine Mühe."
   QM_mob_object = "Tut mir leid, aber im Moment brauche ich nichts. Ich hoffe, Du weißt aber trotzdem, dass ich Dich belohnen werde, solltest Du mir zur rechten Zeit einen Gefallen erweisen."
   QM_hint_msg = "Wer schickt Dich? Ich werde sehen, ob ich eine Botschaft für ihn habe."

   QM_mob_int_phrase = "Geh und bring mir eine Botschaft von %s%s. Wenn Du gerade nicht kannst, schicke mir doch jemanden, der mir helfen kann."
   QM_hint_int_phrase = "Ahh, ich verstehe, Du bist auf einer Mission für den königlichen Hof. Bitte sage %s%s, ~B%s %s %s~n."

   QM_hint_phrase = "Ich wäre Dir sehr dankbar, wenn Du %s%s, ~B%s %s %s~n als Botschaft überbringen würdest."
   QM_hint_object = "Ich hörte, dass %s%s etwas sucht: %s%s."
   QM_already_done = "Du hast Dir meine Gefallen bereits verdient. Deshalb brauchst Du mir keinen mehr zu erweisen. Wenn Du bereit bist, werde ich Dich unterrichten."
   QM_ID_congrats = "Ich habe Deinen Einsatzwillen bereits registriert. Wenn Du bereit bist, komm zu mir zurück und ich werde Dich mit Freude unterrichten."
   QM_item_congrats = "Ich stehe in Deiner Schuld. Bitte erlaube mir, Dir eine kleine Gegenleistung zukommen zu lassen."
   QM_money_congrats = "Danke. Ich kann Deinen Einsatz nur mit Geld belohnen, aber es gibt sicher einen Wunsch, den Du Dir damit erfüllen kannst."
   QM_item_too_heavy = "Möglicherweise kannst Du nichts mehr tragen. %s%s findest Du zu Deinen Füßen."

   QM_join_congrats = "Danke, dass Du Dich mir angeschlossen hast. Ich erwarte große Taten von Dir. Dieser kleine Geldbetrag soll Dir auf Deinen Wegen helfen."
   QM_visit_congrats = "Du hast erneut Deine Ergebenheit bewiesen und hier ist Deine Belohnung. Du brauchst in nächster Zeit nicht zum königlichen Hof zurückzukehren, doch wann immer Du ein Artefakt seinem rechtmäßigen Besitzer zurückgibst, werden wir uns dankbar zeigen."

%responses

%Tos responses
   
%Barloque responses

%Marion responses

%Cor Noth responses

%Jasper responses

% priestesses

   LM_shal_prst_faction_resign = "Du kannst Dich von Deiner jetzigen Fraktion lossagen, indem Du mir ein Artefakt bringst. Aber Du kannst natürlich auch warten, bis man sich Deiner Ergebenheit nicht mehr sicher ist und Dich entläßt."

   LM_onecon_banker_buy = "Ich kenne einige Geheimnisse, aber ich werde sie nur einen Meister der magischen Künste lehren."
 

%triggers
   LT_hi = "Hallo"
   LT_hiya = "hi"
   LT_hello = "Guten Tag"
   LT_howdy = "ciao"
   LT_bye = "Tschüs"
   LT_goodbye = "Auf Wiedersehen"
%   LT_farewell = "farewell"
   LT_help = "hilfe"
   
   LT_ohm = "ohm"
   LT_quest = "Auftrag"
   LT_mausoleum = "Mausoleum"
   LT_mummy = "Die Mumie"
   LT_mummies = "Mumien"
   LT_entroot = "Wurzelknollen"
   
   LT_errand = "Auftrag"
   LT_favor = "Auftrag"
   LT_teach = "lernen"
   LT_token = "Artefakt"
   LT_council = "königlicher Hof"
   LT_message = "Botschaft"
   LT_duke = "Herzog"
   LT_akardius = "Akardius"
   LT_princess = "Prinzessin"
   LT_kateriina = "Kateriina"
   LT_jonas = "Jonas"
   LT_court = "Hof"
   LT_learn = "lernen"
   LT_members = "Mitglieder"

   LT_aubergine = "aubergine"
   LT_baobab = "baobab"
   LT_couloir = "couloir"
   LT_dornick = "dornick"
   LT_ergot = "ergot"
   LT_francolin = "francolin"
   LT_heddle = "heddle"
   LT_infusorian = "infusorian"
   LT_jejune = "jejune"
   LT_kedge = "kedge"
   LT_lumbago = "lumbago"
   LT_megalith = "megalith"
   LT_nunatak = "nunatak"
   LT_operculum = "operculum"
   LT_pettifogger = "pettifogger"
   LT_quisling = "quisling"
   LT_rigatoni = "rigatoni"
   LT_solarium = "solarium"
   LT_tiara = "tiara"
   LT_ullage = "ullage"
   LT_valance = "valance"
   LT_whirlwind = "whirlwind"
   LT_xylem = "xylem"
   LT_yamen = "yamen"
   LT_zeitgeist = "harrgodle"
   LT_nodes = "Magische Quellen"

%Temples
   LT_patience = "Geduld"
   LT_devotion = "Ergebenheit"
   LT_path = "Pfad"
   LT_paths = "Pfade"
   LT_disciple = "Anhänger"

%Priestesses
   LT_resign = "lossagen"
   LT_service = "Dienst"
   LT_onecon = "Alzahakar"
   LT_twocon = "Bei Naq"
   LT_threecon = "Zylill"
   LT_fourcon = "Drex"
   LT_fivecon = "Esseldi"
   LT_vile = "scheußlich"
   LT_good = "gut"
   LT_jala = "Jala"
   LT_faren = "Faren"
   LT_pray = "beten"
   LT_prayer = "Gebet"

%Wanderers
   LT_war = "Krieg"
   LT_rebel = "Rebell"
   LT_rebellion = "Rebellion"
   LT_freebird = "freier Vogel"

%Kocatan people
   LT_customs = "Zoll"
   LT_cheat = "betrügen"
   LT_liar = "Lügner"
   LT_scam = "Schwindel"
   LT_balo = "Balo na?te Din"
   LT_arm = "Waffe"
   LT_konima = "Konima"
   LT_avar = "Avar"
   LT_zala = "Zala"
   LT_smoke = "Rauch"
   LT_bud = "Knospe"
   LT_army = "Armee"
   LT_wulfgang = "Wulfgang"
   LT_precious = "wertvoll"
   LT_business = "Geschäft"
   LT_kazot = "Kazot"
   LT_zoszin = "Zoszin"

%Tos people
   LT_aid = "Hilfe"
   LT_tos = "Tos"
   LT_town = "Stadt"
   LT_here = "hier"
   LT_grandfather = "Großvater"
   LT_history = "Geschichte"
   LT_peaceful = "friedlich"
   LT_ghost = "Der Geist"
   LT_ghosts = "Geister"
   LT_evils = "Böse"
   LT_evil = "böse"
   LT_reagents = "Reagenzien"
   LT_herbs = "Kräuter"
   LT_bank = "Bank"
   LT_money = "Geld"
   LT_gold = "golden"
   LT_interest = "Interesse"
   LT_barloque = "Barloque"
   LT_yevitan = "Yevitan"
   LT_inn = "Kneipe"
   LT_talk = "Gerüchte"
   LT_rumors = "Gerüchte"
   LT_rumor = "Gerücht"
   LT_stranger = "Fremder"
   LT_stories = "Geschichten"
   LT_old = "alte"
   LT_ocean = "Meer"
   LT_shore = "Land"
   LT_jasper = "Jasper"
   LT_woman = "Frau"
   LT_ruins = "Ruinen"
   LT_armor = "Die Rüstung"
   LT_weapon = "Waffe"
   LT_forge = "Schmiede"
   LT_blacksmith = "Schmied"
   LT_fehr = "Fer'loi"
   LT_paddock = "Paddock"
   LT_shutup = "Halt die Klappe"
   LT_shillings = "Schillinge"

%% newbie area triggers   
   LT_Meridian = "Meridian"
   LT_ravi = "Ravin"
   LT_eric = "Eric"
   LT_Marcus = "Markus"
   LT_Tomas = "Thomas"
   LT_Rodric = "Rodrik"

%Barloque people
   LT_apothecary = "Apotheker"
   LT_dwindles = "schrumpft"
   LT_dwindle = "schrumpfen"
   LT_population = "Bevölkerung"
   LT_people = "Leute"
   LT_twice = "zweimal"
   LT_docks = "Docks"
   LT_abandoned = "verlassen"
   LT_rich = "reich"
   LT_save = "sichern"
   LT_die = "Der Würfel"
   LT_crook = "Halsabschneider"
   LT_scoundrel = "Schurke"
   LT_drink = "Getränk"
   LT_ale = "Bier"
   LT_wreckage = "Wrack"
   LT_explorer = "Entdecker"
   LT_volcano = "Vulkan"
   LT_adventurer = "Abenteurer"
   LT_coast = "Küste"
   LT_sea = "Meer"
   LT_complaint = "Beschwerde"
   LT_sailor = "Seemann"
   LT_sail = "Segel"
   LT_sailing = "segeln"
   LT_sailin = "segeln"
   LT_ships = "Schiffe"
   LT_time = "Zeit"
   LT_tides = "Wellen"
   LT_dangerous = "gefährlich"
   LT_hulls = "Rumpf"
   LT_strain = "Rasse"
   LT_story = "Geschichte"
   LT_others = "andere"
   LT_cor = "Cor"
   LT_marion = "Marion"
   LT_rabble = "Pöbel"
   LT_wealthy = "reich"
   LT_skivlat = "Skivlat"
   LT_jewel = "Edelsteine"
   LT_broker = "Händler"
   LT_madelia = "Madelia"
   LT_kraanan = "Kraanan"
   LT_hazar = "Hazar"
   LT_kocatan = "Kocatan"
   LT_kocatan2 = "Ko'catan"
   LT_shal1 = "Sha-Lill"
   LT_shal2 = "Sha-Lill"
   LT_riija = "Riija"
   LT_guild = "Die Gilde"
   LT_pritchett = "Pritchet"
   LT_frular = "Frular"
   LT_frisconar = "Frisconar"

%Marion people
   LT_years = "Jahre"
   LT_age = "Alter"
   LT_changes = "Veränderung"
   LT_monsters = "Monster"
   LT_tricks = "Tricks"
   LT_true = "wahr"
   LT_orc = "Der Ork"
   LT_undead = "Untoten"
   LT_new = "neu"
   LT_creatures = "Kreaturen"
   LT_now = "jetzt"
   LT_yet = "nun"
   LT_treefolk = "Waldschrate"
   LT_smith = "Schmied"
   LT_obvious = "offensichtlich"
   LT_gossip = "Tratsch"
   LT_ran = "Ran"
   LT_wisdom = "Weisheit"
   LT_news = "Neuigkeiten"
   LT_strange = "seltsam"
   LT_quiet = "ruhig"
   LT_fire = "Zielen"
   LT_corinna = "Corinna"
   LT_eldwin = "Eldwin"
   LT_zig = "Wendepunkt"
   LT_hot = "heiß"
   LT_ranerhoth = "Ran'er Zen"
   LT_alarm = "Alarm"
   LT_father = "Vater"
   LT_apple = "Der Apfel"
   LT_crazy = "wahnsinnig"
   LT_mad = "verrückt"
   LT_lunatic = "irre"
   LT_dream = "träumen"

%Cor Noth people
   LT_meet = "treffen"
   LT_gather = "versammeln"
   LT_towns = "Städte"
   LT_trade = "Handel"
   LT_problems = "Probleme"
   LT_profit = "Profit"
   LT_nohl = "Far'Nohl"
   LT_death = "Tod"
   LT_swamp = "Sumpf"
   LT_pollution = "Vergiftung"
   LT_uses = "Nutzen"
   LT_sludge = "Schlamm"
   LT_nobility = "Adel"
   LT_ant = "Die Riesenameise"
   LT_centipede = "Der Tausendfüßler"
   LT_babysp = "Die Spinne"
   LT_baby = "Spinne"
   LT_giantrat = "Die Riesenratte"
   LT_giant = "riesig"
   LT_rat = "Riesenratte"
   LT_fairy = "Fey"
   LT_slime = "Der Schleim"
   LT_tree = "Die Kiefer"
   LT_living = "Waldschrat"
   LT_spider = "Die Riesenspinne"
   LT_queen = "Königin"
   LT_queensp = "Die Spinnenkönigin"
   LT_yeti = "Yeti"
   LT_shadow_mummy = "Die Schattenmumie"
   LT_troll = "Der Troll"
   LT_zombie = "Der Zombie"
   LT_fungusbeast = "Das Pilzwesen"
   LT_fungus = "Pilzwesen"
   LT_mutant = "Rote Ameise"
   LT_skeleton = "Das Skelett"
   LT_scorpion = "Skorpion"
   LT_elhai = "Elhai"
   LT_dirhai = "Dirhai"
   LT_lupogg = "Der Lupogg"
   LT_punch = "Boxen"
   LT_slash = "Zuschlagen"
   LT_dodge = "Ausweichen"
   LT_parry = "Parieren"
   LT_brawling = "Ringen"
   LT_fencing = "Fechten"
   LT_macefgt = "Streitkolbenkampf"
   LT_axewield = "Axtkampf"
   LT_hammwield = "Hammerkampf"
   LT_scimwield = "Säbelkampf"
   LT_weaponcraft = "Waffenfertigkeiten"
   LT_levone = "Zirkel 1"
   LT_levtwo = "Zirkel 2"
   LT_levthree = "Zirkel 3"
   LT_levfour = "Zirkel 4"
   LT_levfive = "Zirkel 5"
   LT_herbutte = "Herbut"
   LT_sir = "Sir"

%Jasper people
   LT_fighting = "kämpfen"
   LT_mountains = "Berge"
   LT_place = "Stelle"
   LT_qor = "Qor"
   LT_trolls = "Trolle"
   LT_ports = "Hafen"
   LT_closed = "geschlossen"
   LT_bar = "Kneipe"
   LT_ship = "Schiff"
   LT_defense = "Verteidigung"
   LT_garrison = "Garnison"
   LT_knowledge = "Wissen"
   LT_shadows = "Schatten"
   LT_flask = "Die Flasche"
   LT_froz = "Froz"
   LT_berserk = "Berserker"
   LT_closer = "näher"
   LT_crisis = "Krise"
   LT_attacked = "angegriffen"
   LT_attack = "Attacke"
   LT_soldiers = "Soldaten"
   LT_hard = "hart"
   LT_times = "Zeiten"
   LT_merchant = "Händler"
   LT_supplies = "Vorräte"
   LT_sell = "verkaufen"
   LT_buy = "kaufen"
   LT_soon = "sobald"
   LT_shortage = "Mangel"
   LT_again = "wieder"
   LT_strike = "schlagen"
   LT_quintor = "Quintor"
   LT_drunk = "betrunken"
   LT_widow = "Witwe"
   LT_afiera = "Afiera Xor"
   LT_secret = "geheim"
   LT_broom = "Besen"
   LT_kill = "töten"
   LT_assassin = "Meuchelmörder"
   LT_murder = "Mörder"
   LT_whiskey = "Whiskey"
   LT_pietro = "Pietro"
   LT_zhieu = "Bob"
   LT_qesino = "Qesino"
   LT_king = "König"
   LT_yes = "Ja"
   LT_wryn = "Feste"
   LT_wool = "Wolle"
   LT_tova = "Tova"

   % Former spell names, now used for mood reactions
   LT_mend = "Reparieren"
   LT_mending = "Reparatur"
   LT_blind = "Blenden"
   LT_dement = "Verblöden"
   LT_lightnin = "Blitz"

%%%%%%%%%%

   %%% Fortunes (suitable to find in cookies)

   % By Greenwich/Ed Halley
   FC_1 = "Qor kümmert das nicht!"
   FC_2 = "Tief in Deiner Seele glaubst auch Du an Sha-Lill."
   FC_3 = "Du wirst Dich vor Kraanan verbeugen."
   FC_4 = "Die Auswirkungen von Farens Energie sollte man nicht auf die leichte Schulter nehmen."
   FC_5 = "Riija zu betrügen ist ein Ziel in sich selbst."

   % By Klaatu/Chris Sellers
   FC_10 = "Du hast das große Verlangen, Kraanans Tempel zu sehen."
   FC_11 = "Lange herbeigesehnte Kräfte werden für Dich bald in Reichweite sein."
   FC_12 = "Deine Fraktion wird immer mächtiger."
   FC_13 = "Manche Leute kommen schon als Helden auf die Welt; andere machen sich selbst zu Helden; wieder anderen fliegt das Heldentum einfach zu. Welcher Gruppe gehörst Du an?"



   FC_14 = "Verschwiegenheit ist eine Zier."
   FC_15 = "Einem geschenkten Ork schaut man nicht ins Maul."
   FC_16 = "Hüte Dich vor den Dienern von Qor, die Geschenke mit sich herumtragen."
   FC_17 = "Stehe Deinen Freunden in der Schlacht bei, und Du wirst reich belohnt werden."
   FC_18 = "Ein Schüler von Faren wird Dir gute Nachrichten bringen."
   FC_19 = "Der dunkelrote Himmel verheißt Chaos und Vernichtung."
   FC_20 = "Suche nicht weiter; das Glück ist ganz in Deiner Nähe."
   FC_21 = "Was ist dieses Leben, das in unseren Venen wie Feuer pulsiert? Leben ist wie flüssiges Eisen, zum Gießen bereit; wähle die Form, und das Leben wird sie für Dich brennen."



   FC_22 = "Achte auf Dein Schwert und Dein Schwert wird Dich achten."
   FC_23 = "Großer Reichtum ist für Dich zum Greifen nahe, wenn Du die Chance zu nutzen weißt."
   FC_24 = "Kraanan hilft denen, die sich selber helfen."
   FC_25 = "Ein Narr und seine Schillinge werden schnell voneinander getrennt."
   FC_26 = "Viele Menschen stolpern von Zeit zu Zeit über die Wahrheit, aber die meisten stehen einfach wieder auf und gehen weiter, als ob nichts geschehen wäre."


   FC_27 = "Jemand erwartet Dich in Ukgot."
   FC_28 = "Das Glück wird bei Deinem nächsten Turnierkampf auf Deiner Seite sein."
   FC_29 = "Du wirst heute in Deiner Gilde eine wichtige Rolle spielen."
   FC_30 = "Der Ruhm wird Dein sein in der Arena."
   FC_31 = "Du könntest ein Krieger sein."
   FC_32 = "Die meisten schlechten Menschen werden einfach mißverstanden, findest Du nicht?"
   FC_33 = "Das Leben ist kurz, aber ein guter Name bleibt ewig bestehen."
   FC_34 = "Du bist ausersehen, Großes zu vollbringen."
   FC_35 = "Vertrauenswürdige Freunde sind das höchste Gut des Abenteurers."
   FC_36 = "Meidei hat einen besonderen Auftrag für Dich."
   FC_37 = "Berate Dich mit einem Freund, bevor Du Deinen Plan in Angriff nimmst."
   FC_38 = "Plötzlich weißt Du, dass Alamir heute seinen 2563. Todestag haben könnte!"
   FC_39 = "Jetzt ist die Zeit zu handeln."
   FC_40 = "Tote erzählen keine Geschichten - zumindest keine sehr kurzweiligen!"
   FC_41 = "Glaube nicht alles, was Du in diesen Glückskeksen liest."

   %% By Greenwich/Ed Halley
   FC_110 = "Die Zahl 13 hat heute einen unschätzbaren Wert."
   FC_111 = "Denke immer daran: Guide Hagen könnte in Deiner Nähe sein!"
   FC_112 = "Bald wirst Du eine Schlüsselrolle in einer Intrige spielen."
   FC_113 = "Viele Wege führen dem Guten zu. Die Wege sind da, gehen musst du."
   FC_114 = "Du hast das Gefühl, dass Du bestimmt wieder einmal in Guidine Detentes Augen blicken kannst."
   FC_115 = "Behalte heute Deine Ausdauer genau im Auge; sie wird sich als wichtig erweisen."
   FC_116 = "Nicht jeder Pilz ist von Wert. Genauso verhält es sich mit den Menschen, die Du 'Freund' nennst."
   FC_117 = "Bevor Sonne und Mond auf einer Linie stehen, wirst Du in etwas Einträgliches stürzen."
   FC_118 = "Eine Nachrichtenkugel ist ein übler Weg, um ein Gerücht zu verbreiten."
   FC_119 = "Warte nicht, bis Deine Freunde Deine Haut retten; sei jedoch stets bereit, ihre zu retten."
   FC_120 = "Wenn Du die Kraft suchst, von der Du weißt, dass Du sie bereits besitzt, ist das töricht. Setze die Kraft ein."
   FC_121 = "Schmiede ein Bündnis, bevor es zu spät ist."
   FC_122 = "Hüte Dich vor denjenigen, die sich versammeln und dennoch nicht offen sprechen."
   FC_123 = "Du hörst die verhallende Stimme Dallains: Ich morde, betrüge, hintergehe und streite alles ab ... Denn auf dieser Welt bin ICH Gott!"
   FC_124 = "Viele Menschen versäumen das kleine Glück, weil sie auf das große vergeblich warten."
   FC_125 = "Du musst bei Deinen Unternehmungen fest entschlossen sein, sowohl in finanzieller als auch in physischer Hinsicht."
   FC_126 = "... und die Augen des Tieres werden rot sein, rot vom Blute lebender Kreaturen..."
   FC_127 = "Wenn der Hahn kräht auf dem Mist, bleibt das Wetter, wie es ist."
   FC_128 = "In den Beratungen des königlichen Hofs wirst Du eine Schlüsselrolle spielen."
   FC_129 = "Du meinst kurz die durchscheinende Silhouette Gott Merrits zu sehen, der Dir aufmunternd zuzwinkert!"
   FC_130 = "Kraanans Faust ist hart wie Stein. Deine Entschlossenheit kann es fast mit ihr aufnehmen."
   FC_131 = "Du beschließt, dem gefallenen Guide Bone ein Opfer zu bringen, um seiner Seele Frieden zu schenken!"
   FC_132 = "Die Anhänger des Herzogs gewinnen an Macht. Du hältst den Schlüssel für sein Schicksal."
   FC_133 = "Das Blut des Chaos wird vom Himmel regnen."
   FC_134 = "Sei stolz auf das, was Du erreicht hast."
   FC_135 = "Du wirst einst so geachtet sein wie Konima."
   FC_136 = "Die Legenden von Jasper bedeuten viel für Dein Schicksal."
   FC_137 = "Wer sich auf seinen Lorbeeren ausruht, trägt sie an der falschen Stelle."
   FC_138 = "Das Seltsamste an der Gegenwart mag der Umstand sein, dass man sie dereinst die gute alte Zeit nennen wird!"
   FC_139 = "Deine Ziele sind zum Greifen nahe. Spute Dich!"
   FC_140 = "Blut für die Erde, Seelen für Qor!"
   FC_141 = "Denke immer daran: Unsterbliche haben auch nur zehn Finger!"
   FC_142 = "Bevor Du Dich heute zur Ruhe legst, solltest Du ein Vermögen finden."
   FC_143 = "Die Sternenkonstellation verheißt nur Gutes für Meridian."
   FC_144 = "Deine eigenen Freunde werden bald Deine Kräfte herausfordern."
   FC_145 = "Götter sind auch nur Unsterbliche, aber Baar ist mehr als ein harter Brocken."
   FC_146 = "Unsterbliche verbleichen nicht auf natürliche Art und Weise, aber das sollte Dich nicht zurückhalten."
   FC_147 = "Die Grenzen der Welt sind nicht das Ende des Universums."
   FC_148 = "Nicht immer ist der Entdecker eines neuen Landes auch derjenige, der davon als erster profitiert."
   FC_149 = "Sei vorsichtig bei dem, was du vom Boden aufhebst. Es könnte dir zum Verhängnis werden!"
   FC_150 = "Manche sagen, dass das Wissen von Riija für alle Zeiten verloren ist. Das sollte Dich nicht zurückhalten."
   FC_151 = "Suche das rote Juwel von Froz, denn in seiner Magie liegt der Schlüssel zu den kraftvollsten Zaubersprüchen."
   FC_152 = "Der Rat spricht über dich."


   %% By Zavant/Kevin O'Hara
   FC_153 = "In Jasper wirst Du einen neuen Gefährten finden."
   FC_154 = "Eine böse Macht wird in die Welt eindringen."
   FC_155 = "Eine finstere Tat steht dem Königlichen Hof bevor."
   FC_156 = "Es wird Dich in Wassernähe ein Unglück überkommen."
   FC_157 = "Du wirst an einem dunklen Ort großes Glück finden."
   FC_158 = "Ich bestehe aus 100 Prozent chlorfrei gebleichtem Pergamentpapier."
   FC_159 = "Du zögerst nie, gefährliche Gegner zu bekämpfen."
   FC_160 = "Gib Acht, wenn Du durch die Schatten wanderst, denn sie mögen lebendiger sein als Dir lieb ist!"
   FC_161 = "Wenn es ums Essen geht, bist du großzügig."
   FC_162 = "Der Geist des Königs Zarcos II schaut Dir zu."
   FC_163 = "Ein guter Zeitpunkt, um Gildenmeister zu werden."
   FC_164 = "Gildenhallen wollen erobert werden. An die Waffen."
   FC_165 = "Die Universität erlangt neue Macht. Lerne, soviel Du kannst."
   FC_166 = "Anerkennung für Deine Taten wird bald folgen."
   FC_167 = "Überdenke Dein Problem, eine neue Lösung wird gebraucht."
   FC_168 = "Gratuliere, wenn du so weiter machst, paßt dir morgen die Robe nicht mehr."
   FC_169 = "Ein Besuch im alten Schloß könnte sich als lohnend erweisen, falls du überlebst."

   %% By Users in Fortune Cookie Contest
   FC_170 = "So kämm' Dir Dein Haar, putz Dir die Nase und ziehe eine Hose an ... Es heißt Medea sei im Lande!"
   FC_171 = "Beiß mich! Ich bin ein Keks!"
   FC_172 = "Sha-Lill paßt auf Dich auf - aber tut sie es auch gründlich genug?"
   FC_173 = "Sei Dir Deiner Wege bewußt, denn Elendils Augen und Ohren sind überall!"
   FC_174 = "Wenn Faren lächelt, wird Hitze beschworen."
   FC_175 = "Der Friedhof ist voll belegt - aber ein oder zwei Plätzchen finden sich immer! Also frisch ans Werk!"
   FC_176 = "Wein, Weib und Gesang - Herz, was willst Du mehr!"
   FC_177 = "Denke bevor du handelst, denn das Handeln könnte Dein Denken beeinflussen!"
   FC_178 = "Ihr werdet mit der Kraft der Faust die bösen Mächte aus dem Land vertreiben."
   FC_179 = "Du wirst das Gesetz aufrecht erhalten gegen die Gesetzlosen, denen die Unschuldigen zum Opfer fallen."
   FC_180 = "Qor mag das Böse bezwingen, aber Du beherrschst das Gute."
   FC_181 = "Was Du suchst, könnte direkt vor Deiner Nase liegen."
   FC_182 = "Kraanan der Mächtige wird Dich heute vor hinterhältigen Angriffen seitens Qor schützen."
   FC_183 = "Jene, die Magie studieren, müssen wachsam sein, dass die Magie nicht anfängt, sie zu studieren."
   FC_184 = "Die ganz Starken werden schwach und die Welt schaut vergnügt zu."
   FC_185 = "In Wirklichkeit ist die Realität ganz anders!"
   FC_186 = "Wenn sonst nichts mehr hilft... lauf!"
   FC_187 = "Zukunft? Du? Ha ha ha - Das glaubst du doch nicht wirklich, oder?"
   FC_188 = "Du solltest Deinen Verbrauch an Glückskeksen einschränken!"
   FC_189 = "Du darfst bei einem Unwetter niemals nach oben schauen. Du weißt nicht wirklich, wer gerade verrückt spielt."
   FC_190 = "Zeig immer Respekt vor den Älteren; sie schlagen ziemlich heftig zu."
   FC_191 = "Denk immer daran, schau dem geschenkten Gaul nicht ins Maul, er beißt."
   FC_192 = "Am Ende wird die Klinge auch den geübtesten Magier niederstrecken, wenn ihr nur genug Zeit gelassen wird."
   FC_193 = "Gebet acht, wem Ihr Zutritt zur Gilde gewährt, denn das große Los, hinter dem alle her sind, ist die verlockende Halle und ihre Schätze."
   FC_194 = "Wenn es dein Ziel ist, ein Jäger zu sein, dann muss du lernen, in der trostlosen Einsamkeit an Deinen Fähigkeiten zu feilen."
   FC_195 = "Die Prinzessin ist gut und gerecht, aber ihre Lehren werden einem Krieger auf dem Schlachtfeld keine Siege bringen."
   FC_196 = "Du hast mehr Freunde, als Du weißt, und mehr Feinde, als Du Dir vorstellen kannst."
   FC_197 = "Du sollst nicht mit vollem Mund sprechen! Was würde Deine Mutter sagen!"
   FC_198 = "Du wirst schon bald den eisigen Hauch des Todes spüren und die Hitze des Höllenfeuers der Unterwelt."
   FC_199 = "Um die Zauberquelle im Tal der Trauer zu bekommen, braucht es viele Abenteurer."
   FC_200 = "Riija war hier."
   FC_201 = "Hilfe! Ich werde in einer Meridianischen Glückskeksbäckerei gefangengehalten!"
   FC_202 = "Vergib Deinen Feinden, aber vergiß ihre Namen nie."
   FC_203 = "Es tut nichts zur Sache, ob du gewinnst oder verlierst, wichtig ist, dass Du überlebst."
   FC_204 = "Vergiß Sha-Lills Schirm nicht am großen Ozean."
   FC_205 = "Übermäßiger Genuß von Glückskeksen kann eine abführende Wirkung hervorrufen!"

   %% By Regifan Du Bukise/Kevin O'Hara 
   FC_206 = "Deine Bestimmung bringt Dir heute viel Erfolg."
   FC_207 = "Das Geheimnis, gute Freunde zu haben, ist für Dich kein Geheimnis."
   FC_208 = "Du besitzt die seltene Fähigkeit, schnell und weise zu entscheiden."
   FC_209 = "Ein Held, ist nur derjenige der mit seinem Ruhm und seinen Fähigkeiten nicht angeben muß."
   FC_210 = "Jener, der niemals Dankbarkeit erwartet, wird auch niemals enttäuscht."
   FC_211 = "Du bist zu größeren Dingen fähig, als Du Dir vorstellen kannst."
   FC_212 = "Überlasse niemals einem Schrumpfkopf das Sprechen."
   FC_213 = "Sei aufmerksam für neue Gelegenheiten."
   FC_214 = "Alles wird gut gehen bei Deiner neuen Aufgabe."
   FC_215 = "Deine Fröhlichkeit hängt stark mit Deiner Lebenseinstellung zusammen."
   FC_216 = "Hilfe, ich werde IMMER NOCH in der Glückskeksbäckerei gefangen gehalten!!!"
   FC_217 = "Gerade ist die richtige Mondphase, um Täuschungen zu erzeugen."
   FC_218 = "Du bist niemals alleine, Detente wird an Deiner Seite sein."
   FC_219 = "Du wirst bei der nächsten Justiziar-Wahl eine entscheidende Rolle spielen."
   FC_220 = "Schaff' Dein Geld auf den Spieltisch, du wirst es brauchen."
   FC_221 = "Dir wird bald das Wohlwollen eines Barden zuteil."
   FC_222 = "Das wahre Glück liegt nicht in diesem Keks, Du musst es schon woanders suchen."
   FC_223 = "Jener, der neue Freunde trifft, wird sich nie langweilen."
   FC_224 = "Jala ist nicht tot."
   FC_225 = "Du solltest Frular aufsuchen und deine Gildenbeiträge entrichten... DIES ist die LETZTE Mahnung."

   %% By Psychochild/Brian Green
   FC_226 = "Auch totgeglaubte Dinge können manchmal zurückkehren, wenn wir es nur stark genug wollen."
   FC_227 = "Willkommen daheim."
   FC_228 = "Wenn Dir ein sprechender Troll begnet, nimm Dich in acht!"
   FC_229 = "Zeige Respekt vor denen, die diese Welt formen, und Du wirst selbst Respekt zurück erhalten."
   FC_230 = "Wenn sich jemand Zeit nimmt, um Dir zuzuhören, heißt das nicht, dass er schwerhörig ist."
   FC_231 = "Erwecke nicht den Zorn der Götter. Ihre Strafen können verheerend sein."
   FC_232 = "Dein Glück im Leben wird von beiden beeinflusst, von Freunden und Feinden."
   FC_233 = "Achte auf den nächsten Ring, den Du aufnimmst. Er könnte anders sein als Du es erwartest."
   FC_234 = "Zerstöre nie den Spaß und die Freude der anderen, denn damit schadest Du nur Dir selbst."
   FC_235 = "Lerne von den Kindern. Es ist genauso wichtig, sich Zeit zum Spielen zu nehmen wie zum Arbeiten."

   LM_haz_rand1 = "Wenn Du noch nie vorher in Meridian warst, findest Du es vielleicht hilfreich, zu lesen, was auf den Schildern steht."
   LM_haz_rand2 = "In Meridian gibt es mehr als 60 Zaubersprüche in fünf verschiedenen Zauberschulen! Trotzdem werden die Zauberkünste kaum mehr weiterentwickelt."
   LM_haz_rand3 = "Die Krypta ist voll von Mumien! Die Frage, wie solch ein heiliger Ort so herunterkommen konnte, wird wahrscheinlich nie beantwortet werden."
%   LM_haz_rand4 = "What's 10 bucks a month?  That's less than the cost of a movie, popcorn and drink!"
   LM_haz_rand5 = "Was Du hier siehst, ist nur ein Bruchteil von Meridian 59. Vielleicht hast Du Lust, auch den Rest des Landes zu erforschen?"
   LM_haz_rand6 = "Ich habe gehört, dass die Auseinandersetzungen zwischen der Prinzessin und dem Herzog immer noch andauern. Glücklicherweise hat das auf uns hier an der Grenze nur wenig Auswirkungen."
   LM_haz_rand7 = "Ich kann Dir nur raten, Freunde und Verbündete zu suchen."
   LM_haz_rand8 = "Einige Abenteurer sind blutrünstige Mörder! Glücklicherweise schützen die Zauber von Sha-Lill unsere Stadt vor solchen Unholden."
   LM_haz_rand9 = "Manchmal wünschte ich, ich würde irgendwo draußen Abenteuer erleben! Aber mein Platz ist hier."
   LM_haz_rand10 = "Sha-Lill liebt die Jungen und die Törichten. Dein Schutzengel behütet Dich für eine gewisse Zeit."
   LM_haz_rand11 = "Der Tod ist ein Unglück. Vermeide ihn."
   LM_haz_rand12 = "Gerüchte besagen, dass Barloque sich zu einem Nest von Attentätern entwickelt hat! Glücklicherweise sind wir weit von diesem Ort entfernt."
   LM_haz_rand13 = "Im fernen Tos gibt es anscheinend eine große Arena, in der mächtige Krieger zeigen können, wer der tapferste Recke ist!"
   LM_haz_rand14 = "Sogar jetzt führen die Fey Elhai und die Fey Dirhai Krieg um das Tal der Trauer."
   LM_haz_rand15 = "Ein mächtiger Krieger kann Magie abweisen, indem er seine Fertigkeiten ausbaut. Leider gibt es in dieser Gegend keine guten Lehrer."
   LM_haz_rand16 = "Falls Du ein Monster tötest, solltest Du seine Hinterlassenschaften an Dich nehmen. Du kannst sie oft für gutes Geld verkaufen."
   LM_haz_rand17 = "Mache auf Deinen Reisen reichlich Gebrauch von der Landkarte. Tippe KARTE ein, um sie aufzurufen."
   
   LM_haz_rand_apoth1 = "Ravin, der Alchemist, ist immer auf der Suche nach Kräutern und Pilzen. Wenn Du welche findest, wird er Dir viel Geld dafür bezahlen."
   LM_haz_rand_bar1 = "Falls Du müde oder verwundet bist, ist Eriks Taverne ein guter Ort, um neue Kräfte zu schöpfen."
   LM_haz_rand_inn1 = "Achte darauf, wirklich alle Schilder durchzulesen. Falls Du vom Weg abgekommen bist: Das Zeichen an der Kneipe im Norden der Stadt ist das erste."
   LM_haz_rand_elder1 = "Frage auch den Weisen um Rat. Er suchte erst kürzlich mutige Krieger, die ihm beim Abwehren der Mumien zur Seite stehen!"
   LM_haz_rand_smith1 = "Der Schmied im Nordwesten der Stadt bietet vorzügliche Waffen für ambitionierte Abenteurer."

   lib_signet_lost = "Du klopfst Deine Taschen ab und wühlst in Deinem Rucksack. Doch vergebens: Der Siegelring ist verschwunden!"

classvars:


properties:

   plFortunes = $
   plCommonFortunes = $

   piSignetChance = 3
   piSignetLock = False
   piMaxSignetNewbies = 20
   piMaxSignets = 20
   plSignetNewbies = $
   plSignetRings = $

   prMonster_advice = $
   prKarma_advice = $
   prGroup_advice = $
   piGenTimerLength =  300000  %every 5 minutes chance of new quest.

   piNextQuestID = QST_START_NUM

   % for the speech triggers and random actions
   plRandomLib = $
   plSpeechLib = $
   plMobLib = $

   % list of npcs by profession
   plOccupations = $

   % a list of all NPCs.
   plNPCs = $

   % for the (old) quest engine
   plQuests = $         %large database of all the current quests (DISABLED -- AJM)
   plQuestUsers = $     %large database of everyones quest status.(DISABLED -- AJM)

   plQuesterList = $
   plOnQuestList = $
   plHinterList = $    
   plQuestDictionary = $
   plQuestOfferClasses = $
   plQuestOfferObjects = $
   plQuestRewards = $
   plOldQuestPhrases = $
   plOldQuestClasses = $

   ptQuestGenTimer = $   %   (DISABLED -- AJM)
   
   % for the extended speech and random libs   -AJM
   piLastSpeechKey = 0
   pcLastSpeechClass = $
   piLastSpeechTriggerNum = 0
   piLastRandomKey = 0
   pcLastRandomClass = $
   plScratchString = $
   
messages:

   Constructor()
   {
      Send(self,@Recreate,#initial=True);
      return;
   }

   ReInitialize()
   "This routine strips the library and yet keeps the quester and hinter"
   "lists. This means that you dont have to recreate the mobs to fix any"
   "nasty bugs that happened. It also finds any mobs who are condsellers"
   "and resets them so their triggers stay in the mob lib. It also puts"
   "the quests of permquesters back into the scheme of things. It does"
   "keep the old phrase and class lists so that possibly there will be"
   "some continuity kept for the players who are just a bit slow."
   {
      local lQuesters,LPermQs,lSellers,i,j,repeat;
      
      lSellers = $;
      lQuesters = $;
      lPermQs = $;
      plScratchString = [ CreateString() ];               % -AJM
      SetString( First( plScratchString ), append_string );

      %Figure out who our condsellers are...
      for i in plMobLib
      {
         repeat = FALSE;
         for j in lSellers
         {
            if i = j
            {
               repeat = TRUE;
            }
         }
         
         if NOT repeat AND Send(i,@MobIsCondSeller)
         {
            lSellers = Cons(i,lSellers);
         }
      }

      %Reset the quester list to be just the raw ones.
      For i in plOnQuestList { plQuesterList=Cons(i,plQuesterList); }
      plOnQuestList = $;
      plMobLib = $;
      plQuests = $;  %(DISABLED -- AJM)
      piNextQuestID= QST_START_NUM;

      %Get our perma questers...
      For i in plQuesterList
      {
        if Send(i,@MobIsPermQuester) {lPermQs=Cons(i,lPermQs);}
      }

      for i in plQuestOfferObjects
      {
         plQuestOfferObjects = DelListElem(plQuestOfferObjects,i);
         Send(i,@Delete);
      }
      plQuestOfferObjects = $;

      %Reset all the lists of things in case something changed...
      Send(self,@CreateRandomLibrary);
      Send(self,@CreateSpeechLibrary);
      Send(self,@CreateFortuneLibrary);
      Send(self,@CreateQuestDictionary);
      Send(self,@CreateQuestOfferClasses);
      Send(self,@CreateQuestRewards);

      %Add in the cond sellers to the mob lib, and permquesters too.
      For i in lSellers { Send(i,@InitCondSale); }
      For i in lPermQs { Send(i,@InitPermQuest); }

      return;
   }

   Recreate(initial=False)
   "Basically this does everything to recreate the library except clear"
   "the plQuestUser list that keeps track of which players have done"
   "which permaquests. If the permaquest id's change, this will be messed"
   "up then..."
   {
      local i;

      if not initial
      {
         %We need to clear stuff out
         plOccupations = $;
         plNPCs = $;
         plMobLib = $;
         plSpeechLib = $;
         plQuests = $;   % (DISABLED -- AJM)
         plHinterList = $;
         plQuesterList = $;
         plOnQuestList = $;
         plOldQuestPhrases = $;
         plOldQuestClasses = $;
         
         for i in plQuestOfferObjects
         {
            plQuestOfferObjects = DelListElem(plQuestOfferObjects,i);
            Send(i,@Delete);
         }
         
         plQuestOfferObjects = $;
         piNextQuestID = QST_START_NUM;
         ptQuestGenTimer=$;
      }
      
      plScratchString = [ CreateString() ];      % -AJM used for NPC dialogue
      SetString( First( plScratchString ), append_string );

      Send(self,@CreateRandomLibrary);
      Send(self,@CreateSpeechLibrary);
      Send(self,@CreateFortuneLibrary);
      Send(self,@CreateQuestDictionary);
      Send(self,@CreateQuestOfferClasses);
      Send(self,@CreateQuestRewards);

      return;
   }

   Delete()
   "Dereferences the three main library lists (yeah garbage collection)"
   "Since the moblib should be used mainly for random quests, this will"
   "cause some mucky problems, unless we clear the quests as well."
   "basically, you shouldnt be deleting this object"
   {
      local i;
      
      plOccupations = $;
      plNPCs = $;
      plRandomLib = $;
      plQuestUsers = $;   %  (DISABLED -- AJM)
      plSpeechLib = $;
      plMobLib = $;
      plQuests = $;  %  (DISABLED -- AJM)
      plHinterList = $;
      plQuesterList = $;
      plOnQuestList = $;
      plQuestDictionary = $;
      plQuestOfferClasses = $;
      plQuestRewards = $;
      plFortunes = $;
      plCommonFortunes = $;

      for i in plQuestOfferObjects
      {
         plQuestOfferObjects = DelListElem(plQuestOfferObjects,i);
         Send(i,@Delete);
      }
      plQuestOfferObjects = $;
      DeleteTimer(ptQuestGenTimer);
      ptQuestGenTimer=$;
      
      return;
   }

   % These are functions for tracking the list of NPCs.

   AddNPC(who = $)
   {
      if plNPCs = $ OR FindListElem(plNPCs,who) = 0
      {
         plNPCs = cons(who,plNPCs);
      }
      
      return;
   }

   RemoveNPC(who = $)
   {
      if plNPCs <> $ AND FindListElem(plNPCs,who) <> 0
      {
         plNPCs = DelListElem(plNPCs,who);
      }
      
      return;
   }

   GetNPCs()
   {
      return plNPCs;
   }

   %% AddToOccupationList()
   %  OccupationList is a list of 2-element lists
   %  first elem is NPC occupation, eg MOB_ROLE_BANKER
   %  next elem is list of NPCs with that job
   %  This method called by monster constructor
   %  NPCs with no occupation are not added to list
   %%
   AddToOccupationList( who = $ )
   {
      local iOccupation, lOccBranch, oNPC;
      
      if who = $ 
      {
         return;
      }
      
      iOccupation = send(who,@GetOccupation);
      
      if iOccupation = 0 
      {
         return;
      }
      
      if plOccupations = $ 
      {
         plOccupations = [ [ iOccupation, [ who ] ] ];
         return;
      }
      
      for lOccBranch in plOccupations
      {
         if first(lOccBranch) = iOccupation
         {
            % make sure npc isn't already in list (shouldn't be)
            for oNPC in Nth(lOccBranch,2)
            {
               if oNPC = who 
               {
                  return;
               }
            }

            % add him
            SetNth(lOccBranch,2,cons(who,Nth(lOccBranch,2)));
            
            return;
         }
      }
      
      % new occupation
      plOccupations = cons( [ iOccupation, [ who ] ], plOccupations );
      return;
   }
   
   %% DeleteFromOccupationList()
   %   OccupationList is a list of 2-element lists
   %   first elem is NPC occupation, eg MOB_ROLE_BANKER
   %   next elem is list of NPCs with that job
   %   This method called by monster Delete
   %%
   DeleteFromOccupationList( who = $ )
   {
      local iOccupation, lOccBranch, oNPC;
      
      if who = $
      {
         return;
      }
      
      iOccupation = send(who,@GetOccupation);
      
      if iOccupation = 0
      {
         return;
      }
      
      if plOccupations = $
      {
         return;
      }
      
      for lOccBranch in plOccupations
      {
         if first(lOccBranch) = iOccupation
         {
            for oNPC in Nth(lOccBranch,2)
            {
               if oNPC = who
               {
                  % remove him
                  SetNth(lOccBranch,2,DelListElem(Nth(lOccBranch,2),who));
                  if Length(Nth(lOccBranch,2)) < 1
                  {
                     % no more with this occupation
                     plOccupations = DelListElem(plOccupations,lOccBranch);
                  }
                  
                  return;
               }
            }
            
            % not in his occupation branch
            return;
         }
      }
      
      % occupation not in list
      return;
   }

   %% GetOccupationList()
   %   OccupationList is a list of 2-element lists
   %   first elem is NPC occupation, eg MOB_ROLE_BANKER
   %   next elem is list of NPCs with that job
   %   This method returns a list of NPCs whose job matches
   %    If cNPC_class filter is defined, return only NPCs who match
   %    If iJob is 0, searches all jobs
   %   onIsland filters by continent (true means island-only, false means mainland-only, $ means either)
   %%
   GetOccupationList( iJob = 0, cNPC_class = $, onIsland = $ )
   {
      local lOccBranch, j, lMatches;

      lMatches = $;
      
      % no iJob or cNPC_class specified
      if iJob = 0 
      {
         if cNPC_class = $ 
         {
            return $;
         }
      }

      % single job type specified, with filter
      for lOccBranch in plOccupations
      {
         if ( iJob = 0 ) or ( iJob = first(lOccBranch) )
         {
            for j in Nth( lOccBranch, 2 )
            {
               if ( cNPC_class = $ ) or ( IsClass(j, cNPC_class) )
               {
                  if ( onIsland = $ ) or
                           ( onIsland = (isclass(j,&KocatanTown) or isClass(j,&RiijaMonk)) )
                  {
                     lMatches = cons( j, lMatches );
                  }
               }
            }
         }
      }
      return lMatches;
   }

   CreateRandomLibrary()
   "Basically, any library entry desired is just added in "
   "at an appropriate place. The library is a list of two-element nodes. "
   "Each node is a classname and a list of entries. Each entry consists "
   "of three elements: Percentage, Restriction Vector, List of the Action "
   "type and its parameters. The percentage is from 0 to 100, and for the "
   "action to be triggered, the incoming percentage must be greater or "
   "equal to the library percentage (so 0 is never, 100 is always, etc)"
   { 
     plRandomLib = $;

%     plRandomLib = Cons(
%     [&towns,[
%       [25,LIBRES_NOT_NEWBIE,[ LIBACT_RUMOR_COURT_STATE ,0]],
%     ]],plRandomLib);

   plRandomLib = Cons(
      [&CorNothTown,[
       [40,LIBRES_NOT_NEWBIE,[ LIBACT_RUMOR_TOKEN_LOC ]] 
      ]],plRandomLib);

   plRandomLib = Cons(
      [&HazarTown,[
    [48,0,[ LIBACT_SAY, LM_haz_rand17 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand16 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand15 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand14 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand13 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand12 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand11 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand10 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand9 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand8 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand7 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand6 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand5 ]],
%    [48,0,[ LIBACT_SAY, LM_haz_rand4 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand3 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand2 ]],
    [48,0,[ LIBACT_SAY, LM_haz_rand1 ]]
      ]],plRandomLib);

    plRandomLib = Cons(
    [&HazarBartender,[
       [48,0,[ LIBACT_SAY, LM_haz_rand_apoth1 ]],
         [48,0,[ LIBACT_SAY, LM_haz_rand_inn1 ]],
       [48,0,[ LIBACT_SAY, LM_haz_rand_smith1 ]],       
       [48,0,[ LIBACT_SAY, LM_haz_rand_elder1 ]]
   ]],plRandomLib);
   
   plRandomLib = Cons(
    [&HazarInnkeeper,[
       [48,0,[ LIBACT_SAY, LM_haz_rand_apoth1 ]],
         [48,0,[ LIBACT_SAY, LM_haz_rand_bar1 ]],
       [48,0,[ LIBACT_SAY, LM_haz_rand_smith1 ]],       
       [48,0,[ LIBACT_SAY, LM_haz_rand_elder1 ]]
   ]],plRandomLib);
   
   plRandomLib = Cons(
    [&HazarBlacksmith,[
       [48,0,[ LIBACT_SAY, LM_haz_rand_apoth1 ]],
         [48,0,[ LIBACT_SAY, LM_haz_rand_inn1 ]],
       [48,0,[ LIBACT_SAY, LM_haz_rand_bar1 ]],       
       [48,0,[ LIBACT_SAY, LM_haz_rand_elder1 ]]
   ]],plRandomLib);
   
   plRandomLib = Cons(
    [&HazarElder,[
       [48,0,[ LIBACT_SAY, LM_haz_rand_apoth1 ]],
         [48,0,[ LIBACT_SAY, LM_haz_rand_inn1 ]],
       [48,0,[ LIBACT_SAY, LM_haz_rand_smith1 ]],       
       [48,0,[ LIBACT_SAY, LM_haz_rand_bar1 ]]
   ]],plRandomLib);
   
   plRandomLib = Cons(
    [&HazarApothecary,[
       [48,0,[ LIBACT_SAY, LM_haz_rand_bar1 ]],
         [48,0,[ LIBACT_SAY, LM_haz_rand_inn1 ]],
       [48,0,[ LIBACT_SAY, LM_haz_rand_smith1 ]],       
       [48,0,[ LIBACT_SAY, LM_haz_rand_elder1 ]]
   ]],plRandomLib);

   return; }

   CreateSpeechLibrary()
   "Basically, any library entry desired is just added in"
   "at an appropriate place. The library is a list of two-element nodes."
   "Each node is a classname and a list of entries. Each entry consists"
   "of three elements: List of Triggers, Restriction Vector, List of the"
   "Action Type and its parameters."
   {
      local lDontInclude, oMonster, lMonsters, lTempList, lAddList;
     plSpeechLib = $;
%     plSpeechLib = Cons(
%     [&monster,[
%       [[LT_hi,LT_hello,LT_howdy],0, [LIBACT_SAY_TARG, LM_mons_hey1]],
%       [[LT_hi,LT_hello,LT_howdy],0, [LIBACT_SAY, LM_mons_hey2 ]],
%       [[LT_hi,LT_hello,LT_howdy],0, [LIBACT_SAY, LM_mons_hey3 ]],
%       [[LT_hi,LT_hello,LT_howdy],0, [LIBACT_SAY, LM_mons_hey4 ]],
%       [[LT_bye,LT_farewell],0, [LIBACT_SAY, LM_mons_bye1 ]],
%       [[LT_bye,LT_farewell],0, [LIBACT_SAY, LM_mons_bye2 ]],
%       [[LT_bye,LT_farewell],0, [LIBACT_SAY, LM_mons_bye3 ]],
%       [[LT_bye,LT_farewell],0, [LIBACT_SAY, LM_mons_bye4 ]]
%     ]],plSpeechLib);

     plSpeechLib = Cons(
    [&hazartown,[
      [[LT_akardius,LT_duke,LT_princess,LT_kateriina],0,[LIBACT_SAY,LM_haz_factions]],
      [[LT_cor,LT_jasper,LT_marion,LT_barloque,LT_tos],0,[LIBACT_SAY,LM_haz_towns]],
        [[LT_help],0,[LIBACT_SAY,LM_haz_help]],
       [[LT_meridian],0,[LIBACT_SAY,LM_haz_meridian]]
     ]],plSpeechLib);

     plSpeechLib = Cons(
    [&hazarInnkeeper,[
        [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]],
      [[LT_buy],0,[LIBACT_SAY,LM_haz_innk_buy]],
      [[LT_sell],0,[LIBACT_SAY,LM_haz_innk_sell]],
      [[LT_entroot],0,[LIBACT_SAY,LM_haz_entroot_none]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarBartender,[
      [[LT_buy],0,[LIBACT_SAY,LM_haz_bar_buy]],
      [[LT_sell],0,[LIBACT_SAY,LM_haz_bar_sell]],
       [[LT_entroot],0,[LIBACT_SAY,LM_haz_entroot_none]],
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarElder,[
       [[LT_buy],0,[LIBACT_SAY,LM_haz_elder_buy]],
      [[LT_sell],0,[LIBACT_SAY,LM_haz_elder_sell]],
       [[LT_entroot],0,[LIBACT_SAY,LM_haz_entroot_none]],
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest_elder]],
      [[LT_mausoleum],0,[LIBACT_SAY,LM_haz_mausoleum]],
      [[LT_mummy,LT_mummies],0,[LIBACT_SAY,LM_haz_mummy]],
        [[LT_eric],0,[LIBACT_SAY,LM_haz_eric]],      
       [[LT_ravi],0,[LIBACT_SAY,LM_haz_ravi]],
       [[LT_marcus],0,[LIBACT_SAY,LM_haz_marcus]],      
       [[LT_tomas],0,[LIBACT_SAY,LM_haz_tomas]]      
    ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarApothecary,[
       [[LT_buy],0,[LIBACT_SAY,LM_haz_apoth_buy]],
      [[LT_sell],0,[LIBACT_SAY,LM_haz_apoth_sell]],
       [[LT_entroot],0,[LIBACT_SAY,LM_haz_entroot_response]],
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]],
      [[LT_rodric],0,[LIBACT_SAY,LM_haz_rodric]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarBlacksmith,[
       [[LT_quest],0,[LIBACT_SAY,LM_haz_quest_entroot]],
      [[LT_buy],0,[LIBACT_SAY,LM_haz_smith_buy]],
      [[LT_sell],0,[LIBACT_SAY,LM_haz_smith_sell]],
       [[LT_entroot],0,[LIBACT_SAY,LM_haz_entroot_none]],      
      [[LT_rodric],0,[LIBACT_SAY,LM_haz_rodric]]   
     ]],plSpeechLib);


     plSpeechLib = Cons(
     [&towns,[
%       [[LT_akardius,LT_duke],LIBRES_NOT_NEWBIE, [ LIBACT_SAY, LM_duke_response]],
%       [[LT_kateriina,LT_princess],LIBRES_NOT_NEWBIE, [ LIBACT_SAY, LM_princess_response]],
%       [[LT_token],LIBRES_NOT_NEWBIE, [ LIBACT_SAY, LM_token_response]],
%       [[LT_council],LIBRES_NOT_NEWBIE, [ LIBACT_SAY, LM_council_response]],
%       [[LT_court],LIBRES_NOT_NEWBIE, [ LIBACT_RUMOR_COURT_STATE ,0]]
     ]],plSpeechLib);

     plSpeechLib = Cons(
     [&factions,[
       [[LT_onecon],0,[LIBACT_COUNCILOR_REPORT,1]],
       [[LT_twocon],0,[LIBACT_COUNCILOR_REPORT,2]],
       [[LT_threecon],0,[LIBACT_COUNCILOR_REPORT,3]],
       [[LT_fourcon],0,[LIBACT_COUNCILOR_REPORT,4]],
       [[LT_fivecon],0,[LIBACT_COUNCILOR_REPORT,5]],
       [[LT_members],0,[LIBACT_NUMBER_REPORT]],
       [[LT_token],0,[LIBACT_RUMOR_TOKEN_LOC]]
     ]],plSpeechLib);

   % DirectX
      plSpeechLib = Cons(
     [&FourCouncilor, [
      [[LT_ohm], 0, [LIBACT_MOOD, 1], 1]
     ]],plSpeechLib);

   % Esseldi
      plSpeechLib = Cons(
     [&FiveCouncilor, [
      [[LT_quest], 0, [LIBACT_MOOD, 1], 1]
     ]],plSpeechLib);

      plSpeechLib = Cons(
     [&FiveCouncilor, [
      [[LT_nodes], 0, [LIBACT_MANA_NODE_LIST, 1], 1]
     ]],plSpeechLib);

%Wanderers

   % Jonas
     plSpeechLib = Cons( 
     [&RebelLiege,[
       [[LT_rebel], 0, [LIBACT_MOOD, 2], 1],
       [[LT_rebellion], 0, [LIBACT_MOOD, 1], 2],
       [[LT_duke], 0, [LIBACT_MOOD, -3], 3],
       [[LT_princess], 0, [LIBACT_MOOD, -3], 4],
       [[LT_orc], 0, [LIBACT_MOOD, 2], 5]
     ]], plSpeechLib);

   % Parrin
     plSpeechLib = Cons( 
     [&Minstrel,[
       [[LT_help], 0, [LIBACT_MOOD, 1], 1],
       [[LT_duke], 0, [LIBACT_MOOD, -3], 2],
       [[LT_princess], 0, [LIBACT_MOOD, -3], 3],
       [[LT_freebird], 0, [LIBACT_MOOD, 4], 4]
     ]], plSpeechLib);

%Tos people

   % Skivlat
     plSpeechLib = Cons(
     [&TosBanker,[
       [[LT_shillings], 0, [LIBACT_MOOD, 1], 1]
     ]], plSpeechLib);

   % Frisconar
     plSpeechLib = Cons(
     [&tosapothecary,[
       [[LT_madelia], 0, [LIBACT_MOOD, 1], 1],
       [[LT_paddock], 0, [LIBACT_MOOD, -1], 2]
     ]], plSpeechLib);

   % Paddock
     plSpeechlib = Cons(
     [&tosinnkeeper,[
       [[LT_akardius],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_DUKE]],
       [[LT_kateriina],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_PRINCESS]],
       [[LT_jonas],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_REBEL]],
       [[LT_shutup], 0, [LIBACT_MOOD, -3], 1],
       [[LT_mend], 0, [LIBACT_MOOD, -1], 2],
       [[LT_mending], 0, [LIBACT_MOOD, -1], 3]
     ]], plSpeechLib);

%Kocatan people

   % Kochtal
     plSpeechLib = Cons( 
     [&KocatanWeaponsMaster,[
       [[LT_customs], 0, [LIBACT_MOOD, 5], 1],
       [[LT_blind], 0, [LIBACT_MOOD, -5], 2]
     ]], plSpeechLib);

   % Tepal
     plSpeechLib = Cons( 
     [&KocatanTailor,[
       [[LT_konima], 0, [LIBACT_MOOD, -2], 1],
       [[LT_kocatan], 0, [LIBACT_MOOD, -2], 2],
       [[LT_kocatan2], 0, [LIBACT_MOOD, -2], 3],
       [[LT_wulfgang], 0, [LIBACT_MOOD, 2], 4],
       [[LT_precious], 0, [LIBACT_MOOD, 2], 5],
       [[LT_avar], 0, [LIBACT_MOOD, 1], 6]
     ]], plSpeechLib);

   % Pacal
     plSpeechLib = Cons( 
     [&kocatanShopkeeper,[
       [[LT_sell], 0, [LIBACT_MOOD, 2], 1],
       [[LT_business], 0, [LIBACT_MOOD, 3], 2],
       [[LT_howdy], 0, [LIBACT_MOOD, 1], 3],
       [[LT_hello], 0, [LIBACT_MOOD, 1], 4],
       [[LT_hi], 0, [LIBACT_MOOD, 1], 5],
       [[LT_hiya], 0, [LIBACT_MOOD, 1], 6]
     ]], plSpeechLib);

   % Ixla
     plSpeechLib = Cons( 
     [&KocatanBlacksmith,[
       [[LT_kazot], 0, [LIBACT_MOOD, -3], 1],
       [[LT_zoszin], 0, [LIBACT_MOOD, -2], 2],
       [[LT_konima], 0, [LIBACT_MOOD, -2], 3],
       [[LT_hello], 0, [LIBACT_MOOD, 3], 4],
       [[LT_hi], 0, [LIBACT_MOOD, 3], 5],
       [[LT_hiya], 0, [LIBACT_MOOD, 3], 6],
       [[LT_howdy], 0, [LIBACT_MOOD, 3], 7]
     ]], plSpeechLib);

   % Zala
     plSpeechLib = Cons( 
     [&KocatanApothecary,[
       [[LT_smoke], 0, [LIBACT_MOOD, -1], 1],
       [[LT_bud], 0, [LIBACT_MOOD, -3], 2],
       [[LT_army], 0, [LIBACT_MOOD, -5], 3]
     ]], plSpeechLib);

   % Wulfgang
     plSpeechLib = Cons( 
     [&kocatanTradeMaster,[
       [[LT_marion], 0, [LIBACT_MOOD, -3], 1],
       [[LT_tos], 0, [LIBACT_MOOD, -3], 2],
       [[LT_duke], 0, [LIBACT_MOOD, -2], 3],
       [[LT_princess], 0, [LIBACT_MOOD, -2], 4]
     ]], plSpeechLib);

   % Oxal
     plSpeechLib = Cons( 
     [&KocatanBartender,[
       [[LT_arm], 0, [LIBACT_MOOD, -10], 1],
       [[LT_konima], 0, [LIBACT_MOOD, 2], 2],
       [[LT_balo], 0, [LIBACT_MOOD, -2], 3],
       [[LT_avar], 0, [LIBACT_MOOD, -6], 4],
       [[LT_zala], 0, [LIBACT_MOOD, -2], 5]
     ]], plSpeechLib);

   % Moxal
     plSpeechLib = Cons( 
     [&KocatanInnkeeper,[
       [[LT_cheat], 0, [LIBACT_MOOD, -2], 1],
       [[LT_liar], 0, [LIBACT_MOOD, -2], 2],
       [[LT_scam], 0, [LIBACT_MOOD, -2], 3]
     ]], plSpeechLib);

%Barloque people

   % Herbutte
     plSpeechLib = Cons( 
     [&BarloqueMerchant,[
       [[LT_duke], 0, [LIBACT_MOOD, -2], 1],
       [[LT_tos], 0, [LIBACT_MOOD, -1], 2],
       [[LT_cor], 0, [LIBACT_MOOD, -1], 3],
       [[LT_hazar], 0, [LIBACT_MOOD, -1], 4],
       [[LT_jasper], 0, [LIBACT_MOOD, -1], 5],
       [[LT_kocatan], 0, [LIBACT_MOOD, -1], 6],
       [[LT_kocatan2], 0, [LIBACT_MOOD, -1], 7],
       [[LT_marion], 0, [LIBACT_MOOD, -1], 8]
     ]], plSpeechLib);

   % Meidei
     plSpeechLib = Cons( 
     [&BarloqueBartender,[
       [[LT_shal1], 0, [LIBACT_MOOD, 2], 1],
       [[LT_shal2], 0, [LIBACT_MOOD, 2], 2],
       [[LT_riija], 0, [LIBACT_MOOD, -1], 3],
       [[LT_qor], 0, [LIBACT_MOOD, -3], 4]
     ]], plSpeechLib);

   % Fehr'loi Qan
     plSpeechLib = Cons( 
     [&BarloqueBlacksmith,[
       [[LT_kraanan], 0, [LIBACT_MOOD, 1], 1],
       [[LT_tos], 0, [LIBACT_MOOD, -1], 2]
     ]], plSpeechLib);

     plSpeechLib = Cons(
     [&barloqueapothecary,[
     ]],plSpeechLib);

   % Frular
     plSpeechLib = Cons(
     [&GuildCreator,[
       [[LT_princess], 0, [LIBACT_MOOD, -1], 1],
       [[LT_madelia], 0, [LIBACT_MOOD, 1], 2]
     ]],plSpeechLib);

   % Pritchett
     plSpeechLib = Cons( 
     [&BarloqueInnkeeper,[
       [[LT_sailor], 0, [LIBACT_MOOD, 3], 1],
       [[LT_madelia], 0, [LIBACT_MOOD, 2], 2]
     ]], plSpeechLib);

   % Obert
     plSpeechLib = Cons( 
     [&barloqueVaultman,[
       [[LT_guild], 0, [LIBACT_MOOD, -2], 1],
       [[LT_hello], 0, [LIBACT_MOOD, 1], 2],
       [[LT_hi], 0, [LIBACT_MOOD, 1], 3],
       [[LT_hiya], 0, [LIBACT_MOOD, 1], 4],
       [[LT_howdy], 0, [LIBACT_MOOD, 1], 5]
     ]], plSpeechLib);

   % Madelia
     plSpeechLib = Cons( 
     [&Barloquetailor,[
       [[LT_frisconar], 0, [LIBACT_MOOD, -3], 1],
       [[LT_frular], 0, [LIBACT_MOOD, 3], 2],
       [[LT_pritchett], 0, [LIBACT_MOOD, 1], 3],
       [[LT_princess], 0, [LIBACT_MOOD, 1], 4]
     ]], plSpeechLib);

%Marion people

   % Tova
     plSpeechLib = Cons(
     [&MarionBartender, [
       [[LT_paddock], 0, [LIBACT_MOOD, -2], 1],
       [[LT_duke], 0, [LIBACT_MOOD, -1], 2],
       [[LT_tos], 0, [LIBACT_MOOD, -1], 3],
       [[LT_zig], 0, [LIBACT_MOOD, -1], 4]
     ]], plSpeechLib);

   % Ran er'Hoth
     plSpeechLib = Cons(
     [&marionelder, [
       [[LT_akardius],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_DUKE]],
       [[LT_kateriina],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_PRINCESS]],
       [[LT_jonas],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_REBEL]],
       [[LT_alarm], 0, [LIBACT_MOOD, -2], 1],
       [[LT_father], 0, [LIBACT_MOOD, -2], 2],
       [[LT_apple], 0, [LIBACT_MOOD, -2], 3],
       [[LT_old], 0, [LIBACT_MOOD, -2], 4],
       [[LT_quest], 0, [LIBACT_MOOD, -4], 5],
       [[LT_errand], 0, [LIBACT_MOOD, -4], 6],
       [[LT_favor], 0, [LIBACT_MOOD, -4], 7],
       [[LT_crazy], 0, [LIBACT_MOOD, -5], 8],
       [[LT_mad], 0, [LIBACT_MOOD, -5], 9],
       [[LT_lunatic], 0, [LIBACT_MOOD, -5], 10],
       [[LT_dream], 0, [LIBACT_MOOD, -2], 11]
    ]], plSpeechLib);

   % Colhorr
     plSpeechLib = Cons(
     [&marionblacksmith, [
       [[LT_ranerhoth], 0, [LIBACT_MOOD, -3], 1],
       [[LT_hot], 0, [LIBACT_MOOD, -5], 2]
     ]],plSpeechLib);

%Cor Noth people

   % D'Franco
     plSpeechLib = Cons(
     [&cornothinnkeeper, [
       [[LT_akardius],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_DUKE]],
       [[LT_kateriina],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_PRINCESS]],
       [[LT_jonas],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_REBEL]],
       [[LT_princess], 0, [LIBACT_MOOD, -2], 1]
     ]], plSpeechLib);

%     plSpeechLib = Cons(
%     [&cornothsergeant, [
%%% now created dynamically on recreateall
%       [[LT_punch], 0, [LIBACT_LEARN, SKID_PUNCH, True]],
%       [[LT_slash], 0, [LIBACT_LEARN, SKID_SLASH, True]],
%       [[LT_dodge], 0, [LIBACT_LEARN, SKID_DODGE, True]],
%       [[LT_parry], 0, [LIBACT_LEARN, SKID_PARRY, True]],
%       [[LT_brawling], 0, [LIBACT_LEARN, SKID_BRAWLING, True]],
%       [[LT_macefgt], 0, [LIBACT_LEARN, SKID_PROFICIENCY_MACE, True]],
%       [[LT_axewield], 0, [LIBACT_LEARN, SKID_PROFICIENCY_AXE, True]],
%       [[LT_hammwield], 0, [LIBACT_LEARN, SKID_PROFICIENCY_HAMMER, True]],
%       [[LT_fencing], 0, [LIBACT_LEARN, SKID_PROFICIENCY_SWORD, True]],
%       [[LT_sir], 0, [LIBACT_MOOD, 5], 1],
%       [[LT_princess], 0, [LIBACT_MOOD, -5], 2]
%     ]], plSpeechLib);


      lDontInclude = [ &Cow, &Guard, &Frogman, &Mummy, &BlackMummy, &Avar,
                       &AvarShaman, &AvarChieftain, &DragonFly, &DragonFlyQueen,
                       &Kriipa, &Lich, &RebelTroop, &DukeTroop, &PrincessTroop,
                       &NecromancerTroop, &LupoggKing, &StoneTroll
                     ];
      lMonsters = [ [[LT_sir], 0, [LIBACT_MOOD, 5], 1],
                    [[LT_princess], 0, [LIBACT_MOOD, -5], 2] ];
                    
      for oMonster in Send(SYS,@GetMonsterTemplates)
      {
         if NOT FindListElem(lDontInclude,GetClass(oMonster))
         {
            lTempList = cons(GetClass(oMonster),[]);
            lTempList = cons(LIBACT_MONSTER_ADVICE,lTempList);
            lAddList = cons(lTempList,[]);
            lAddList = cons(0,lAddList);
            lTempList = cons(send(oMonster,@GetName),[]);
            lAddList = cons(lTempList,lAddList);
            lMonsters = cons(lAddList,lMonsters);
         }
      }

      lAddList = cons(lMonsters,[]);
      lAddList = cons(&cornothsergeant,lAddList);

      plSpeechLib = Cons(
         lAddList,
         plSpeechLib);
         
   % Solomon
     plSpeechLib = Cons(
     [&CornothGrocer, [
       [[LT_herbutte], 0, [LIBACT_MOOD, 1], 1]
     ]],plSpeechLib);

%Jasper people

   % Yevitan
     plSpeechLib = Cons(
     [&jasperbanker,[
       [[LT_akardius],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_DUKE]],
       [[LT_kateriina],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_PRINCESS]],
       [[LT_jonas],0, [ LIBACT_RUMOR_COURT_STATE ,FACTION_REBEL]],
       [[LT_tos], 0, [LIBACT_MOOD, -2], 1],
       [[LT_duke], 0, [LIBACT_MOOD, -2], 2],
       [[LT_king], 0, [LIBACT_MOOD, -2], 3],
       [[LT_whiskey], 0, [LIBACT_MOOD, -10], 4]
     ]],plSpeechLib);
   
     plSpeechLib = Cons(
     [&OneCouncilor, [
     ]],plSpeechLib);

   % Qesino
     plSpeechLib = Cons(
     [&JasperInnKeeper, [
       [[LT_quintor], 0, [LIBACT_MOOD, -3], 1],
       [[LT_kill], 0, [LIBACT_MOOD, -10], 2],
       [[LT_assassin], 0, [LIBACT_MOOD, -10], 3],
       [[LT_murder], 0, [LIBACT_MOOD, -10], 4]
     ]],plSpeechLib);

   % Afiera D'xor
     plSpeechLib = Cons(
     [&jasperelder, [
       [[LT_treefolk], 0, [LIBACT_MOOD, -2], 1],
       [[LT_ant], 0, [LIBACT_MOOD, -2], 2],
       [[LT_yeti], 0, [LIBACT_MOOD, -2], 3],
       [[LT_spider], 0, [LIBACT_MOOD, -3], 4],
       [[LT_giantrat], 0, [LIBACT_MOOD, -3], 5],
       [[LT_troll], 0, [LIBACT_MOOD, -2], 6],
       [[LT_centipede], 0, [LIBACT_MOOD, -2], 7],
       [[LT_orc], 0, [LIBACT_MOOD, -2], 8],
       [[LT_dement], 0, [LIBACT_MOOD, -2], 9],
       [[LT_lightnin], 0, [LIBACT_MOOD, -2], 10],
       [[LT_council], 0, [LIBACT_MOOD, -2], 11],
       [[LT_princess], 0, [LIBACT_MOOD, -2], 12],
       [[LT_duke], 0, [LIBACT_MOOD, -2], 13],
       [[LT_tos], 0, [LIBACT_MOOD, -2], 14],
       [[LT_jasper], 0, [LIBACT_MOOD, -2], 15],
       [[LT_marion], 0, [LIBACT_MOOD, -2], 16],
       [[LT_cor], 0, [LIBACT_MOOD, -2], 17],
       [[LT_barloque], 0, [LIBACT_MOOD, -2], 18],
       [[LT_hello], 0, [LIBACT_MOOD, -2], 19],
       [[LT_hi], 0, [LIBACT_MOOD, -2], 20],
       [[LT_hiya], 0, [LIBACT_MOOD, -2], 21],
       [[LT_howdy], 0, [LIBACT_MOOD, -2], 22],
       [[LT_bye], 0, [LIBACT_MOOD, -2], 23],
       [[LT_goodbye], 0, [LIBACT_MOOD, -2], 24],
       [[LT_faren], 0, [LIBACT_MOOD, -3], 25],
       [[LT_jala], 0, [LIBACT_MOOD, -1], 26]
     ]], plSpeechLib);

   % Zhieu B'hob
     plSpeechLib = Cons(
     [&JasperMerchant, [
       [[LT_princess], 0, [LIBACT_MOOD, 2], 1],
       [[LT_yes], 0, [LIBACT_MOOD, 5], 2],
       [[LT_afiera], 0, [LIBACT_MOOD, 2], 3],
       [[LT_qesino], 0, [LIBACT_MOOD, 1], 4],
       [[LT_quintor], 0, [LIBACT_MOOD, 1], 5],
       [[LT_wryn], 0, [LIBACT_MOOD, 2], 6],
       [[LT_council], 0, [LIBACT_MOOD, 2], 7],
       [[LT_princess], 0, [LIBACT_MOOD, 2], 8],
       [[LT_pietro], 0, [LIBACT_MOOD, 1], 9],
       [[LT_duke], 0, [LIBACT_MOOD, 1], 10],
       [[LT_yevitan], 0, [LIBACT_MOOD, 1], 11],
       [[LT_marion], 0, [LIBACT_MOOD, 1], 12],
       [[LT_wool], 0, [LIBACT_MOOD, 2], 13],
       [[LT_tos], 0, [LIBACT_MOOD, 1], 14],
       [[LT_jasper], 0, [LIBACT_MOOD, 1], 15],
       [[LT_cor], 0, [LIBACT_MOOD, 1], 16],
       [[LT_zig], 0, [LIBACT_MOOD, 1], 17],
       [[LT_barloque], 0, [LIBACT_MOOD, 1], 18],
       [[LT_tova], 0, [LIBACT_MOOD, 1], 19],
       [[LT_whiskey], 0, [LIBACT_MOOD, 1], 20],
       [[LT_hello], 0, [LIBACT_MOOD, 1], 21],
       [[LT_hi], 0, [LIBACT_MOOD, 1], 22],
       [[LT_hiya], 0, [LIBACT_MOOD, 1], 23],
       [[LT_howdy], 0, [LIBACT_MOOD, 1], 24],
       [[LT_bye], 0, [LIBACT_MOOD, 1], 25],
       [[LT_goodbye], 0, [LIBACT_MOOD, 1], 26]
     ]], plSpeechLib);

   % Quintor
     plSpeechLib = Cons(
     [&jasperblacksmith, [
       [[LT_whiskey], 0, [LIBACT_MOOD, -2], 1],
       [[LT_widow], 0, [LIBACT_MOOD, -5], 2],
       [[LT_pietro], 0, [LIBACT_MOOD, -2], 3],
       [[LT_yevitan], 0, [LIBACT_MOOD, -2], 4],
       [[LT_zhieu], 0, [LIBACT_MOOD, -1], 5],
       [[LT_afiera], 0, [LIBACT_MOOD, -1], 6],
       [[LT_princess], 0, [LIBACT_MOOD, -3], 7],
       [[LT_duke], 0, [LIBACT_MOOD, -3], 8],
       [[LT_council], 0, [LIBACT_MOOD, -3], 9],
       [[LT_qesino], 0, [LIBACT_MOOD, -3], 10]
     ]], plSpeechLib);

   % Pietro
     plSpeechLib = Cons(
     [&jasperbartender, [
       [[LT_hello], 0, [LIBACT_MOOD, -2], 1],
       [[LT_hi], 0, [LIBACT_MOOD, -2], 2],
       [[LT_hiya], 0, [LIBACT_MOOD, -2], 3],
       [[LT_howdy], 0, [LIBACT_MOOD, -2], 4],
       [[LT_bye], 0, [LIBACT_MOOD, -2], 5],
       [[LT_goodbye], 0, [LIBACT_MOOD, -2], 6],
       [[LT_quintor], 0, [LIBACT_MOOD, -2], 7],
       [[LT_drunk], 0, [LIBACT_MOOD, -5], 8],
       [[LT_widow], 0, [LIBACT_MOOD, -2], 9],
       [[LT_yevitan], 0, [LIBACT_MOOD, -2], 10],
       [[LT_afiera], 0, [LIBACT_MOOD, -2], 11],
       [[LT_barloque], 0, [LIBACT_MOOD, -2], 12],
       [[LT_cor], 0, [LIBACT_MOOD, -2], 13],
       [[LT_jasper], 0, [LIBACT_MOOD, -2], 14],
       [[LT_marion], 0, [LIBACT_MOOD, -2], 15],
       [[LT_tos], 0, [LIBACT_MOOD, -2], 16],
       [[LT_duke], 0, [LIBACT_MOOD, -2], 17],
       [[LT_princess], 0, [LIBACT_MOOD, -2], 18],
       [[LT_council], 0, [LIBACT_MOOD, -2], 19],
       [[LT_secret], 0, [LIBACT_MOOD, -2], 20],
       [[LT_broom], 0, [LIBACT_MOOD, -2], 21]
     ]], plSpeechLib);

 %Priestesses

     plSpeechLib = Cons(
     [&kraananpriestess, [
       [[LT_threecon], 0, [LIBACT_MOOD, -2], 1]
     ]], plSpeechLib);

     plSpeechLib = Cons(
     [&farenpriestess, [
       [[LT_qor], 0, [LIBACT_MOOD, -5], 1],
       [[LT_riija], 0, [LIBACT_MOOD, -1], 2],
       [[LT_jala], 0, [LIBACT_MOOD, 2], 3],
       [[LT_faren], 0, [LIBACT_MOOD, 1], 4]
     ]], plSpeechLib);

     plSpeechLib = Cons(
     [&qorpriestess, [
       [[LT_shal1], 0, [LIBACT_MOOD, -2], 1],
       [[LT_shal2], 0, [LIBACT_MOOD, -2], 2],
       [[LT_vile], 0, [LIBACT_MOOD, 1], 3],
       [[LT_good], 0, [LIBACT_MOOD, -1], 4]
     ]], plSpeechLib);

     plSpeechLib = Cons(
     [&shalillepriestess, [
       [[LT_resign], 0, [LIBACT_SAY, LM_shal_prst_faction_resign]],
       [[LT_qor], 0, [LIBACT_MOOD, -1], 1],
       [[LT_shal1], 0, [LIBACT_MOOD, 1], 2],
       [[LT_shal2], 0, [LIBACT_MOOD, 1], 3],
       [[LT_pray], 0, [LIBACT_MOOD, 1], 4],
       [[LT_prayer], 0, [LIBACT_MOOD, 1], 5]
     ]], plSpeechLib);

     plSpeechLib = Cons(
    [&hazartown,[
      [[LT_akardius,LT_duke,LT_princess,LT_kateriina],0,[LIBACT_SAY,LM_haz_factions]],
      [[LT_cor,LT_jasper,LT_marion,LT_barloque,LT_tos],0,[LIBACT_SAY,LM_haz_towns]],
        [[LT_help],0,[LIBACT_SAY,LM_haz_help]]
     ]],plSpeechLib);

     plSpeechLib = Cons(
    [&hazarInnkeeper,[
        [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarBartender,[
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarElder,[
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest_elder]],
      [[LT_mausoleum],0,[LIBACT_SAY,LM_haz_mausoleum]],
      [[LT_mummy],0,[LIBACT_SAY,LM_haz_mummy]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarApothecary,[
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]]
     ]],plSpeechLib);
     plSpeechLib = Cons(
    [&hazarBlacksmith,[
      [[LT_quest],0,[LIBACT_SAY,LM_haz_quest]]
     ]],plSpeechLib);


     return; }

      AppendSpeechLibrary(lDialogue=$)
      {
    %% assume all is right with the world, and tack it in
    if lDialogue <> $
    {
       pLSpeechLib = Cons(lDialogue,plSpeechLib);
    }
    return;
     }

   CreateFortuneLibrary()
   {
      plFortunes = $;
      plCommonFortunes = $;


      %% Add the most commonly recurring ones here.
     %% All the fortunes which are added here will appear
     %% quite a bit more often than any other fortune added below.
     %%
     plCommonFortunes = [
      FC_1, FC_2, FC_3, FC_4, FC_5
     ];


      %% Add the rest of the fortunes here.
     %%
      plFortunes = $;
      plFortunes = Cons(FC_10, plFortunes);
      plFortunes = Cons(FC_11, plFortunes);
      plFortunes = Cons(FC_12, plFortunes);
      plFortunes = Cons(FC_13, plFortunes);
      plFortunes = Cons(FC_14, plFortunes);
      plFortunes = Cons(FC_15, plFortunes);
      plFortunes = Cons(FC_16, plFortunes);
      plFortunes = Cons(FC_17, plFortunes);
      plFortunes = Cons(FC_18, plFortunes);
      plFortunes = Cons(FC_19, plFortunes);
      plFortunes = Cons(FC_20, plFortunes);
      plFortunes = Cons(FC_21, plFortunes);
      plFortunes = Cons(FC_22, plFortunes);
      plFortunes = Cons(FC_23, plFortunes);
      plFortunes = Cons(FC_24, plFortunes);
      plFortunes = Cons(FC_25, plFortunes);
      plFortunes = Cons(FC_26, plFortunes);
      plFortunes = Cons(FC_27, plFortunes);
      plFortunes = Cons(FC_28, plFortunes);
      plFortunes = Cons(FC_29, plFortunes);
      plFortunes = Cons(FC_30, plFortunes);
      plFortunes = Cons(FC_31, plFortunes);
      plFortunes = Cons(FC_32, plFortunes);
      plFortunes = Cons(FC_33, plFortunes);
      plFortunes = Cons(FC_34, plFortunes);
      plFortunes = Cons(FC_35, plFortunes);
      plFortunes = Cons(FC_36, plFortunes);
      plFortunes = Cons(FC_37, plFortunes);
      plFortunes = Cons(FC_38, plFortunes);
      plFortunes = Cons(FC_39, plFortunes);
      plFortunes = Cons(FC_40, plFortunes);
      plFortunes = Cons(FC_41, plFortunes);
      plFortunes = Cons(FC_110, plFortunes);
      plFortunes = Cons(FC_111, plFortunes);
      plFortunes = Cons(FC_112, plFortunes);
      plFortunes = Cons(FC_113, plFortunes);
      plFortunes = Cons(FC_114, plFortunes);
      plFortunes = Cons(FC_115, plFortunes);
      plFortunes = Cons(FC_116, plFortunes);
      plFortunes = Cons(FC_117, plFortunes);
      plFortunes = Cons(FC_118, plFortunes);
      plFortunes = Cons(FC_119, plFortunes);
      plFortunes = Cons(FC_120, plFortunes);
      plFortunes = Cons(FC_121, plFortunes);
      plFortunes = Cons(FC_122, plFortunes);
      plFortunes = Cons(FC_123, plFortunes);
      plFortunes = Cons(FC_124, plFortunes);
      plFortunes = Cons(FC_125, plFortunes);
      plFortunes = Cons(FC_126, plFortunes);
      plFortunes = Cons(FC_127, plFortunes);
      plFortunes = Cons(FC_128, plFortunes);
      plFortunes = Cons(FC_129, plFortunes);
      plFortunes = Cons(FC_130, plFortunes);
      plFortunes = Cons(FC_131, plFortunes);
      plFortunes = Cons(FC_132, plFortunes);
      plFortunes = Cons(FC_133, plFortunes);
      plFortunes = Cons(FC_134, plFortunes);
      plFortunes = Cons(FC_135, plFortunes);
      plFortunes = Cons(FC_136, plFortunes);
      plFortunes = Cons(FC_137, plFortunes);
      plFortunes = Cons(FC_138, plFortunes);
      plFortunes = Cons(FC_139, plFortunes);
      plFortunes = Cons(FC_140, plFortunes);
      plFortunes = Cons(FC_141, plFortunes);
      plFortunes = Cons(FC_142, plFortunes);
      plFortunes = Cons(FC_143, plFortunes);
      plFortunes = Cons(FC_144, plFortunes);
      plFortunes = Cons(FC_145, plFortunes);
      plFortunes = Cons(FC_146, plFortunes);
      plFortunes = Cons(FC_147, plFortunes);
      plFortunes = Cons(FC_148, plFortunes);
      plFortunes = Cons(FC_149, plFortunes);
      plFortunes = Cons(FC_150, plFortunes);
      plFortunes = Cons(FC_151, plFortunes);
      plFortunes = Cons(FC_152, plFortunes);
      plFortunes = Cons(FC_153, plFortunes);
      plFortunes = Cons(FC_154, plFortunes);
      plFortunes = Cons(FC_155, plFortunes);
      plFortunes = Cons(FC_156, plFortunes);
      plFortunes = Cons(FC_157, plFortunes);
      plFortunes = Cons(FC_158, plFortunes);
      plFortunes = Cons(FC_159, plFortunes);
      plFortunes = Cons(FC_160, plFortunes);
      plFortunes = Cons(FC_161, plFortunes);
      plFortunes = Cons(FC_162, plFortunes);
      plFortunes = Cons(FC_163, plFortunes);
      plFortunes = Cons(FC_164, plFortunes);
      plFortunes = Cons(FC_165, plFortunes);
      plFortunes = Cons(FC_166, plFortunes);
      plFortunes = Cons(FC_167, plFortunes);
      plFortunes = Cons(FC_168, plFortunes);
      plFortunes = Cons(FC_169, plFortunes);
      plFortunes = Cons(FC_170, plFortunes);
      plFortunes = Cons(FC_171, plFortunes);
      plFortunes = Cons(FC_172, plFortunes);
      plFortunes = Cons(FC_173, plFortunes);
      plFortunes = Cons(FC_174, plFortunes);
      plFortunes = Cons(FC_175, plFortunes);
      plFortunes = Cons(FC_176, plFortunes);
      plFortunes = Cons(FC_177, plFortunes);
      plFortunes = Cons(FC_178, plFortunes);
      plFortunes = Cons(FC_179, plFortunes);
      plFortunes = Cons(FC_180, plFortunes);
      plFortunes = Cons(FC_181, plFortunes);
      plFortunes = Cons(FC_182, plFortunes);
      plFortunes = Cons(FC_183, plFortunes);
      plFortunes = Cons(FC_184, plFortunes);
      plFortunes = Cons(FC_185, plFortunes);
      plFortunes = Cons(FC_186, plFortunes);
      plFortunes = Cons(FC_187, plFortunes);
      plFortunes = Cons(FC_188, plFortunes);
      plFortunes = Cons(FC_189, plFortunes);
      plFortunes = Cons(FC_190, plFortunes);
      plFortunes = Cons(FC_191, plFortunes);
      plFortunes = Cons(FC_192, plFortunes);
      plFortunes = Cons(FC_193, plFortunes);
      plFortunes = Cons(FC_194, plFortunes);
      plFortunes = Cons(FC_195, plFortunes);
      plFortunes = Cons(FC_196, plFortunes);
      plFortunes = Cons(FC_197, plFortunes);
      plFortunes = Cons(FC_198, plFortunes);
      plFortunes = Cons(FC_199, plFortunes);
      plFortunes = Cons(FC_200, plFortunes);
      plFortunes = Cons(FC_201, plFortunes);
      plFortunes = Cons(FC_202, plFortunes);
      plFortunes = Cons(FC_203, plFortunes);
      plFortunes = Cons(FC_204, plFortunes);
      plFortunes = Cons(FC_205, plFortunes);
      plFortunes = Cons(FC_206, plFortunes);
      plFortunes = Cons(FC_207, plFortunes);
      plFortunes = Cons(FC_208, plFortunes);
      plFortunes = Cons(FC_209, plFortunes);
      plFortunes = Cons(FC_210, plFortunes);
      plFortunes = Cons(FC_211, plFortunes);
      plFortunes = Cons(FC_212, plFortunes);
      plFortunes = Cons(FC_213, plFortunes);
      plFortunes = Cons(FC_214, plFortunes);
      plFortunes = Cons(FC_215, plFortunes);
      plFortunes = Cons(FC_216, plFortunes);
      plFortunes = Cons(FC_217, plFortunes);
      plFortunes = Cons(FC_218, plFortunes);
      plFortunes = Cons(FC_219, plFortunes);
      plFortunes = Cons(FC_220, plFortunes);
      plFortunes = Cons(FC_221, plFortunes);
      plFortunes = Cons(FC_222, plFortunes);
      plFortunes = Cons(FC_223, plFortunes);
      plFortunes = Cons(FC_224, plFortunes);
      plFortunes = Cons(FC_225, plFortunes);
      plFortunes = Cons(FC_226, plFortunes);
      plFortunes = Cons(FC_227, plFortunes);
      plFortunes = Cons(FC_228, plFortunes);
      plFortunes = Cons(FC_229, plFortunes);
      plFortunes = Cons(FC_230, plFortunes);
      plFortunes = Cons(FC_231, plFortunes);
      plFortunes = Cons(FC_232, plFortunes);
      plFortunes = Cons(FC_233, plFortunes);
      plFortunes = Cons(FC_234, plFortunes);
      plFortunes = Cons(FC_235, plFortunes);

      return;
   }

   PickFortune()
   {
      local a, b;
     a = Length(plCommonFortunes);
     b = Length(plFortunes);
      if (Random(1, b + a + a + a + a + a) < b)   % 5x more likely to get common one
     {
         return Nth(plFortunes, Random(1, b));
     }
      return Nth(plCommonFortunes, Random(1, a));
   }

   AddToMobLib(mob = $, percent = 0, triggers = $, action = $, id = 0)
   "Add a new trigger/event to the mob library. If the mob already has"
   "entries, we simply add them to that list, otherwise we create a new"
   "section on the library."
   {
      local i;
 
      for i in plMobLib
      {
         if First(i) = mob
         {
            SetNth(i,2,Cons([percent,triggers,action,id],Nth(i,2)));
            return;
         }
      }
      plMobLib=Cons([mob,[[percent,triggers,action,id]]],plMobLib);
      return;
   }

   DeleteFromMobLib(mob = $, id = -1)
   "Delete triggers/events from the mob library. Any which match the id"
   "value are deleted, or all are deleted if the id is -1 (Default)."
   "If all are deleted, then the reference to the mob is deleted as well."
   {
      local i,j,k,lTmp,iCount;
 
      iCount=0;
      for i in plMobLib
      {
         iCount=iCount+1;
         if First(i) = mob
         {
            % Found entries for the mob, delete the relevant ones.
            lTmp=Nth(i,2);
            for j in lTmp
            {
               % we are marching through the mobs events, hoping for id matches
               if Nth(j,4) = id OR id = -1
               {
                  lTmp=DelListElem(lTmp,j);
               }
            }

            % finished deleting this id from the list, see if any entries left
            if lTmp = $
            {
               plMobLib=DelListElem(plMobLib,i);
            }
            else
            {
            SetNth(plMobLib,iCount,[mob,lTmp]);
            iCount = iCount - 1;
            }
            return;
         }
      }
      return;
   }

   PersonalityClash(mob = $, libvec = 0)
   "Determine if the mob has a conflicting personality to a library entry"
   {
      if mob = $ OR libvec=0 {return False;}

      if ((libvec & LIBRES_FEMALE_ONLY) <> 0) AND
         (Send(mob,@GetGender) = GENDER_MALE)
      {
         return True;
      }
      if ((libvec & LIBRES_MALE_ONLY) <> 0) AND
         (Send(mob,@GetGender) = GENDER_FEMALE)
      {
         return True;
      }
      if ((libvec & LIBRES_NOT_ROOK) <> 0) AND
         (IsClass(mob,&CorNothSergeant))
      {
    return True;
      }
      if ((libvec & LIBRES_NOT_NEWBIE) <> 0) AND (IsClass(mob,&HazarTown))
    {  return True;  }

      if( ( libvec & LIBRES_MOOD_MASK ) <> 0 )
      {
    if( (( libvec & LIBRES_MOOD_MASK ) & send( mob, @GetMoodFlags )) = 0 )
    {
       return TRUE;
    }
      }
      return False;
   }

   SearchMobLib(mob = $, string = $, percent = 100, count=0, action_list=$)
   "Given the mob and either a string or a percentage, return an action."
   "When two or more actions apply, a random one is chosen. The local mob lib"
   "triggers only match if EVERY speech keyword is stated."
   % Now returns a list [lAction, cMobClass, iKey] for spamlist to use
   % MobLib items without keys (currently all of them) will not be filtered by spamlist
   {
      local i,j,k,lActionList,iCount,bFound,iKey, ktriggered, bKtContainK, bKContainKt;
      lActionList = action_list;
      ktriggered = $;
      iCount = count;
      %bFound = FALSE;
      for i in plMobLib
      {
         if (First(i) = mob)
         {
            for j in Nth(i,2)
            {
               if (string <> $) 
               {
                  for k in Nth(j,2)
                  {
                     % We have a speech trigger, check for keyword matches
                     if (StringContain(string,k))
                     {
                        if first(Nth(j,3)) = LIBACT_QST_OBJI_LIST
                        {
                           return nth(j,3);
                        }
                        if ktriggered <> $ {
                           bKtContainK = StringContain(ktriggered,k);
                           bKContainKt = StringContain(k,ktriggered);
                        }
                        else {
                           bKtContainK = false;
                           bKContainKt = true;
                        }
                        if bKContainKt {           % old trigger is a subset of the new one, so the new one takes precedence (ex. "mutant ant" always supercedes "ant")
                           iKey = 0;
                           if( length(j) > 3 )
                              { iKey = Nth(j,4); }
                           lActionList = [Nth(j,3), GetClass(First(i)), iKey];
                           ktriggered = k;
                           iCount = 0;             % reset the counter, since we've superceded the whole set of options we were picking randomly amongst
                           break;                  % don't need to search additional triggers for the same response, nor do we want them all to be counted
                        }
                        else {
                           if ((bKtContainK and bKContainKt) or               % (triggers are equal) or 
                                    not (bKtContainK or bKContainKt)) {       % (triggers are unrelated),
                              if Random(0,iCount) = 0 % and bFound = FALSE    % so pick one randomly
                              {
                                 iKey = 0;
                                 if( length(j) > 3 )
                                    { iKey = Nth(j,4); }
                                 lActionList = [Nth(j,3), GetClass(First(i)), iKey];
                                 ktriggered = k;
                              }
                              iCount = iCount + 1;    % keep track of how many equally viable triggers we've gone through (whether we picked them or not)
                              break;                  % don't need to search additional triggers for the same response, nor do we want them all to be counted
                           }
                        }
                     }
                  }
               }
               else
               {
                  if (Nth(j,1)>=percent)
                  {
                     if Random(0,iCount) = 0
                     {
                        iKey = 0;
                        if( length(j) > 3 )
                        {
                           iKey = Nth(j,4);
                        }
                        lActionList = [Nth(j,3), GetClass(First(i)), iKey];
                     } 
                     iCount = iCount + 1;
                     continue;
                  }
               }
            }
         }
      }
      return lActionList;
   }

   % spew everything
   DebugSpeechLib(mob = $)
   {
      local i,j,lAct;
      for i in plSpeechLib
      {
         if IsClass(mob,First(i))
    {
       for j in Nth(i,2)
            {
          lAct = nth(j,3);
          if( first(lAct) = LIBACT_QUOTE )
          {
        Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_MESSAGE,
             #string = quote_substring,
             #parm1=Nth(lAct,2) );
          }
          if( first(lAct) = LIBACT_MOOD )
          {
%        Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_MESSAGE,
%             #string = quote_substring,
%             #parm1=Nth(lAct,2) );
%        debug("mood trigger",mob);
          }

       }
    }
      }
      return;
   } 
   

   SearchSpeechLib(mob = $, string = $)
   "Given the mob and the string, return an action. Any of the superclasses"
   "of the mob can provide the action, and when two or more actions apply,"
   "a random one is chosen."
   % Now returns a list [lAction, cMobClass, iKey] for spamlist to use
   % SpeechLib items without keys will not be filtered by spamlist
   % Note: mood mods are handled specially
   %% They are always processed immediately and added to spam list,
   %% then search continues for a "real" action
   {
      local i,j,k,iCount,lActionList, iKey, bFound, ktriggered, bKtContainK, bKContainKt;
      lActionList = $;
      ktriggered = $;      % saves the current speech trigger corresponding to lActionList
      iCount = 0;
%      debug( "SL: looking for class",GetClass(mob) );
      for i in plSpeechLib
      {
         if IsClass(mob,First(i)) 
         {
%           debug( "SL: found class",First(i) );
            if (Send(mob,@GetAttributes) & MOB_LOCAL_ONLY) <> 0 AND (First(i) <> GetClass(mob)) 
               { continue; }
            for j in Nth(i,2)
            {
               if not Send(self,@PersonalityClash,#mob=mob,#libvec=Nth(j,2))
               {
%                 debug("SL:checking",string); 
                  for k in Nth(j,1)
                  {
                     % We have a suitable action for the class, check triggers
                     if (StringContain(string,k))
                     {
%                       debug("SL: passed stringcontain",k);
                        % Spam filter:
                        % Check action key against list of keys triggered since last randomtimer firing
                        % Only check items with keys (4th in list)
                        % Don't repeat it if it's on the list
                        if( Length(j) > 3 )
                        {
                           if send( mob, @OnSpamList, #mob_class = First(i), #key_num = Nth(j,4) )
                              { continue; }
                        }
%                       debug("SL: passed spamlist",k);

         if( First(Nth(j,3)) = LIBACT_MOOD )
         {
            % it's a mood change action, so process it immediately
            Post( self, @ParseAction, #action=Nth(j,3), #mob=mob );

            % now add it to the spam list
            Send( mob, @AddToSpamList, #mob_class=First(i), #key_num=Nth(j,4) );

            % keep searching for a "real" action       
            continue;
         }

                        if ktriggered <> $ {
                           bKtContainK = StringContain(ktriggered,k);
                           bKContainKt = StringContain(k,ktriggered);
                        }
                        else {
                           bKtContainK = false;
                           bKContainKt = true;
                        }
                        if bKContainKt {           % old trigger is a subset of the new one, so the new one takes precedence (ex. "mutant ant" always supercedes "ant")
                           iKey = 0;
                           if( length(j) > 3 )
                              { iKey = Nth(j,4); }
                           lActionList = [Nth(j,3), First(i), iKey];
                           ktriggered = k;
                           iCount = 0;             % reset the counter, since we've superceded the whole set of options we were picking randomly amongst
                           break;                  % don't need to search additional triggers for the same response, nor do we want them all to be counted
                        }
                        else {
                           if ((bKtContainK and bKContainKt) or            % (triggers are equal) or 
                                    not (bKtContainK or bKContainKt)) {    % (triggers are unrelated),
                              if (Random(0,iCount) = 0) {                  % so pick one randomly
                                 iKey = 0;
                                 if( length(j) > 3 )
                                    { iKey = Nth(j,4); }
                                 lActionList = [Nth(j,3), First(i), iKey];
                                 ktriggered = k;
                              }
                              iCount = iCount + 1;    % keep track of how many equally viable triggers we've gone through (whether we picked them or not)
                              break;                  % don't need to search additional triggers for the same response, nor do we want them all to be counted
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      return Send(self,@SearchMobLib,#mob=mob, #percent=0, #string=string, 
                 #count=iCount, #action_list=lActionList);
   }

   % extended speech and random lib stuff   -AJM

   % spew everything
   DebugRandomLib(mob = $)
   {
      local i,j,lAct;
      for i in plRandomLib
      {
         if IsClass(mob,First(i))
    {
       for j in Nth(i,2)
            {
          lAct = nth(j,3);
          if( first(lAct) = LIBACT_QUOTE )
          {
        Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_MESSAGE,
             #string = quote_substring,
             #parm1=Nth(lAct,2) );
          }
       }
    }
      }
      return;
   } 

   SetRandomLibQuote( npc_class = $, keynum = 0, percent = 50, mood = $, quote = $, append = FALSE )
   {
      % if key is found, replaces string (or appends if append = TRUE)
      % otherwise creates new key
      % returns key used, or FALSE on error
      % if percent non-nil, replaces percent
      % if quote = nil, does not change quote
      % new class added if npc_class not found -- be careful! no way to error check this? xxxAJM;
      % mood only set on initial create

      local lClassBranch, lSpeechBranch, iCurrKey, iHighKey, lNewSpeechBranch, sScratch;

      if( keynum = -1 )
      {
    keynum = piLastRandomKey;
    npc_class = pcLastRandomClass;
      }
      if( npc_class = $ )
      {
    pcLastRandomClass = $;
    piLastRandomKey = 0;
    return FALSE;
      }
      if( percent < 5 )
      {
         percent = 5;
      }
      if( percent > 100 )
      {
         percent = 100;
      }
      if( mood = $ )
      {
    mood = 0;
      }
      if( mood < 1 )
      {
         mood = 0;
      }
            
      iHighKey = 0;
      for lClassBranch in plRandomLib
      {
    if( npc_class = First( lClassBranch ) )
    {
       for lSpeechBranch in Nth( lClassBranch, 2 )
       {
          if( First( Nth( lSpeechBranch, 3 ) ) = LIBACT_QUOTE )
          {
        % quote action
        iCurrKey = Nth( lSpeechBranch, 4 );
        if( iCurrKey = keynum )
        {
           % found it - replace if non-nil
           if( quote <> $ )
           {
         if( append )
         {
%            debug( "appending string" );

            setString(First(plScratchString), quote);

            clearTempString();
            appendTempString(Nth(Nth(lSpeechbranch, 3), 2));
            appendTempString(First(plScratchString));
            setString(Nth(Nth(lSpeechbranch, 3), 2), getTempString());

%            SetString( First( plScratchString ), append_string );
%            StringSubstitute( First( plScratchString ), append_substring1, Nth( Nth( lSpeechbranch, 3 ), 2 ) );
%            StringSubstitute( First( plScratchString ), append_substring2, quote );
%            SetString( Nth( Nth( lSpeechbranch, 3 ), 2 ), First( plScratchString ) );

         }
         else
         {
%            debug( "replacing string" ); 
            SetString( Nth( Nth( lSpeechbranch, 3 ), 2 ), quote );
         }
           }
           % replace percent if non-nil
           if( percent <> $ )
           {
         SetNth( lSpeechBranch, 1, percent );
           }
           pcLastRandomClass = npc_class;
           piLastRandomKey = keynum;
           return keynum;
        }
        if( iCurrKey > iHighKey )
        {
           iHighKey = iCurrKey;
        }
          }
       }

       % key not found - create new key
%       debug( "creating new string" );

       iHighKey = iHighkey + 1;
       lNewSpeechBranch = [ percent, mood, [ LIBACT_QUOTE, CreateString() ], iHighKey ];
       SetString( Nth( Nth( lNewSpeechBranch, 3 ), 2 ), quote );
       SetNth( lClassBranch, 2, cons( lNewSpeechBranch, Nth( lClassBranch, 2 ) ) );

       pcLastRandomClass = npc_class;
       piLastRandomKey = iHighKey;
       return iHighKey;
    }
      }

      % class not found, create new branch
      if( TRUE ) % want a way to validate a class name here
      {
%    debug( "RandomLib: creating new class ",npc_class );
    iHighKey = 1;
    lNewSpeechBranch = [ percent, mood, [ LIBACT_QUOTE, CreateString() ], iHighKey ];
    SetString( Nth( Nth( lNewSpeechBranch, 3 ), 2 ), quote );
    lClassBranch = [ npc_class, [ lNewSpeechBranch ] ];
    plRandomLib = cons( lClassBranch, plRandomLib );

    pcLastRandomClass = npc_class;
    piLastRandomKey = iHighKey;
    return iHighKey;
      }

      debug( "RandomLib: Invalid class, ignored." );
      pcLastRandomClass = $;
      piLastRandomKey = 0;
      return FALSE;
   }

   AppendLastRandomLibQuote( quote = $ )
   {
      % appends quote to last quote added (to bypass length restriction on admin textfile read)

      if( quote = $ )
      {
    return 0;
      }
      if( piLastRandomKey = 0 )
      {
    return 0;
      }
      if( pcLastRandomClass = $ )
      {
    return 0;
      }
      return send( self, @SetRandomLibQuote, #keynum = -1, #quote = quote, #append = TRUE );
   }

   SetSpeechLibTrigger( npc_class = $, keynum = 0, triggernum = 0, trigger = $, mood = $, mood_change = $ )
   {
      % if key and triggernum both found, replaces trigger
      % if key is found, but not triggernum, creates new trigger
      % if key is -1, uses last key set (for adding multiple triggers)
      % otherwise creates new key
      % returns key used
      % new class added if npc_class not found -- be careful! no way to error check this? xxxAJM;
      % mood only set on initial create
      % if mood_change is sent, creates a mood_change trigger isntead of a quote trigger

      local lClassBranch, lSpeechBranch, iCurrKey, iHighKey, lNewSpeechBranch, iNumTriggers, lNewAction;
      if( keynum = -1 )
      {
    keynum = piLastSpeechKey;
    npc_class = pcLastSpeechClass;
      }
      if( npc_class = $ )
      {
    pcLastSpeechClass = $;
    piLastSpeechKey = 0;

    return 0;
      }
      if( trigger = $ )
      {
    pcLastSpeechClass = $;
    piLastSpeechKey = 0;
    return 0;
      }
      if( mood = $ )
      {
    mood = 0;
      }
      if( mood < 1 )
      {
    mood = 0;
      }

      iHighKey = 0;
      for lClassBranch in plSpeechLib
      {
    if( npc_class = First( lClassBranch ) )
    {
       for lSpeechBranch in Nth( lClassBranch, 2 )
       {
          if( First( Nth( lSpeechBranch, 3 ) ) = LIBACT_QUOTE )
          {
        % look through keys for a match
        iCurrKey = Nth( lSpeechBranch, 4 );
        if( iCurrKey = keynum )
        {
           % found key - now look for triggernum
%           debug( "found key" );
           iNumTriggers = Length( First( lSpeechBranch) );
           if( triggernum > iNumTriggers )
           {
         % add new trigger
%         debug( "adding trigger" );
         SetNth( lSpeechBranch, 1, cons( CreateString(), First( lSpeechBranch ) ) );
         SetString( First( First( lSpeechBranch ) ), trigger );
           }
           else
           {
         % replace trigger, counting from end of list
%         debug( "replacing trigger" );
         SetString( Nth( First( lSpeechBranch ), iNumTriggers - triggernum + 1), trigger );
           }
           piLastSpeechKey = keynum;
           pcLastSpeechClass = npc_class;
           return keynum;
        }
        if( iCurrKey > iHighKey )
        {
           iHighKey = iCurrKey;
        }
          }
       }

       % key not found - create new key

       iHighKey = iHighkey + 1;
       if( mood_change = $ )
       {
          lNewAction = [ LIBACT_QUOTE, CreateString() ];
          SetString( Nth( lNewAction, 2 ), quote_uninitialized );
%          debug( "creating new string" );
       }
       else
       {
          lNewAction = [ LIBACT_MOOD, mood_change ];
%             debug( "creating mood trigger" );
       }
       lNewSpeechBranch = [ [ CreateString() ], mood, lNewAction, iHighKey ];
       SetString( First( First( lNewSpeechBranch) ), trigger );
       SetNth( lClassBranch, 2, cons( lNewSpeechBranch, Nth( lClassBranch, 2 ) ) );
       piLastSpeechKey = iHighKey;
       pcLastSpeechClass = npc_class;
       return iHighKey;
    }
      }

      % class not found, create new branch
      if( TRUE ) % want a way to validate a class name here
      {
    iHighKey = 1;
    if( mood_change = $ )
    {
       lNewAction = [ LIBACT_QUOTE, CreateString() ];
       SetString( Nth( lNewAction, 2 ), quote_uninitialized );
%       debug( "creating new string in new class ", npc_class );
    }
    else
    {
       lNewAction = [ LIBACT_MOOD, mood_change ];
%       debug( "creating mood trigger in new class ", npc_class );
    }
    lNewSpeechBranch = [ [ CreateString() ], mood, lNewAction, iHighKey ];
    SetString( First( First( lNewSpeechBranch) ), trigger );
    lClassBranch = [ npc_class, [ lNewSpeechBranch ] ];
    plSpeechLib = cons( lClassBranch, plSpeechLib );

    piLastSpeechKey = iHighKey;
    pcLastSpeechClass = npc_class;
    return iHighKey;
      }

      debug( "SpeechLib: Invalid class, ignored." );
      piLastSpeechKey = iHighKey;
      pcLastSpeechClass = npc_class;
      return FALSE;
   }

   SetSpeechLibQuote( npc_class = $, keynum = 0, quote = $, append = FALSE )
   {
   % if key is found, replaces quote (or appends if append = TRUE)
   % returns key used
   % adding new key not allowed (must set trigger first), returns -1 if key not found
   % uses piLastSpeechKey if keynum = -1 (use to set quote for last trigger added)
   % adding new class not allowed, returns 0 if class not found;

      local lClassBranch, lSpeechBranch, iCurrKey, iHighKey, lNewSpeechBranch;
      if( keynum = -1 )
      {
    keynum = piLastSpeechKey;
    npc_class = pcLastSpeechClass;
      }
      if( npc_class = $ )
      {
    pcLastSpeechClass = $;
    piLastSpeechKey = 0;
    return 0;
      }
      iHighKey = 0;
      for lClassBranch in plSpeechLib
      {
    if( npc_class = First( lClassBranch ) )
    {
       for lSpeechBranch in Nth( lClassBranch, 2 )
       {
          if( First( Nth( lSpeechBranch, 3 ) ) = LIBACT_QUOTE )
          {
        % quote action
        iCurrKey = Nth( lSpeechBranch, 4 );
        if( iCurrKey = keynum )
        {
           if( append )
           {
%         debug( "appending string" );

         setString(First(plScratchString), quote);

         clearTempString();
         appendTempString(Nth(Nth(lSpeechbranch, 3), 2));
         appendTempString(First(plScratchString));
         setString(Nth(Nth(lSpeechbranch, 3), 2), getTempString());

%         SetString( First( plScratchString ), append_string );
%         StringSubstitute( First( plScratchString ), append_substring1, Nth( Nth( lSpeechbranch, 3 ), 2 ) );
%         StringSubstitute( First( plScratchString ), append_substring2, quote );
%         SetString( Nth( Nth( lSpeechbranch, 3 ), 2 ), First( plScratchString ) );
           }
           else
           {
%         debug( "replacing string" ); 
         SetString( Nth( Nth( lSpeechbranch, 3 ), 2 ), quote );
           }
           pcLastSpeechClass = npc_class;
           piLastSpeechKey = keynum;
           return keynum;
        }
        if( iCurrKey > iHighKey )
        {
           iHighKey = iCurrKey;
        }
          }
       }

       % key not found
       debug( "key not found" );
       pcLastSpeechClass = $;
       piLastSpeechKey = 0;
       return -1;
    }
      }
      pcLastSpeechClass = $;
      piLastSpeechKey = 0;
      return 0;
   }

   AppendLastSpeechLibQuote( quote = $ )
   {
      % appends quote to last quote added (to bypass length restriction on admin textfile read)

      if( quote = $ )
      {
    return 0;
      }
      if( piLastSpeechKey = 0 )
      {
    return 0;
      }
      if( pcLastSpeechClass = $ )
      {
    return 0;
      }
      return send( self, @SetSpeechLibQuote, #keynum = -1, #quote = quote, #append = TRUE );
   }

   SearchRandomLib(mob = $, percent = 100)
   "Given the mob and percentage, return an action"
   {
      local i,j,iCount,lAction,lActionList;
      lAction = $;
      iCount = 0;
      for i in plRandomLib
      {
         if IsClass(mob,First(i))
         {
            if (Send(mob,@GetAttributes) & MOB_LOCAL_ONLY) <> 0 AND
               (First(i) <> GetClass(mob)) 
            { continue; }
            for j in Nth(i,2)
            {
               if (First(j)>=percent) AND (not Send(self,@PersonalityClash,
                                           #mob=mob, #libvec=Nth(j,2)))
               {
                  % We have a legal action, so choose it perhaps.... 
                  if Random(0,iCount) = 0 { lAction = Nth(j,3); } 
                  iCount = iCount + 1;
               }
            }
         }
      }
      lActionList = Send(self,@SearchMobLib,#mob=mob, #percent=percent,
                 #count=iCount, #action_list=[lAction,$,0]);
      if( lActionList = $ )
      {
    return $;
      }
      return First(lActionList);
   }

   % plug words into NPC dialogue, e.g. %NAME <- [player's name]
   SpeechPlugIn( unplugged = $, who = $ )
   {
      local iHour;
      SetString( first(plScratchString), unplugged );

      if( unplugged = $ )
      {
    return;
      }

      iHour = send( SYS, @GetHour );
      while StringContain( first(plScratchString), substring_daynight )
      {
    if( ( iHour < 6 ) OR ( iHour > 17 ) )
    {
       if StringSubstitute( first(plScratchString), substring_daynight, plugin_night ) <> 1 {break;}
    }
    else
    {
       if StringSubstitute( first(plScratchString), substring_daynight, plugin_day ) <> 1 {break;}
    }
      }
      if( IsClass( who, &user ) )
      {
    while StringContain( first(plScratchString), substring_name )
    {
       if StringSubstitute( first(plScratchString), substring_name, send( who, @GetName ) ) <> 1 {break;}
    }
    if( send( who, @GetGender ) = GENDER_MALE )
    {
       while StringContain( first(plScratchString), substring_sirmadam )
       {
          if StringSubstitute( first(plScratchString), substring_sirmadam, plugin_sir ) <> 1 {break;}
       }
       while StringContain( first(plScratchString), substring_lordlady )
       {
          if StringSubstitute( first(plScratchString), substring_lordlady, object_lord ) <> 1 {break;}
       }
       while StringContain( first(plScratchString), substring_ladlassie )
       {
          if StringSubstitute( first(plScratchString), substring_ladlassie, plugin_lad ) <> 1 {break;}
       }
    }
    else
    {
       while StringContain( first(plScratchString), substring_sirmadam )
       {
          if StringSubstitute( first(plScratchString), substring_sirmadam, plugin_madam ) <> 1 {break;}
       }
       while StringContain( first(plScratchString), substring_lordlady )
       {
          if StringSubstitute( first(plScratchString), substring_lordlady, object_lady ) <> 1 {break;}
       }
       while StringContain( first(plScratchString), substring_ladlassie )
       {
          if StringSubstitute( first(plScratchString), substring_ladlassie, plugin_lassie ) <> 1 {break;}
       }
    }
      }
      return first(plScratchString);
   }

   ParseAction(action = $,mob = $, obj = $, target = $)
   "Basically a switch statement, where we handle our various action types"
   {
      local iFlag,oParl;
      if action = $
        { Debug("Null action in ParseAction: mob:",mob); return; }

      iFlag = Nth(action,1);

      if iFlag = LIBACT_QUOTE
      % We have been asked to say a quote (string)   -AJM
      {
         Send(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_MESSAGE,
              #string = quote_substring,
         #parm1=Send( self, @SpeechPlugIn, #unplugged=Nth(action,2), #who=target ) );
         return;
      }

      if iFlag = LIBACT_MOOD
      % We have been induced to change mood   -AJM
      {
%    debug( "Mood change of",Nth(action,2) );
%    debug( "  for ",send( mob, @GetName ) );

         Post( mob, @SetMood, #new_mood = send( mob, @GetMood ) + Nth( action, 2 ) );
         return;
      }

     if iFlag = LIBACT_CONDITIONAL
      {
         Send(mob,@AddToConditionalList,#obj=Nth(action,2),
              #value=Nth(action,3));
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,4),
              #parm1=Send(Nth(action,2),@GetIndef),
              #parm2=Send(Nth(action,2),@GetName));
         return;
      }

      if iFlag = LIBACT_LEARN
      {
         Send(mob,@CanDoTeach,#who=target,
                 #sid=Nth(action,2),#bskill=Nth(action,3));
         return;
      }

      if iFlag = LIBACT_SAY
      % We have been asked to say something with no arguments
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2));
         return;
      }

      if iFlag = LIBACT_SAY_OBJI
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_TARG
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(target,@GetDef),
              #parm2=Send(target,@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJD
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetDef),
              #parm2=Send(Nth(action,3),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJD_OBJD
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetDef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Send(Nth(action,4),@GetDef),
              #parm4=Send(Nth(action,4),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJD_OBJI
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetDef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Send(Nth(action,4),@GetIndef),
              #parm4=Send(Nth(action,4),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJI_OBJD
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Send(Nth(action,4),@GetDef),
              #parm4=Send(Nth(action,4),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJI_OBJI
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Send(Nth(action,4),@GetIndef),
              #parm4=Send(Nth(action,4),@GetName));
         return;
      }

      if iFlag = LIBACT_SAY_OBJD_RSC
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetDef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Nth(action,4));
         return;
      }

      if iFlag = LIBACT_SAY_OBJI_LIST
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Nth(Nth(action,4),1),
              #parm4=Nth(Nth(action,4),2),
              #parm5=Nth(Nth(action,4),3));
         return;
      }

      if iFlag = LIBACT_SAY_OBJI_RSC
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Nth(action,4));
         return;
      }

      if iFlag = LIBACT_SAY_RSC
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Nth(action,3));
         return;
      }

      if iFlag = LIBACT_RUMOR_COURT_STATE
      {
         oParl= Send(SYS,@GetParliament);
         if oParl<>$
           {Send(oParl,@CourtStateRumor,#mob=mob,#faction=Nth(action,2));}
         return;
      }

      if iFlag = LIBACT_NUMBER_REPORT
      {
         oParl= Send(SYS,@GetParliament);
         if oParl<>$
           {Send(oParl,@CourtNumberRumor,#mob=mob);}
         return;
      }

      if iFlag = LIBACT_RUMOR_TOKEN_LOC
      {
         oParl= Send(SYS,@GetTokenGame);
         if oParl<>$
           {Send(oParl,@TokenLocRumor,#mob=mob,#who=target);}
         return;
      }

      if iFlag = LIBACT_SAY_RSC_RSC
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Nth(action,3),
              #parm2=Nth(action,4));
         return;
      }

      if iFlag = LIBACT_QST_SAY_OBJD
      % We have been sent to get a message.. So lets flag the player
      {
         if isClass(mob,&Factions) 
         {
            if (not Send(target,@PlayerIsIntriguing))
            {
               Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                   #type=SAY_RESOURCE,#string=faction_visit_novice);
               return;
            }
            if (Send(target,@GetFaction)=Send(mob,@GetFaction)) AND
               (Send(target,@GetFactionService)<FACTION_MIN_REVISIT_TIME)
            {
               Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                   #type=SAY_RESOURCE,#string=faction_visit_too_soon);
               return;
            }
            if ( (Send(target,@GetFaction)<>FACTION_NEUTRAL) AND
                 (Send(mob,@GetFaction)<>Send(target,@GetFaction)))
            {
               if (Send(Send(SYS,@GetParliament),@GetPower,
                  #faction=Send(mob,@GetFaction))=FACTION_STRONGLY_IN)
                  {
                     Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                        #type=SAY_RESOURCE,#string=faction_visit_wrong,
                        #parm1=faction_visit_wrong_decline);
                  }
               else
                  {
                     Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                        #type=SAY_RESOURCE,#string=faction_visit_wrong,
                        #parm1=faction_visit_wrong_accept);
                  }
               return;
            }
            if (Send(Send(SYS,@GetParliament),@GetPower,
                    #faction=Send(mob,@GetFaction))=FACTION_STRONGLY_IN) AND
                 (Send(mob,@GetFaction)<>Send(target,@GetFaction))
            {
               Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                   #type=SAY_RESOURCE,#string=faction_too_strong);
               return;
            }
            if ( (Send(target,@GetFaction)<>FACTION_NEUTRAL) AND
                 (Send(mob,@GetFaction)=Send(target,@GetFaction)))
            {
               Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                   #type=SAY_RESOURCE,#string=factionite_visit_start);
            }
            if Send(target,@GetFaction)=FACTION_NEUTRAL
            {
               Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                   #type=SAY_RESOURCE,#string=neutral_visit_start);
            }
         }
         
         Send(self,@RecordCompletedQuest,#who=target,
                   #questid=Send(self,@GetQuestID,#who=mob),
                   #type=QST_TEMP_PHRASE);
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@Getdef),
              #parm2=Send(Nth(action,3),@GetName));
         return;
      }

      if iFlag = LIBACT_QST_OBJI_LIST
      % Lets make sure the player is flagged, before we tell them the message.
      {
         if Send(self,@HasDoneQuestID,#who=target,
                 #questID=Send(self,@GetQuestID,#who=Nth(action,3)))
         {
            Send(self,@RecordCompletedQuest,#who=target,
                #questID=(-1*Send(self,@GetQuestID,#who=Nth(action,3))),
                #type=QST_TEMP_PHRASE);
            Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = Nth(action,2),
              #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName),
              #parm3=Nth(Nth(action,4),1),
              #parm4=Nth(Nth(action,4),2),
              #parm5=Nth(Nth(action,4),3));
         }
         else
         {
            Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
              #string = QM_no_record, #parm1=Send(Nth(action,3),@GetIndef),
              #parm2=Send(Nth(action,3),@GetName));
         }
         return;
      }

      if iFlag = LIBACT_COUNCILOR_REPORT
      {
         oParl= Send(SYS,@GetTokenGame);
         if oParl<>$
          { Send(oParl,@CouncilorReport,#mob=mob,
               #who=target,#num=Nth(action,2));
          }
         return;
      }
      
      if iFlag = LIBACT_MONSTER_ADVICE
      {
         %this is a special routine, basically someone asked us about a
         %monster and we want to reply intelligently giving info about
         %how hard the monster is for the target, what its karma is like,
         %and perhaps even a hint on weakness or strength of the monster.
         %To do this, we either need to have access to a monster of the
         %type, or the info is hardcoded somehow... So, lets assume that
         %the information being passed to us includes the monster class.

         Send(self,@MonsterAdvice,#mob=mob,#person=target,#action=action);
         return;
      }

      if iFlag = LIBACT_MANA_NODE_LIST
      {
         Send(self, @PlayerManaNodeList, #mob = mob, #person = target);
         return;
      }

      Debug ("Parse Action ended without matching an action: ",Nth(action,1));
      return;
   }

   MonsterAdvice(mob=$,person=$,action=$)
   {
      local iRnd,oObj,iMval,iPval;

      if not isClass(person,&User) {return;}
      oObj=Create(Nth(action,2));
      iRnd=Random(1,10);
      iMval=Send(oObj,@Getlevel);
      iPval=Send(person,@GetBaseMaxHealth);

      if iPval+30<iMval { prMonster_advice=LM_monster_really_hard; }
      else
      {
         if iPval+15<iMval { prMonster_advice=LM_monster_too_hard; }
         else
         { if iPval-5>iMval { prMonster_advice=LM_monster_too_easy; }
            else { prMonster_advice=LM_monster_about_right; }
         }
      }

      prGroup_advice=$;
      prKarma_advice=$;
      if iMval>(2*iPval)
      {
         prGroup_advice=LM_monster_for_groups;
      }

      if iRnd<5
      {
         %say something about its karma
         iPval=Send(oObj,@GetKarma);
         if iPval>=45 { prKarma_advice=LM_monster_has_high_karma; }
         else 
         {
          if iPval>=15 { prKarma_advice=LM_monster_has_good_karma; }
          else
          {
           if iPval>(-15){ prKarma_advice=LM_monster_has_neutral_karma; }
           else 
           {
            if iPval>(-45) { prKarma_advice=LM_monster_has_bad_karma; }
            else { prKarma_advice=LM_monster_has_low_karma; }
           }
          }
         }
      }

      if prGroup_advice=$ AND prKarma_advice=$
      {
         Send(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
          #string=LM_advice_string1,#parm1=prMonster_advice,
          #parm2=Send(oObj,@GetCapDef),#parm3=Send(oObj,@GetName));
      }
      else
      {  if prGroup_advice=$
         {
            Send(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
             #string=LM_advice_string2,#parm1=prMonster_advice,
             #parm2=prKarma_advice,
             #parm3=Send(oObj,@GetCapDef),#parm4=Send(oObj,@GetName),
             #parm5=Send(oObj,@GetCapDef),#parm6=Send(oObj,@GetName));
         }
         else
         {  if prKarma_advice=$
            {
               Send(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                #type=SAY_RESOURCE, #string=LM_advice_string2,
                #parm1=prMonster_advice,#parm2=prGroup_advice,
                #parm3=Send(oObj,@GetCapDef),#parm4=Send(oObj,@GetName));
            }
            else 
            {
               Send(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
                #type=SAY_RESOURCE, #string=LM_advice_string3,
                #parm1=prMonster_advice,#parm2=prGroup_advice,
                #parm3=prKarma_advice,
                #parm4=Send(oObj,@GetCapDef),#parm5=Send(oObj,@GetName),
                #parm6=Send(oObj,@GetCapDef),#parm7=Send(oObj,@GetName));
            }
         }
      }
   
      Send(oObj,@Delete);
      return;
   }

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% QUEST ENGINE ROUTINES
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% MAINTAIN/CREATE QUEST ENGINE LISTS

   CreateQuestDictionary()
   {
      plQuestDictionary = $;
      plQuestDictionary = [
      LT_aubergine, LT_baobab, LT_couloir, LT_dornick, LT_ergot, LT_francolin,
      LT_heddle, LT_infusorian, LT_jejune, LT_kedge, LT_lumbago, LT_megalith,
      LT_nunatak, LT_operculum, LT_pettifogger, LT_quisling, LT_rigatoni,
      LT_solarium, LT_tiara, LT_ullage, LT_valance, LT_whirlwind, LT_xylem,
      LT_yamen, LT_zeitgeist ];

      return;
   }

   CreateQuestOfferClasses()
   {
      plQuestOfferClasses = $;
      plQuestOfferClasses = [
        &OrcTooth, &Diamond, &Ruby, &DarkAngelFeather, &Scimitar,
        &BlueMushroom, &Chalice, &BlueDragonScale, &Scepter, 
        &ShadowAmulet,&RingofLethargy, &StaffOfJolting, &EntrootBerry ];
      return;
   }

   GetQuestRewardList()
   {
      return plQuestRewards;
   }

   CreateQuestRewards()
   {
      plQuestRewards = $;
      plQuestRewards = [
        &InkyCap, &FireWand, &HealWand, &VampireWand, &Key,
        &BerserkerRing, &FireRing, &RingInvisibility, &Circlet,
        &MysticSword, &PlateArmor, &KnightShield, &DarkAngelFeather,
        &BlueDragonScale, &Gauntlet, &StaffOfJolting, &EntrootBerry ];
      return;
   }

   AddtoQuesterList(who = $)
   {
      plQuesterList = Cons(who,plQuesterList);
      return;
   }

   MoveQuesterOn(who = $)
   {
      local i;
      for i in plQuesterList
      {
         if i = who
         {
            plOnQuestList = Cons(i,plOnQuestList);
            plQuesterList=DelListElem(plQuesterList,i);
         }
      }
      return;
   }

   MoveQuesterOff(who = $)
   {
      local i;
      for i in plOnQuestList
      {
         if i = who
         {
            plQuesterList = Cons(i,plQuesterList);
            plOnQuestList=DelListElem(plOnQuestList,i);
         }
      }
      return;
   }

   DeleteExtraQuests()
   "This walks the list of quests, and deletes any that dont mesh."
   "I.E. if the quester doesnt have the id as its questid, the quest is junked."
   {
      local i; 
      for i in plQuests
      {
      if Send(Self,@GetQuestID,#who=Nth(i,2))<>First(i)
      {
         Send(self,@DeleteQuest,#id=First(i),#clean=True);
      }
      }
      return;
   }


   DeleteFromQuesterList(who = $)
   {
      local i;
      for i in plOnQuestList
      {
          if i = who 
          {
             Send(self,@DeleteQuest,#id=Send(self,@GetQuestID,#who=who));
             break;
          }
      }
      for i in plQuesterList
      {
          if i = who
          {
             plQuesterList=DelListElem(plQuesterList,i);
             break;
          }
          
      }
      return;
   }

   AddToHinterList(who = $)
   {
      plHinterList = Cons(who,plHinterList);
      return;
   }

   DeleteFromHinterList(who = $)
   {
      local i;
      for i in plHinterList
      {
         if i = who
         {
            %We may have lost an active hinter.. so replace it..
            for i in plQuests
            {
               if who = Nth(i,3)
               {
                  if Length(plHinterList) < 2 
                  {
                     %Debug("Quest ran out of hinter mobs. so Deleted");
                     Send(self,@DeleteQuest,#id=Nth(i,1)); 
                  }
                  else 
                  {
                     SetNth(i,3,Send(self,@SelectHinter));
                     while Nth(i,3) = Nth(i,2)
                     {
                        SetNth(i,3,Send(self,@SelectHinter));
                     }

                     Send(Self,@RemoveQuestTriggers,#id=Nth(i,1));
                     Send(Self,@DispenseTriggers,#id=Nth(i,1),
                       #quester=Nth(i,2),#hinter=Nth(i,3),
                       #type=Nth(i,4),#goal=Nth(i,5));
                  }
               }
            }
            plHinterList=DelListElem(plHinterList,who);
            return;
         }
      }
      return;
   }

% QUEST COMPLETED DATABASE

   StripTempQuests(id = 0)
   {
      %We want to eliminate all trace of the given quest from the temp ranks.
      local i,j,oWho,lTemp,lPerm,iCount;

      if id = 0 { return; }
      iCount=0;

      for i in plQuestUsers
      {
         iCount= iCount+1;
         oWho=Nth(i,1);
         lPerm=Nth(i,2);
         lTemp=Nth(i,3);
         for j in lTemp
         {
            if j=id
            { 
               lTemp=DelListElem(lTemp,j);
            }
         }
         if lPerm=$ AND lTemp=$
            { iCount=iCount - 1; plQuestUsers=DelListElem(plQuestUsers,i);}
%         else { SetNth(plQuestUsers,iCount,[oWho,lPerm,lTemp]);}  (DISABLED -- AJM)
      }
      return;
   }

   DeleteCompletedQuest(who = $, id = 0)
   {
      local i,j,lPerm,lTemp,iCount;

      if id = 0 OR who = $ {return;}
      iCount=0;
      for i in plQuestUsers
      {
         iCount= iCount+1;
         if First(i) = who
         {
            lPerm=Nth(i,2);
            lTemp=Nth(i,3);
            for j in lPerm {if j=id OR id=(-1) {lPerm=DelListElem(lPerm,j);}}
            for j in lTemp {if j=id OR id=(-1) {lTemp=DelListElem(lTemp,j);}}
            if lPerm=$ AND lTemp=$ {plQuestUsers=DelListElem(plQuestUsers,i);}
%            else { SetNth(plQuestUsers,iCount,[who,lPerm,lTemp]);} % (DISABLED -- AJM)
            return;
         }
      }
      return;
   }

%  (DISABLED -- AJM)
   RecordCompletedQuest(who = $, questID = 0, type = 0)
   "Give the user credit for completing a quest in the quest database"
   {
%      local i,j,lTemp;
%     if (who=$) OR (not IsClass(who,&User)) OR (questID=0) or (type=0)
%         { return; }
%      for i in plQuestUsers
%      {
%         if First(i) = who
%         {
%            if (type = QST_PERM_OBJECT) OR (type = QST_PERM_PHRASE)
%            {
%               lTemp = Nth(i,2);
%               for j in lTemp { if j = questID { return; } }
%               lTemp = Cons(questID,lTemp);
%               SetNth(i,2,lTemp);
%               return;
%            }
%            else
%            {
%               lTemp = Nth(i,3);
%               for j in lTemp { if j = questID { return; } }
%               lTemp = Cons(questID,lTemp);
%               SetNth(i,3,lTemp);
%               return;
%            }
%         }
%      }
%      if (type = QST_PERM_OBJECT) OR (type = QST_PERM_PHRASE)
%      { lTemp = [ who, [questID], $ ]; }
%      else { lTemp = [ who, $, [questID] ]; }
%
%      plQuestUsers = Cons(lTemp,plQuestUsers);
%       
      return;
   }

   HasDoneQuestID(who = $, questID = 0)
   "Check to see if the user has completed a quest of the given id"
   {
      local i,j;
      if questID = 0  OR who = $ OR (not IsClass(who,&User)) { return False;}
      for i in plQuestUsers
      {
         if First(i) = who
         {
            for j in Nth(i,2) { if j = questID { return True; } }
            for j in Nth(i,3) { if j = questID { return True; } }
            return False;
         }
      }
      return False;
   }

% HANDLE QUEST OPERATIONS

   CreateQuest(type=0, quester=$, reward=$)
   "if there are no arguments, its a temp quest. "
   {
      local i,itemp,iType, oGoal, oQuester, oHinter, lReward, iId;

      iType = type;
      if iType = QST_PERM_OBJECT OR iType = QST_PERM_PHRASE
      % this is a recycling quest... so clean up and then restart
      {
    iId=Send(self,@GetQuestID,#who=quester);
    oQuester=quester;
    lReward=reward;
    if send(oQuester,@MobIsBuyer) or isClass(oQuester,&Factions)
        {iType=QST_PERM_PHRASE;}
    else {iType = Random(QST_PERM_OBJECT,QST_PERM_PHRASE);}
       
    % id = 0 means that its the first call of the quest
    if iId = 0
    {
       iId = Send(Self,@GetNextQuestID); 
       Send(self,@MoveQuesterOn,#who=oQuester);
    }
    else
    {
       % If we are recycling a faction quest, lets burn a new id and
       % strip the old ones away... We also need to make sure that this
       % quest gets cleaned up properly.
       if isclass(oQuester,&Factions)
       {
         Send(self,@StripTempQuests,#id=iId);
         Send(self,@StripTempQuests,#id=-iId);
         Send(Self,@RemoveQuestTriggers,#id=iId);
         for i in plQuests
         {
         if iId = Nth(i,1)
       {
       plQuests=DelListElem(plQuests,i);
       }
         }
         iId = Send(Self,@GetNextQuestID);
       }
    }
      }
      else 
      % its a one-shot temporary quest we want to build....
      {
    oQuester = Send(self,@SelectQuester); 
    if oQuester=$ {return;}

    Send(self,@MoveQuesterOn,#who=oQuester);
    lReward = Send(self,@SelectQuestReward);
    iId = Send(self,@GetNextQuestID);
    if send(oQuester,@MobIsBuyer) {iType=QST_TEMP_PHRASE;}
    else {iType = Random(QST_TEMP_OBJECT,QST_TEMP_PHRASE);}
      }

      oHinter = Send(self,@SelectHinter);
      if Length(plHinterList) > 1
    {
    while oHinter = oQuester 
       { oHinter = Send(self,@SelectHinter);}
    }

      oGoal = Send(self,@SelectQuestGoal,#type = iType);
      Send(self,@InstallQuest,#quester=oQuester,#hinter=oHinter,#type=iType,
      #goal=oGoal,#reward=lReward,#id=iId);
      Send(self,@DispenseTriggers,#type=iType,#goal=oGoal,#id=iId,
      #quester=oQuester,#hinter=oHinter);

      return;
   }

   IsQuestStringMatch(string=$,id=0,goal=$,who=$,mob=$)
   {
      local i,j,lGoal,bTest,bOld,oQuester,lReward,hinter;

      if goal=$ { lGoal = Send(self,@GetQuestGoal,#id=id); bOld=False; }
      else {lGoal = goal; bOld=True;}
    
      for i in lGoal { if not StringContain(string,i) {return False;} }

      %The player said all the keywords, make sure they werent guessing all
      
      for i in plQuestDictionary
      {
         bTest=False;
         if StringContain(string,i)
         % this better be in the goal, otherwise they cheated :)
         {
            for j in lGoal
            {
               if i = j {bTest=True;break;} 
            }
            if not bTest { return False; }
         } 
      }
    %is the mob a one-time permquester?
      if id=0 { Send(self,@GetQuestID,#who=mob); }
      if id <> 0
      {
         lReward=Send(self,@GetQuestReward,#id=id);
         if First(lReward) = QST_REWARD_ID AND
            Send(self,@HasDoneQuestID,#who=who,#questID=Nth(lReward,2))
         {
            Post(Send(oQuester,@GetOwner),@SomeoneSaid,
              #what=oQuester,#type=SAY_RESOURCE,#string = QM_already_done);
            return False;
         }
      }

      if bOld
      {
         Post(Send(mob,@GetOwner),@SomeoneSaid,#what=mob,
             #type=SAY_RESOURCE,#string=QM_old_phrase);
         return False;
      }

      if not Send(self,@HasDoneQuestID,#who=who,#questID=id)
      {
         Post(Send(who,@GetOwner),@SomeoneSaid,#what=mob,
             #type=SAY_RESOURCE,#string=QM_never_sent);
         return False;
      }

      if not Send(self,@HasDoneQuestID,#who=who,#questID=-id)
      {
         hinter=Send(self,@GetHinter,#id=id);
         Post(Send(who,@GetOwner),@SomeoneSaid,#what=mob,
             #type=SAY_RESOURCE,#string=QM_missed_middle,
             #parm1=Send(hinter,@GetDef),#parm2=Send(hinter,@GetName));
         return False;
      }

      Send(self,@DeleteCompletedQuest,#who=who,#id=id);
      Send(self,@DeleteCompletedQuest,#who=who,#id=-id);
      return True;
   }

   FinishedQuest(who=$,id=0) 
   {
      local i,j,iType,lReward,oTmp,oQuester,oGoal,iServ;

      %if already completed, just return with error message. 

      oQuester=Send(self,@GetQuester,#id=id);
      oGoal = Send(self,@GetQuestGoal,#id=id);
      iType = Send(self,@GetQuestType,#id=id);
      lReward = Send(self,@GetQuestReward,#id=id);

      if First(lReward) = QST_REWARD_SERVICE
      {
    if (not Send(who,@PlayerIsIntriguing))
    {
       Post(Send(oQuester,@GetOwner),@SomeoneSaid,#what=oQuester,
          #type=SAY_RESOURCE,#string=faction_visit_novice);
       return;
    }
    if Send(who,@GetFaction)<>FACTION_NEUTRAL and
       Send(who,@GetFaction)<>Send(oQuester,@GetFaction)
    {
       if (Send(Send(SYS,@GetParliament),@GetPower,
           #faction=Send(oQuester,@GetFaction))=FACTION_STRONGLY_IN)
            {
         Post(Send(oQuester,@GetOwner),@SomeoneSaid,#what=oQuester,
           #type=SAY_RESOURCE,#string=faction_visit_wrong,
                #parm1=faction_visit_wrong_decline);
            }
            else
            {
         Post(Send(oQuester,@GetOwner),@SomeoneSaid,#what=oQuester,
           #type=SAY_RESOURCE,#string=faction_visit_wrong,
                #parm1=faction_visit_wrong_accept);
            }
       return;
    }
    %Give em 2500 coins - 100 for each hour its been since they visited.
    if Send(who,@GetFaction)=Send(oQuester,@GetFaction)
      { iServ = 100*Send(who,@GetFactionService)/3600; }
    else
      {iServ = 0;}
    oTmp = Send(who,@GetMoneyObject);
    if oTmp = $
    {
       oTmp = Create(&Money,#number=bound(SERVICE_GOLD_REWARD-iServ,1,$));
       Send(who,@NewHold,#what=oTmp);
    }
    else
    {
       send(oTmp,@AddNumber,#number=bound(SERVICE_GOLD_REWARD-iServ,1,$));
    }

   for i in Send(Send(SYS,@GetParliament),@GetFactionList)
   {
      if First(i)=Send(oQuester,@GetFaction)
      {
         for j in Nth(i,2)
         {
       if j=who {continue;}
       if Send(self,@HasDoneQuestID,#who=j,#questid=(-id))
       {
          Send(j,@MsgSendUser,#message_rsc=Faction_visit_completed);
          Send(j,@UpdateFactionService,#middle=True);
          continue;
       }
       if Send(self,@HasDoneQuestID,#who=j,#questid=(id))
       {
          Send(j,@MsgSendUser,#message_rsc=Faction_visit_completed);
          Send(j,@UpdateFactionService,#front=True);
       }
         }
         
         break;
      }
   }
   
   if Send(who,@GetFaction)=FACTION_NEUTRAL 
   {
     Send(who,@JoinFaction,#new_Faction=Send(oQuester,@GetFaction));
     Post(Send(oQuester,@GetOwner),@SomeoneSaid,
      #what=oQuester,#type=SAY_RESOURCE,#string = QM_join_congrats);
   }
   else
   {
     Send(who,@UpdateFactionService,#full=True);
     Post(Send(oQuester,@GetOwner),@SomeoneSaid,
      #what=oQuester,#type=SAY_RESOURCE,#string = QM_visit_congrats);
   }
      }
      
      if First(lReward) = QST_REWARD_ID
      {
    if Send(self,@HasDoneQuestID,#who=who,#questID=Nth(lReward,2))
    {
       Post(Send(oQuester,@GetOwner),@SomeoneSaid,
         #what=oQuester,#type=SAY_RESOURCE,#string = QM_already_done);
       return False;
    }
    Send(self,@RecordCompletedQuest,#who=who,
        #questID=Nth(lReward,2), #type=iType);
    Post(Send(oQuester,@GetOwner),@SomeoneSaid,
       #what=oQuester,#type=SAY_RESOURCE,#string = QM_ID_congrats);
      }
      
      if First(lReward) = QST_REWARD_ITEMLIST
      {
    Post(Send(oQuester,@GetOwner),@SomeoneSaid,
          #what=oQuester,#type=SAY_RESOURCE,#string=QM_item_congrats);
    for i in Nth(lReward,2)
    {
       oTmp = Create(i);
       if Send(who,@ReqNewHold,#what=oTmp)
       {
          Send(who,@NewHold,#what=oTmp);
       }
       else
       {
          Send(Send(who,@GetOwner),@NewHold,#what=oTmp,
          #new_row=Send(who,@GetRow),#new_col=Send(who,@GetCol));
          Post(Send(oQuester,@GetOwner),@SomeoneSaid,
        #what=oQuester,#type=SAY_RESOURCE,#string=QM_item_too_heavy,
        #parm1=Send(oTmp,@GetDef),#parm2=Send(oTmp,@GetName));
       }
    }
      }

      if First(lReward) = QST_REWARD_MONEY
      {
    oTmp = Send(who,@GetMoneyObject);
    if oTmp = $
    {
       oTmp = Create(&Money,#number=Nth(lReward,2));
       Send(who,@NewHold,#what=oTmp);
    }
    else
    {
       send(oTmp,@AddNumber,#number=Nth(lReward,2));
    }
    Post(Send(oQuester,@GetOwner),@SomeoneSaid,
       #what=oQuester,#type=SAY_RESOURCE,#string = QM_money_congrats);
      }

      if iType = QST_PERM_OBJECT OR iType = QST_TEMP_OBJECT
      {
    Send(self,@KeepOldQuestClass,#mob=oQuester,#class=GetClass(oGoal));
    %take the goal object out of the game
    for i in plQuestOfferObjects
    {
       if i = oGoal
       {
          plQuestOfferObjects = DelListElem(plQuestOfferObjects,i);
          Send(oGoal,@Delete);
       }
    }
      }
      else
      {
    Send(self,@KeepOldQuestPhrase,#mob=oQuester,#phrase=oGoal);
      }
      %delete or recreate
      if (iType = QST_PERM_OBJECT) OR (iType = QST_PERM_PHRASE)
      {
    Send(Self,@RemoveQuestTriggers,#id=id);
    Send(self,@CreateQuest,#type=iType,
         #quester=Send(self,@GetQuester,#id=id),
         #reward=Send(self,@GetQuestReward,#id=id));
    % It should be the case here that any players who have temporary
    % quests based on this quest get that removed.
    Send(Self,@StripTempQuests,#id=id);
      }
      else
      {
    Send(Self,@DeleteQuest,#id=id);
      }

      return True;
   }

   DeleteQuest(id = 0,clean=False)
   "Take the quest out of the Quests Database, and out of any associated mobs"
   {
      local i,iType,oGoal;

      if id = 0 { return; }

      % It should be the case here that any players who have temporary
      % quests based on this quest get that removed.
      Send(Self,@StripTempQuests,#id=id);
      Send(Self,@StripTempQuests,#id=-id);

      iType = Send(self,@GetQuestType,#id=id);
      if iType = QST_PERM_OBJECT OR iType = QST_TEMP_OBJECT
      {   
    oGoal = Send(self,@GetQuestGoal,#id=id);
    for i in plQuestOfferObjects
    {
       if i = oGoal
       {
          plQuestOfferObjects = DelListElem(plQuestOfferObjects,i);
          Send(oGoal,@Delete);
       }
    }
      }

      Send(Self,@RemoveQuestTriggers,#id=id);

      if clean=False
      { Send(Self,@MoveQuesterOff,#who=Send(Self,@GetQuester,#id=id));}

      for i in plQuests
      {
    if id = Nth(i,1)
    {
       plQuests=DelListElem(plQuests,i);
    }
      }
      
      return;
   }

%   (DISABLED -- AJM)
   InstallQuest(quester=$,hinter=$,type=0,goal=$,reward=$,id=0)
   {
%      local i,lQuest;
%     if quester=$ OR hinter=$ or type=0 OR goal=$ OR id=0 OR reward=$
%      {
%         Debug("Error in installation of quest... not all values filled");
%         return;
%      }
%      %if the quest already exists, delete it.
%      for i in plQuests
%      {
%         if id = Nth(i,1)
%         {
%            plQuests=DelListElem(plQuests,i);
%         }
%      }
%      
%      lQuest=[id,quester,hinter,type,goal,reward];
%      plQuests=Cons(lQuest,plQuests);
      return;
   }

%   (DISABLED -- AJM)
   QuestGenerationTimer()
   "We only add a quest if there arent that many in existance. Unless the"
   "random number dictates that we should."
   {
%      local iRnd,iQuester;

      ptQuestGenTimer=$;
%      ptQuestGenTimer=CreateTimer(self,@QuestGenerationTimer,piGenTimerLength);
%      
%      if plQuesterList <> $ AND
%         Random(1,100) > Bound(100*Length(plOnQuestList) /
%                        (Length(plOnQuestList)+Length(plQuesterList)),5,95)
%      {
%         Send(self,@CreateQuest);
%      }
      return;
   }

   RemoveQuestTriggers(id=$)
   {
      local i,j,iType;

      for i in [Send(self,@GetQuester,#id=id),Send(self,@GetHinter,#id=id)]
      {
         Send(self,@DeleteFromMobLib,#mob=i,#id=id);
      }
      iType = Send(Self,@GetQuestType,#id=id);

      if iType = QST_PERM_OBJECT OR iType = QST_TEMP_OBJECT
      {
         Send(Send(self,@GetQuester,#id=id),@CutWantedItem,
                 #class=GetClass(Send(Self,@GetQuestGoal,#id=id)));
      }
      return;
   }

%  (DISABLED -- AJM )
   DispenseTriggers(type=0,id=0,goal=$,quester=$,hinter=$)
   {
%      if isclass(quester,&factions)
%      {
%         Send(self,@AddToMobLib,#mob=quester, #triggers=[LT_errand,LT_favor],
%            #action=[LIBACT_QST_SAY_OBJD,QM_mob_int_phrase,hinter],#id = id);
%         Send(self,@AddToMobLib,#mob=hinter, #triggers=[LT_message],
%            #action=[LIBACT_SAY,QM_hint_msg],#id=id);
%         Send(self,@AddToMobLib,#mob=hinter, #triggers=[Send(quester,@GetName)],
%            #action=[LIBACT_QST_OBJI_LIST,QM_hint_int_phrase,quester,goal],#id=id);
%         return;
%      }

%      if type = QST_PERM_OBJECT OR type = QST_TEMP_OBJECT
%      {
%         Send(quester,@SetWantedItem,#class=GetClass(goal));
%         Send(self,@AddToMobLib,#mob=quester, #triggers=[LT_errand,LT_favor],
%            #action=[LIBACT_SAY,QM_mob_object],#id=id);
%         Send(self,@AddToMobLib,#mob=hinter, #triggers=[LT_errand,LT_favor],
%            #action=[LIBACT_SAY_OBJI_OBJI,QM_hint_object,quester,goal],#id=id);
%         Send(self,@AddToMobLib,#mob=hinter, #percent=QST_RNDM_PERCENT,
%            #action=[LIBACT_SAY_OBJI_OBJI,QM_hint_object,quester,goal],#id=id);
%      }
%      else  %Its a phrase type quest
%      {
%         Send(self,@AddToMobLib,#mob=quester, #triggers=[LT_errand,LT_favor],
%            #action=[LIBACT_QST_SAY_OBJD,QM_mob_phrase,hinter],#id = id);
%         Send(self,@AddToMobLib,#mob=hinter, #triggers=[LT_message],
%            #action=[LIBACT_SAY,QM_hint_msg],#id=id);
%         Send(self,@AddToMobLib,#mob=hinter, #triggers=[Send(quester,@GetName)],
%            #action=[LIBACT_QST_OBJI_LIST,QM_hint_phrase,quester,goal],#id=id);
%      }
      return;
   }

   SelectQuestGoal(type=$)
   {
      local bAlready,iCount,i,j,cGoal,Goal,tmp,tmp2,tmp3;
      Goal=$;
      iCount=0;
      bAlready=False;
      if type = QST_PERM_OBJECT OR type = QST_TEMP_OBJECT
      {
    for i in plQuestOfferClasses
    {
       if Random(0,iCount) = 0 { cGoal = i;} 
       iCount = iCount + 1;
    }

         % if cgoal is already on the quest list, then lets do a reroll.
         for i in plQuestOfferObjects
         {
            if IsClass(i,cgoal)
            {
               bAlready=True;
               iCount=0;
            }
         }

         if bAlready=True
         {
      for i in plQuestOfferClasses
      {
         if Random(0,iCount) = 0 { cGoal = i;} 
         iCount = iCount + 1;
      }
         }

    Goal = Create(cGoal);
    plQuestOfferObjects = Cons(Goal,plQuestOfferObjects);
      }
      else
      {
    iCount=0;
    for i in plQuestDictionary
    {
       if Random(0,iCount) = 0 { tmp = i;}
       iCount = iCount + 1;
    }
    Goal = Cons(tmp,Goal);

    iCount=0;
    for i in plQuestDictionary
    {
       if tmp <> i
       {
          if Random(0,iCount) = 0 { tmp2 = i;}
          iCount = iCount + 1;
       }
    }
    Goal = Cons(tmp2,Goal);

    iCount=0;
    for i in plQuestDictionary
    {
       if tmp <> i AND tmp2 <> i
       {
          if Random(0,iCount) = 0 { tmp3 = i;}
          iCount = iCount + 1;
       }
    }
    Goal = Cons(tmp3,Goal);
      }

      return Goal;
   }


   SelectQuestReward()
   {
      local iInt,lReward,lTemp,iCount;

      if Random(1,2) = 1
      {
         lReward=[QST_REWARD_MONEY,Random(QST_LOW_MONEY,QST_HIGH_MONEY)];
      }
      else
      {
         lTemp=$;
         iCount=0;
         while 1 = 1
         {
            iCount= iCount+1;
            lTemp = Cons(Nth(plQuestRewards,Random(1,Length(plQuestRewards))),
                         lTemp);
            if Random(0,QST_MAX_ITEMS) <= iCount {break;}
         }
         lReward=[QST_REWARD_ITEMLIST,lTemp];
      }
      return lReward;
   }

   SelectQuester()
   {
      local iCount,i,oMob;
      oMob=$;
      iCount=0;
      for i in plQuesterList
      {
         if Random(0,iCount) = 0 { oMob = i;} 
         iCount = iCount + 1;
      }
      return oMob;
   }

   SelectHinter()
   {
      local iCount,i,oMob;
      oMob=$;
      iCount=0;
      for i in plHinterList
      {
         if Random(0,iCount) = 0 { oMob = i;} 
         iCount = iCount + 1;
      }
      return oMob;
   }

% ACCESS THE EXISTING QUEST DATABASE
%
% Quest = [ id, quester, hinter, type, goal, [ reward ], 


   GetQuestID(who = $)
   {
      local i;
      for i in plQuests
      {
         if who = Nth(i,2) { return Nth(i,1); }
      }
      return 0;
   } 

   GetQuester(id = $)
   {
      local i;
      for i in plQuests
      {
         if First(i) = id { return Nth(i,2); }
      }
      return $;
   }

   GetHinter(id = $)
   {
      local i;
      for i in plQuests
      {
         if First(i) = id { return Nth(i,3); }
      }
      return $;
   }

   GetQuestType(id = $)
   {
      local i;
      for i in plQuests
      {
         if First(i) = id { return Nth(i,4); }
      }
      return 0;
   }

   GetQuestGoal(id = $)
   {
      local i;
      for i in plQuests
      {
         if First(i) = id { return Nth(i,5); }
      }
      return $;
   }

   GetQuestReward(id = $)
   {
      local i;
      for i in plQuests
      {
         if First(i) = id { return Nth(i,6); }
      }
      return $;
   }

   GetNextQuestID()
   {
      piNextQuestID= piNextQuestID + 1;
      return piNextQuestID;
   }   

   GetOldPhrases(mob=$)
   {
      local i;
      for i in plOldQuestPhrases
      {
         if First(i) = mob { return Nth(i,2); }
      }
      return $;
   }

   GetOldClasses(mob=$)
   {
      local i;
      for i in plOldQuestClasses
      {
         if First(i) = mob { return Nth(i,2); }
      }
      return $;
   }

   KeepOldQuestClass(mob=$,class=$)
   {
      local i,lElem;
 
      for i in plOldQuestClasses
      {
         if First(i) = mob
         {
            SetNth(i,2,Cons(class,Nth(i,2)));
            if Length(Nth(i,2)) > 4
            {
               lElem=Nth(i,2);
               lElem=DelListElem(lElem,Nth(lElem,5));
               SetNth(i,2,lElem);
            }
            return;
         }
      }
      plOldQuestClasses=Cons([mob,[class]],plOldQuestClasses);
      return;
   }

   KeepOldQuestPhrase(mob=$,phrase=$)
   {
      local i,lElem;
 
      for i in plOldQuestPhrases
      {
         if First(i) = mob
         {
            SetNth(i,2,Cons(phrase,Nth(i,2)));
            if Length(Nth(i,2)) > 4
            {
               lElem=Nth(i,2);
               lElem=DelListElem(lElem,Nth(lElem,5));
               SetNth(i,2,lElem);
            }
            return;
         }
      }
      plOldQuestPhrases=Cons([mob,[phrase]],plOldQuestPhrases);
      return;
   }

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
   %
   % SIGNETS Added 11/04/96 by jrmurphy
   %
   %%%%%%%%%%%%%%

   IsNewbieSignetEligible(who=$)
   {
     local i;
     if who=$ {return False;}

     for i in plSignetNewbies
     {
       if i=who { return False;}
     } 
     return True;
   }

   CreateSignetRing(who=$)
   {
      %This routine needs to put the who onto the newbie list, and find a
      %suitible mob to be the owner, and then call the create routine.
      local mob,i,iCnt;

     
      if piSignetLock=True { return $;}

      if who<>$
      {
        plSignetNewbies=Cons(who,plSignetNewbies);
        while Length(plSignetNewbies)>Send(self,@GetMaxSignetNewbies)
        {
          plSignetNewbies=DelListElem(plSignetNewbies,
                                  Nth(plSignetNewbies,Length(plSignetNewbies)));
        }
      }

      if plHinterlist=$ {return $;}

      iCnt = 0;
     mob = $;
      For i in plHinterList
      {
        if ((Send(i,@GetAttributes) & MOB_RECEIVE) <> 0) and
               ((Send(i,@GetAttributes) & MOB_NOQUEST) = 0) and
               (isClass(i,&BarloqueTown) or
                isClass(i,&CorNothTown) or
                isClass(i,&JasperTown) or
                isClass(i,&MarionTown) or
                isClass(i,&TosTown) or 
                isClass(i,&Wanderer))
        {
          if Random(0,iCnt)=0 { mob=i; }
          iCnt=iCnt+1;
        }
      }
      if mob = $ {return $;}
      return Create(&SignetRing,#mob=mob);
   }

   RegisterSignet(newring=$)
   {
      local oldring, oRingOwner;
      %This routine adds the signet ring to the front of the rings list.
      %If the number of rings on the list exceeds the max number, then a
      %ring is deleted from the end of the list.

      if newring=$ {return;}
      plSignetRings=Cons(newring,plSignetRings);
      while Length(plSignetRings)>Send(self,@GetMaxSignets)
      {
        oldring=Nth(plSignetRings,Length(plSignetRings));
        plSignetRings=DelListElem(plSignetRings,oldring);
      
      oRingOwner=send(oldRing,@getowner);
      if oRingOwner <> $
        { send(oRingOwner,@msgsenduser,#message_rsc=lib_signet_lost); }
        
      Send(oldring,@delete);
      }
      return;
   }

   SignetDelivered(who=$)
   {
     if who=$ {return;}
     plSignetNewbies=Cons(who,plSignetNewbies);
     while Length(plSignetNewbies)>Send(self,@GetMaxSignetNewbies)
     {
       plSignetNewbies=DelListElem(plSignetNewbies,
                               Nth(plSignetNewbies,Length(plSignetNewbies)));
     }
     return;
   }

   UnregisterSignet(newring=$)
   {
     local i;

     if newring=$ {return;}
    for i in plSignetRings            %% safety measure, only delete the ring if it's in the list
    {
       if i = newring
      {  plSignetRings=DelListElem(plSignetRings,newring); }
    }
     return;
   }

   SetSignetLock(value=False)
   {
     piSignetLock=value;
     return;
   }

   ClearSignets()
   {
     local i;
     for i in plSignetRings
     {
       Send(i,@Delete);
     }
     plSignetRings=$;
     plSignetNewbies=$;
     return;
   }

   GetMaxSignetNewbies()
   {
      return piMaxSignetNewbies;
   }

   GetMaxSignets()
   {
      return piMaxSignets;
   }

   GetSignetChance()
   {
     return piSignetChance;
   }
  
   GetSignetRings()
   {
      return plSignetRings;
   }


  % Signet Info:
  % Variables: MaxSignets = number of signets in game at once
  %            MaxSignetNewbies = number of newbies blocked from using signets
  %            SignetChance = percentage of newbie kills spawning signets 
  %            SignetLock = True/False allow generation of signets or not
  %    ****All of these respond to GetXXXX or SetXXXX,#value=yyyy
  % Lists:     SignetRings = all the signets in the game.
  %            SignetNewbies = newbies who have created or delivered signets.
  %
  % Newbies are those who are not pk enabled.
  % On newbie kill, if the newbie is not on plSignetNewbies, then signet is
  % generated based on SignetChance. The newbie is added to plSignetNewbies.
  % The signet is added to plSignetRings. both These lists are pruned to be
  % less than their Max values. Pruned newbies are free to earn signets again.
  % Pruned rings are deleted (basically a delivery timeout...) Initially the
  % rings and newbies are set at 20... These may need to be tweaked so that
  % there is 30min or so to deliver signets when play is crowded with newbies.
  %
  % Upon creation, a mob is selected to be the receiver of the signet. The
  % signetring class is added to their plWantedItems List, and the mob is
  % stored as the poRingOwner in the signet itself. When offered to the mob,
  % the CheckWhyWanted routine is chosen, and it determines that the signet
  % offered is the one desired, and then gives a bonus money amount. If its
  % not the proper ring, its returned to the player. If it is the right ring
  % the newbie is again added to the plSignetNewbies list. The SignetRing
  % class is removed from the mob's plWantedItem list. It is also unregisterd
  % from the library (removed from the plSignetRings list).
  %
  % If needed, the ClearSignets routine in the library can be called to do
  % a restart of all signets. Also, the SetSignetLock routine can be called
  % to prevent the generation of any future signets. 
  % 
  % If a signet is dropped, or left on the ground, it will eventually blink
  % (like the tokens) to the center of the room. This is to keep them out
  % of the water. Also, if a non-newbie returns the token, then they dont
  % get any money and their name is added to the plSignetNewbies list (in
  % effect bumping a real newbie off the list).
  %
  % When a signet is deleted, it sends a message to a logged on user
  % that is holding it, which indicates that the player lost the ring.
  % This might happen if the player takes too long to deliver it.
  % If the player logs off with the ring, it will likely be gone when they
  % log back on the next day. Currently there is no message for this.
  % it may be seen as a bug. Any suggestions on dealing with this are
  % appreciated.


   PlayerManaNodeList(mob = $, person = $)
   "Tell the player the list of mana nodes they have bonded with."
   {
      local iNodeList, index, oNode, count;

      if mob = $ or person = $ or NOT IsClass(person, &User)
      {
         return;
      }

      iNodeList = Send(person, @GetNodeList);

      if iNodeList = 0
      {
         Send(Send(mob, @GetOwner), @SomeoneSaid, #what=mob, #type=SAY_RESOURCE, 
              #string = LM_no_mana_nodes);
         return;
      }

      index = 1;
      count = 0;
      ClearTempString();
      while index <= NODE_MAX_VALUE
      {
         if iNodelist & index
         {
            oNode = Send(SYS, @FindNodeByNum, #num = index);
            if oNode <> $
            {
               if count <> 0
               {
                  AppendTempString(", ");
               }

               AppendTempString(Send(oNode, @GetLocationName));
               count = count + 1;
            }
         }
         index = 2 * index;
      }
      
      Send(Send(mob, @GetOwner), @SomeoneSaid, #what=mob, #type=SAY_RESOURCE,
           #string = LM_mana_nodes,
           #parm1 = GetTempString());
      return;      
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


